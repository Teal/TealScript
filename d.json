{
    "TypeNode": {
        "indent": 0,
        "doc": false,
        "extends": "Node",
        "comment": "类型节点",
        "name": "TypeNode",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "precedence",
                "equal": "Precedence.any",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": [
            "let result: @TypeNode;",
            "if (isPredefinedType(this.lexer.peek().type)) {",
            "\tresult = @PredefinedTypeNode();",
            "} else {",
            "\tswitch (this.lexer.peek().type) {",
            "\t\t//+ case 'identifier':",
            "\t\t//+ \tresult = @GenericTypeOrTypeReferenceNode();",
            "\t\t//+ \tbreak;",
            "\t\tcase '(':",
            "\t\t\tresult = @FunctionOrParenthesizedTypeNode();",
            "\t\t\tbreak;",
            "\t\tcase '[':",
            "\t\t\tresult = @TupleTypeNode();",
            "\t\t\tbreak;",
            "\t\tcase '{':",
            "\t\t\tresult = @ObjectTypeNode();",
            "\t\t\tbreak;",
            "\t\tcase 'new':",
            "\t\t\treturn @ConstructorTypeNode();",
            "\t\tcase '<':",
            "\t\t\treturn @FunctionTypeNode(@TypeParameters(), @Parameters());",
            "\t\tcase 'typeof':",
            "\t\t\tresult = @TypeQueryNode();",
            "\t\t\tbreak;",
            "\t\tcase '=>':",
            "\t\t\treturn @FunctionTypeNode();",
            "\t\tcase 'numericLiteral':",
            "\t\tcase 'stringLiteral':",
            "\t\tcase 'true':",
            "\t\tcase 'false':",
            "\t\t\tresult = @LiteralTypeNode();",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tresult = @GenericTypeOrTypeReferenceNode();",
            "\t\t\tbreak;",
            "\t}",
            "}",
            "while (getPrecedence(this.lexer.peek().type) >= precedence) {",
            "\tswitch (this.lexer.peek().type) {",
            "\t\tcase '.':",
            "\t\t\tresult = @QualifiedNameTypeNode(result);",
            "\t\t\tcontinue;",
            "\t\tcase '[':",
            "\t\t\tif (@sameLine) {",
            "\t\t\t\tresult = @ArrayTypeNode(result);",
            "\t\t\t}",
            "\t\t\tcontinue;",
            "\t\tcase '&':",
            "\t\tcase '|':",
            "\t\tcase 'is':",
            "\t\t\tresult = @BinaryTypeNode(result);",
            "\t\t\tcontinue;",
            "\t}",
            "\tbreak;",
            "}",
            "return result;"
        ]
    },
    "PredefinedTypeNode": {
        "indent": 2,
        "doc": false,
        "extends": "TypeNode",
        "comment": "内置类型节点(`number`、`string`、...)",
        "name": "PredefinedTypeNode",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "type",
                "comment": "类型",
                "args": "",
                "equals": "",
                "type": "'any'|'number'|'boolean'|'string'|'symbol'|'void'|'never'|'this'|'null'|'undefined'|'char'|'byte'|'int'|'long'|'short'|'uint'|'ulong'|'ushort'|'float'|'double'|'*'|'?'"
            }
        ],
        "codes": []
    },
    "GenericTypeOrTypeReferenceNode": {
        "indent": 4,
        "doc": false,
        "extends": "Node",
        "comment": "泛型类型节点(`x<T>`)或类型引用节点(`x`)",
        "name": "GenericTypeOrTypeReferenceNode",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "let result = @TypeReferenceNode();",
            "if (@sameLine && this.lexer.peek().type === '<') {",
            "\treturn @GenericTypeNode(result);",
            "}",
            "return result;"
        ]
    },
    "GenericTypeNode": {
        "indent": 5,
        "doc": false,
        "extends": "TypeNode",
        "comment": "泛型类型节点(`Array<number>`)",
        "name": "GenericTypeNode",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "target",
                "comment": "目标部分",
                "args": "",
                "equals": "",
                "type": "TypeReferenceNode"
            },
            {
                "optional": false,
                "name": "typeArguments",
                "comment": "类型参数部分",
                "args": "",
                "equals": "",
                "type": "TypeArguments"
            }
        ],
        "codes": []
    },
    "TypeArguments": {
        "indent": 6,
        "doc": false,
        "extends": "Node",
        "comment": "类型参数列表(`<number>`)",
        "name": "TypeArguments",
        "equals": "< ... TypeArgument , isTypeNodeStart ... >",
        "params": [],
        "parts": [],
        "codes": []
    },
    "TypeArgument": {
        "indent": 7,
        "doc": false,
        "extends": "Node",
        "comment": "类型参数(`number`)",
        "name": "TypeArgument",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "value",
                "comment": "值",
                "args": "Precedence.assignment",
                "equals": "",
                "type": "TypeNode"
            }
        ],
        "codes": []
    },
    "TypeReferenceNode": {
        "indent": 5,
        "doc": false,
        "extends": "TypeNode",
        "comment": "类型引用节点(`x`)",
        "name": "TypeReferenceNode",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "value",
                "comment": "值部分",
                "args": "",
                "equals": "",
                "type": "'identifier'"
            }
        ],
        "codes": [
            "if (isIdentifierName(this.lexer.peek().type)) {",
            "\tconst result = new @TypeReferenceNode();",
            "\tresult.start = @read;",
            "\tresult.value = @lexer.current.value;",
            "\tresult.end = @lexer.current.end;",
            "\treturn result;",
            "}",
            "@error(@lexer.peek(), \"Type expected. Unexpected token '{0}'.\", getTokenName(this.lexer.peek().type));",
            "return @ErrorTypeNode();"
        ]
    },
    "ErrorTypeNode": {
        "indent": 6,
        "doc": false,
        "extends": "TypeNode",
        "comment": "错误的类型节点",
        "name": "ErrorTypeNode",
        "equals": "",
        "params": [
            {
                "comment": "标记的开始位置",
                "name": "start",
                "equal": "@lexer.current.end",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": [
            "const result = new @ErrorTypeNode();",
            "result.start = start;",
            "result.end = @lexer.current.end;",
            "return result;"
        ]
    },
    "FunctionOrParenthesizedTypeNode": {
        "indent": 4,
        "doc": false,
        "extends": "TypeNode",
        "comment": "函数(`()=> void`)或括号类型节点(`(x)`)",
        "name": "FunctionOrParenthesizedTypeNode",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": [
            "const savedState = @stashSave();",
            "const parameters = @Parameters();",
            "if (this.lexer.peek().type === '=>') {",
            "\t@stashClear(savedState);",
            "\treturn @FunctionTypeNode(undefined, parameters);",
            "}",
            "@stashRestore(savedState);",
            "return @ParenthesizedTypeNode();"
        ]
    },
    "FunctionTypeNode": {
        "indent": 5,
        "doc": false,
        "extends": "TypeNode",
        "comment": "函数类型节点(`(x: number) => void`)。",
        "name": "FunctionTypeNode",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "typeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "TypeParameters"
            },
            {
                "optional": true,
                "name": "parameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Parameters"
            },
            {
                "optional": false,
                "name": "",
                "comment": "",
                "args": "",
                "equals": ">",
                "type": ""
            },
            {
                "optional": false,
                "name": "returnType",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "TypeNode"
            }
        ],
        "codes": []
    },
    "TypeParameters": {
        "indent": 6,
        "doc": false,
        "extends": "Node",
        "comment": "类型参数列表(`<T>`)",
        "name": "TypeParameters",
        "equals": "< ... TypeParameterDeclaration , isIdentifierName ... >",
        "params": [],
        "parts": [],
        "codes": []
    },
    "TypeParameterDeclaration": {
        "indent": 7,
        "doc": false,
        "extends": "Declaration",
        "comment": "类型参数声明(`T`、`T extends R`)",
        "name": "TypeParameterDeclaration",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": "extends",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "extends",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "TypeNode"
            }
        ],
        "codes": [
            "const result = new @TypeParameterDeclaration();",
            "result.name = @Identifier();",
            "if (this.lexer.peek().type === 'extends') {",
            "\tresult.extendsToken = @readToken('extends');",
            "\tresult.extends = @TypeNode();",
            "}",
            "return result;"
        ]
    },
    "Parameters": {
        "indent": 6,
        "doc": false,
        "extends": "Node",
        "comment": "参数列表(`(x, y)`)",
        "name": "Parameters",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "... ParameterDeclaration",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "isBindingElementStart ...",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": []
    },
    "ParameterDeclaration": {
        "indent": 7,
        "doc": false,
        "extends": "Declaration",
        "comment": "参数声明(`x`、`x?: number`)",
        "name": "ParameterDeclaration",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": true,
                "name": "modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Modifiers"
            },
            {
                "optional": true,
                "name": "...",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "BindingName"
            },
            {
                "optional": true,
                "name": "?",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Initializer",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "BindingName": {
        "indent": 8,
        "doc": false,
        "extends": "Node",
        "comment": "绑定名称(`x`, `[x]`, `{x: x}`)",
        "name": "BindingName",
        "equals": "Identifier | ArrayBindingPattern | ObjectBindingPattern",
        "params": [],
        "parts": [],
        "codes": []
    },
    "ArrayBindingPattern": {
        "indent": 9,
        "doc": false,
        "extends": "Node",
        "comment": "数组绑定模式项(`[x]`)",
        "name": "ArrayBindingPattern",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "elements",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "[ ArrayBindingElement , isArrayBindingElementStart ... ]"
            }
        ],
        "codes": []
    },
    "ArrayBindingElement": {
        "indent": 10,
        "doc": false,
        "extends": "Node",
        "comment": "数组绑定模式项(`x`)",
        "name": "ArrayBindingElement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": true,
                "name": "...",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "value",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "BindingName"
            },
            {
                "optional": true,
                "name": "Initializer",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "ObjectBindingPattern": {
        "indent": 9,
        "doc": false,
        "extends": "Node",
        "comment": "对象绑定模式项(`{x: x}`)",
        "name": "ObjectBindingPattern",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "elements: { ObjectBindingElement , isObjectBindingElementStart ... }"
        ]
    },
    "ObjectBindingElement": {
        "indent": 10,
        "doc": false,
        "extends": "Node",
        "comment": "对象绑定模式项(`x`)",
        "name": "ObjectBindingElement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": true,
                "name": "...",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "key",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "PropertyName,"
            },
            {
                "optional": true,
                "name": "",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "value",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "BindingName"
            },
            {
                "optional": true,
                "name": "Initializer",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "PropertyName": {
        "indent": 11,
        "doc": false,
        "extends": "Node",
        "comment": "属性名称(`xx`、`\"xx\"`、`0`、`[xx]`)",
        "name": "PropertyName",
        "equals": "Identifier | NumericLiteral | StringLiteral | ComputedPropertyName",
        "params": [],
        "parts": [],
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\t//+ case 'identifier':",
            "\t//+ \treturn @Identifier(true);",
            "\tcase 'stringLiteral':",
            "\t\treturn @StringLiteral();",
            "\tcase 'numericLiteral':",
            "\t\treturn @NumericLiteral();",
            "\tcase '[':",
            "\t\treturn @ComputedPropertyName();",
            "\tdefault:",
            "\t\treturn @Identifier(true);",
            "}"
        ]
    },
    "ComputedPropertyName": {
        "indent": 14,
        "doc": false,
        "extends": "Node",
        "comment": "已计算的属性名(`[1]`)",
        "name": "ComputedPropertyName",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "[",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "body",
                "comment": "",
                "args": "Precedence.assignment",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": false,
                "name": "]",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "TypeAnnotation": {
        "indent": 8,
        "doc": false,
        "extends": "Node",
        "comment": "类型注解(`: number`)",
        "name": "TypeAnnotation",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "result",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "type",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "TypeNode"
            }
        ],
        "codes": [
            ":"
        ]
    },
    "Initializer": {
        "indent": 8,
        "doc": false,
        "extends": "Node",
        "comment": "初始值",
        "name": "Initializer",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "result",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "allowIn",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "initializer",
                "comment": "",
                "args": "Precedence.assignment, allowIn",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": []
    },
    "ParenthesizedTypeNode": {
        "indent": 5,
        "doc": false,
        "extends": "TypeNode",
        "comment": "括号类型节点(`(number)`)",
        "name": "ParenthesizedTypeNode",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "(",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "body",
                "comment": "主体部分",
                "args": "",
                "equals": "",
                "type": "TypeNode"
            },
            {
                "optional": false,
                "name": ")",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "TupleTypeNode": {
        "indent": 4,
        "doc": false,
        "extends": "TypeNode",
        "comment": "元祖类型节点(`[string, number]`)",
        "name": "TupleTypeNode",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "elements",
                "comment": "所有元素",
                "args": "",
                "equals": "",
                "type": "[ ... TupleTypeElement , isTypeNodeStart ... ]"
            }
        ],
        "codes": []
    },
    "TupleTypeElement": {
        "indent": 5,
        "doc": false,
        "extends": "Node",
        "comment": "元祖类型节点元素(`x`)",
        "name": "TupleTypeElement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "value",
                "comment": "",
                "args": "Precedence.assignment",
                "equals": "",
                "type": "TypeNode"
            }
        ],
        "codes": []
    },
    "ObjectTypeNode": {
        "indent": 4,
        "doc": false,
        "extends": "TypeNode",
        "comment": "对象类型节点(`{x: number}`)",
        "name": "ObjectTypeNode",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "elements: { TypeMemberSignature ... }"
        ]
    },
    "TypeMemberSignature": {
        "indent": 5,
        "doc": false,
        "extends": "Node",
        "comment": "类型成员签名(`x： y`、`x() {...}`)",
        "name": "TypeMemberSignature",
        "equals": "PropertySignature | CallSignature | ConstructSignature | IndexSignature | MethodSignature | AccessorSignature",
        "params": [],
        "parts": [],
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\t//+ case 'identifier':",
            "\t//+ \tbreak;",
            "\tcase 'get':",
            "\tcase 'set':",
            "\t\tconst savedToken = @lexer.current;",
            "\t\t@lexer.read();",
            "\t\tif (isKeyword(this.lexer.peek().type) || this.lexer.peek().type === '[') {",
            "\t\t\treturn @AccessorSignature(savedToken.type === 'get' ? savedToken.start : undefined, savedToken.type === 'set' ? savedToken.start : undefined);",
            "\t\t}",
            "\t\t@lexer.current = savedToken;",
            "\t\tbreak;",
            "\tcase '[':",
            "\t\tlet isIndexSignature;",
            "\t\tconst savedToken = @lexer.current;",
            "\t\t@lexer.read();",
            "\t\tif (isIdentifierName(this.lexer.peek().type)) {",
            "\t\t\t@lexer.read();",
            "\t\t\tisIndexSignature = this.lexer.peek().type === ':';",
            "\t\t}",
            "\t\t@lexer.current = savedToken;",
            "\t\tif (isIndexSignature) {",
            "\t\t\treturn @IndexSignature();",
            "\t\t}",
            "\t\tbreak;",
            "\tcase '(':",
            "\t\treturn @CallSignature();",
            "\tcase 'new':",
            "\t\treturn @ConstructSignature();",
            "}",
            "const name = @PropertyName();",
            "const questionToken = this.lexer.peek().type === '?' ? @readToken('?') : undefined;",
            "switch (this.lexer.peek().type) {",
            "\tcase '(':",
            "\tcase '<':",
            "\t\treturn @MethodSignature(name, questionToken);",
            "\tdefault:",
            "\t\treturn @PropertySignature(name, questionToken);",
            "}"
        ]
    },
    "PropertySignature": {
        "indent": 6,
        "doc": true,
        "extends": "Node",
        "comment": "属性签名(`x: number`)",
        "name": "PropertySignature",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "name": "?",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "ObjectMemberTail",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "CallSignature": {
        "indent": 6,
        "doc": true,
        "extends": "Node",
        "comment": "函数签名(`(): number`)",
        "name": "CallSignature",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": true,
                "name": "TypeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "Parameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "ObjectMemberTail",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "ConstructSignature": {
        "indent": 6,
        "doc": true,
        "extends": "Node",
        "comment": "构造函数签名(`new x(): number`)",
        "name": "ConstructSignature",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "new",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "Parameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "ObjectMemberTail",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "IndexSignature": {
        "indent": 6,
        "doc": true,
        "extends": "Node",
        "comment": "索引器声明(`get x() {...}`、`set x(value) {...}`)",
        "name": "IndexSignature",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "[",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "argument",
                "comment": "",
                "args": "false",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "]",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "ObjectMemberTail",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "MethodSignature": {
        "indent": 6,
        "doc": true,
        "extends": "Node",
        "comment": "方法签名(`x(): number`)",
        "name": "MethodSignature",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "name": "?",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "Parameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "ObjectMemberTail",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "AccessorSignature": {
        "indent": 6,
        "doc": true,
        "extends": "Node",
        "comment": "访问器签名(`get x(): number`、`set x(value): void`)",
        "name": "AccessorSignature",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "get",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "set",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "name": "?",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "Parameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "ObjectMemberTail",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "ObjectMemberTail": {
        "indent": 6,
        "doc": false,
        "extends": "Node",
        "comment": "对象成员尾部",
        "name": "ObjectMemberTail",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "result",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": ",",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "if (this.lexer.peek().type === ';') {",
            "\tresult.semicolonToken = @readToken(';');",
            "} else if (this.lexer.peek().type === ',') {",
            "\tresult.commaToken = @readToken(',');",
            "} else if (@sameLine) {",
            "\tthis.error({ start: this.lexer.current.end, end: this.lexer.current.end }, \"Missing ';' after property.\");",
            "}"
        ]
    },
    "ConstructorTypeNode": {
        "indent": 4,
        "doc": false,
        "extends": "TypeNode",
        "comment": "构造函数类型节点(`new () => void`)",
        "name": "ConstructorTypeNode",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "new",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "Parameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "",
                "comment": "",
                "args": "",
                "equals": ">",
                "type": ""
            },
            {
                "optional": false,
                "name": "return",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "TypeNode"
            }
        ],
        "codes": []
    },
    "TypeQueryNode": {
        "indent": 4,
        "doc": false,
        "extends": "TypeNode",
        "comment": "类型查询节点(`typeof x`)",
        "name": "TypeQueryNode",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "typeof",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "operand",
                "comment": "",
                "args": "Precedence.postfix",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": []
    },
    "LiteralTypeNode": {
        "indent": 4,
        "doc": false,
        "extends": "TypeNode",
        "comment": "字面量类型节点(`\"abc\"`、`true`)",
        "name": "LiteralTypeNode",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "body",
                "comment": "",
                "args": "Precedence.primary",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": []
    },
    "QualifiedNameTypeNode": {
        "indent": 4,
        "doc": false,
        "extends": "TypeNode",
        "comment": "限定名称类型节点(`\"abc\"`、`true`)",
        "name": "QualifiedNameTypeNode",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "target",
                "comment": "目标部分",
                "args": "",
                "equals": "",
                "type": "TypeNode"
            },
            {
                "optional": false,
                "name": ".",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "argument",
                "comment": "参数部分",
                "args": "true",
                "equals": "@MemberCallArgument()",
                "type": "Identifier"
            }
        ],
        "codes": []
    },
    "ArrayTypeNode": {
        "indent": 4,
        "doc": false,
        "extends": "TypeNode",
        "comment": "数组类型节点(`T[]`)",
        "name": "ArrayTypeNode",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "target",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "TypeNode"
            },
            {
                "optional": false,
                "name": "[",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "]",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "BinaryTypeNode": {
        "indent": 4,
        "doc": false,
        "extends": "TypeNode",
        "comment": "双目表达式(x + y、x = y、...)",
        "name": "BinaryTypeNode",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "left",
                "comment": "左值部分",
                "args": "",
                "equals": "",
                "type": "TypeNode"
            },
            {
                "optional": false,
                "name": "operator",
                "comment": "运算类型",
                "args": "",
                "equals": "",
                "type": "'&'|'|'|'is'"
            },
            {
                "optional": false,
                "name": "right",
                "comment": "右值部分",
                "args": "getPrecedence(result.operator",
                "equals": "",
                "type": "TypeNode + 1)"
            }
        ],
        "codes": []
    },
    "Expression": {
        "indent": 0,
        "doc": false,
        "extends": "Node",
        "comment": "表达式",
        "name": "Expression",
        "equals": "",
        "params": [
            {
                "comment": "允许解析的最低操作符优先级",
                "name": "precedence",
                "equal": "Precedence.any",
                "question": false,
                "type": ""
            },
            {
                "comment": "是否解析 in 表达式。",
                "name": "allowIn",
                "equal": "true",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": [
            "let result: @Expression;",
            "switch (this.lexer.peek().type) {",
            "\tcase 'identifier':",
            "\t\tresult = @ArrowFunctionOrGenericExpressionOrIdentifier(allowIn);",
            "\t\tbreak;",
            "\tcase 'this':",
            "\tcase 'null':",
            "\tcase 'true':",
            "\tcase 'false':",
            "\tcase 'super':",
            "\t\tresult = @SimpleLiteral();",
            "\t\tbreak;",
            "\tcase '(':",
            "\t\tresult = @ArrowFunctionOrParenthesizedExpression(allowIn);",
            "\t\tbreak;",
            "\tcase 'numericLiteral':",
            "\t\tresult = @NumericLiteral();",
            "\t\tbreak;",
            "\tcase 'stringLiteral':",
            "\tcase 'noSubstitutionTemplateLiteral':",
            "\t\tresult = @StringLiteral();",
            "\t\tbreak;",
            "\tcase '[':",
            "\t\tresult = @ArrayLiteral();",
            "\t\tbreak;",
            "\tcase '{':",
            "\t\tresult = @ObjectLiteral();",
            "\t\tbreak;",
            "\tcase 'function':",
            "\t\tresult = @FunctionExpression();",
            "\t\tbreak;",
            "\tcase 'new':",
            "\t\tresult = @NewTargetOrNewExpression();",
            "\t\tbreak;",
            "\tcase '/':",
            "\tcase '/=':\t",
            "\t\tresult = @RegularExpressionLiteral();",
            "\t\tbreak;",
            "\tcase 'templateHead':",
            "\t\tresult = @TemplateLiteral();",
            "\t\tbreak;",
            "\tcase '<':",
            "\t\tresult = @ArrowFunctionOrTypeAssertionExpression(allowIn);",
            "\t\tbreak;",
            "\tcase 'yield':",
            "\t\tresult = @YieldExpression(allowIn);",
            "\t\tbreak;",
            "\tcase 'await':",
            "\t\tresult = @AwaitExpressionOrIdentifier(allowIn);",
            "\t\tbreak;",
            "\tcase 'class':",
            "\t\tresult = @ClassExpression();",
            "\t\tbreak;",
            "\tcase 'async':",
            "\t\tresult = @AsyncFunctionExpressionOrIdentifier(allowIn);",
            "\t\tbreak;",
            "\tcase '=>':",
            "\t\tresult = @ArrowFunctionExpression(undefined, undefined, undefined, allowIn);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (isUnaryOperator(this.lexer.peek().type)) {",
            "\t\t\tresult = @UnaryExpression();",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (isIdentifierName(this.lexer.peek().type)) {",
            "\t\t\tresult = @ArrowFunctionOrGenericExpressionOrIdentifier(allowIn);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t@error(@lexer.peek(), @isKeyword(this.lexer.peek().type) ? \"Expression expected; '{0}' is a keyword.\" : \"Expression expected; Unexpected token '{0}'.\", getTokenName(this.lexer.peek().type));",
            "\t\treturn @ErrorIdentifier(isStatementStart(this.lexer.peek().type) ? @lexer.current.end : @read);",
            "}",
            "while (getPrecedence(this.lexer.peek().type) >= precedence) {",
            "\tswitch (this.lexer.peek().type) {",
            "\t\tcase '.':",
            "\t\t\tresult = @MemberCallExpression(result);",
            "\t\t\tcontinue;",
            "\t\t//+ case '=':",
            "\t\t//+ \tbreak;",
            "\t\tcase '(':",
            "\t\t\tresult = @FunctionCallExpression(result);",
            "\t\t\tcontinue;",
            "\t\tcase '[':",
            "\t\t\tresult = @IndexCallExpression(result);",
            "\t\t\tcontinue;",
            "\t\tcase '?':",
            "\t\t\tresult = @ConditionalExpression(result, allowIn);",
            "\t\t\tcontinue;",
            "\t\tcase '++':",
            "\t\tcase '--':",
            "\t\t\tif (!@sameLine) {",
            "\t\t\t\treturn result;",
            "\t\t\t}",
            "\t\t\tresult = @PostfixExpression(result);",
            "\t\t\tcontinue;",
            "\t\tcase 'noSubstitutionTemplateLiteral':",
            "\t\t\tresult = @TemplateCallExpression(parsed, @StringLiteral());",
            "\t\t\tcontinue;",
            "\t\tcase 'templateHead':",
            "\t\t\tresult = @TemplateCallExpression(parsed, @TemplateLiteral());",
            "\t\t\tcontinue;",
            "\t\tcase '>':",
            "\t\t\tconst savedToken = @lexer.current;",
            "\t\t\t@lexer.readAsGreaterThanTokens();",
            "\t\t\t@lexer.current = savedToken;",
            "\t\t\tbreak;",
            "\t\tcase 'in':",
            "\t\t\tif (allowIn === false) {",
            "\t\t\t\treturn result;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t}",
            "\tresult = @BinaryExpression(result, allowIn);",
            "}",
            "return result;"
        ]
    },
    "ArrowFunctionOrGenericExpressionOrIdentifier": {
        "indent": 3,
        "doc": false,
        "extends": "Node",
        "comment": "箭头函数(`x => y`)或泛型表达式(`x<T>`)或标识符(`x`)",
        "name": "ArrowFunctionOrGenericExpressionOrIdentifier",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "allowIn",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": [
            "let result = @Identifier();",
            "switch (this.lexer.peek().type) {",
            "\tcase '=>':",
            "\t\tresult = @ArrowFunctionExpression(undefined, undefined, result, allowIn);",
            "\t\tbreak;",
            "\tcase '<':",
            "\t\tif (@sameLine) {",
            "\t\t\tconst savedState = @stashSave();",
            "\t\t\tconst typeArguments = @TypeArguments();",
            "\t\t\tif (@current === '>' && (isBinaryOperator(this.lexer.peek().type) || !isUnaryOperator(this.lexer.peek().type))) {",
            "\t\t\t\t@stashClear(savedState);",
            "\t\t\t\tresult = @GenericExpression(result, typeArguments);",
            "\t\t\t} else {",
            "\t\t\t\t@stashRestore(savedState);",
            "\t\t\t}",
            "\t\t}",
            "\t\tbreak;",
            "}",
            "return result;"
        ]
    },
    "GenericExpression": {
        "indent": 6,
        "doc": false,
        "extends": "Expression",
        "comment": "泛型表达式(`x<number>`)",
        "name": "GenericExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "target",
                "comment": "目标部分",
                "args": "",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": false,
                "name": "typeArguments",
                "comment": "类型参数部分",
                "args": "",
                "equals": "",
                "type": "TypeArguments"
            }
        ],
        "codes": []
    },
    "Identifier": {
        "indent": 4,
        "doc": false,
        "extends": "Node",
        "comment": "标识符(`x`)",
        "name": "Identifier",
        "equals": "",
        "params": [
            {
                "comment": "是否允许解析关键字",
                "name": "allowKeyword",
                "equal": "false",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "value",
                "comment": "值部分",
                "args": "",
                "equals": "",
                "type": "'identifier'"
            }
        ],
        "codes": [
            "if (isIdentifierName(this.lexer.peek().type) || (allowKeyword && isKeyword(this.lexer.peek().type))) {",
            "\tconst result = new @Identifier();",
            "\tresult.start = @read;",
            "\tresult.value = @lexer.current.value;",
            "\tresult.end = @lexer.current.end;",
            "\treturn result;",
            "}",
            "@error(@lexer.peek(), isKeyword(this.lexer.peek().type) ? \"Identifier expected; Keyword '{0}' cannot be used as an identifier.\" : \"Identifier expected; Unexpected token '{0}'.\", getTokenName(this.lexer.peek().type));",
            "return @ErrorIdentifier();"
        ]
    },
    "ErrorIdentifier": {
        "indent": 5,
        "doc": false,
        "extends": "Node",
        "comment": "错误的标识符占位符",
        "name": "ErrorIdentifier",
        "equals": "",
        "params": [
            {
                "comment": "标记的开始位置",
                "name": "start",
                "equal": "@lexer.current.end",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": [
            "const result = new @ErrorIdentifier();",
            "result.start = start;",
            "result.end = @lexer.current.end;",
            "return result;"
        ]
    },
    "SimpleLiteral": {
        "indent": 3,
        "doc": false,
        "extends": "Expression",
        "comment": "简单字面量(`null`、`true`、`false`、`this`、`super`)",
        "name": "SimpleLiteral",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "type",
                "comment": "类型",
                "args": "",
                "equals": "",
                "type": "'this'|'null'|'true'|'false'|'super'"
            }
        ],
        "codes": []
    },
    "ArrowFunctionOrParenthesizedExpression": {
        "indent": 3,
        "doc": false,
        "extends": "Expression",
        "comment": "箭头(`()=>...`)或括号表达式(`(x)`)",
        "name": "ArrowFunctionOrParenthesizedExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "allowIn",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": [
            "const savedState = @stashSave();",
            "const parameters = @Parameters();",
            "if (@sameLine && (this.lexer.peek().type === '=>' || this.lexer.peek().type === ':' || this.lexer.peek().type === '{')) {",
            "\t@stashClear(savedState);",
            "\treturn @ArrowFunctionExpression(undefined, undefined, parameters, allowIn);",
            "}",
            "@stashRestore(savedState);",
            "return @ParenthesizedExpression();"
        ]
    },
    "ArrowFunctionExpression": {
        "indent": 5,
        "doc": false,
        "extends": "Expression",
        "comment": "箭头函数表达式(`x => {...}`、`(x, y) => {...}`)。",
        "name": "ArrowFunctionExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "allowIn",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Modifiers"
            },
            {
                "optional": true,
                "name": "typeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "TypeParameters"
            },
            {
                "optional": true,
                "name": "parameters",
                "comment": "参数部分",
                "args": "",
                "equals": "",
                "type": "NodeList<ParameterDeclaration> | Identifier"
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "",
                "comment": "",
                "args": "",
                "equals": ">",
                "type": ""
            },
            {
                "optional": false,
                "name": "body",
                "comment": "",
                "args": "",
                "equals": "@peek === '{' ? @BlockStatement() : @Expression(Precedence.assignment, allowIn)",
                "type": "BlockStatement | Expression"
            }
        ],
        "codes": []
    },
    "ParenthesizedExpression": {
        "indent": 4,
        "doc": false,
        "extends": "Expression",
        "comment": "括号表达式(`(x)`)",
        "name": "ParenthesizedExpression",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "(",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "body",
                "comment": "主体部分",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": false,
                "name": ")",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "NumericLiteral": {
        "indent": 3,
        "doc": false,
        "extends": "Expression",
        "comment": "数字字面量(`1`)",
        "name": "NumericLiteral",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "value",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "'numericLiteral'"
            }
        ],
        "codes": []
    },
    "StringLiteral": {
        "indent": 3,
        "doc": false,
        "extends": "Expression",
        "comment": "字符串字面量(`'abc'`、`\"abc\"`、`\\`abc\\``)",
        "name": "StringLiteral",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "value",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "'stringLiteral'"
            }
        ],
        "codes": []
    },
    "ArrayLiteral": {
        "indent": 3,
        "doc": false,
        "extends": "Expression",
        "comment": "数组字面量(`[x, y]`)",
        "name": "ArrayLiteral",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "elements",
                "comment": "元素列表",
                "args": "",
                "equals": "",
                "type": "[ ArrayLiteralElement , ... isExpressionStart ]"
            }
        ],
        "codes": []
    },
    "ArrayLiteralElement": {
        "indent": 4,
        "doc": false,
        "extends": "Node",
        "comment": "数组字面量元素(`x`)",
        "name": "ArrayLiteralElement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": true,
                "name": "...",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "value",
                "comment": "",
                "args": "Precedence.assignment",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": []
    },
    "ObjectLiteral": {
        "indent": 3,
        "doc": false,
        "extends": "Expression",
        "comment": "对象字面量(`{x: y}`)",
        "name": "ObjectLiteral",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "elements: { ... ObjectLiteralElement ... }"
        ]
    },
    "ObjectLiteralElement": {
        "indent": 4,
        "doc": false,
        "extends": "Node",
        "comment": "对象字面量元素(`x: y`、`x() {...}`)",
        "name": "ObjectLiteralElement",
        "equals": "ObjectPropertyDeclaration | ObjectMethodDeclaration | ObjectAccessorDeclaration",
        "params": [],
        "parts": [],
        "codes": [
            "const modifiers = @Modifiers();",
            "switch (this.lexer.peek().type) {",
            "\t//+ case 'identifier':",
            "\t//+ \tbreak;",
            "\tcase 'get':",
            "\tcase 'set':",
            "\t\tconst savedToken = @lexer.current;",
            "\t\t@lexer.read();",
            "\t\tif (isKeyword(this.lexer.peek().type) || this.lexer.peek().type === '[') {",
            "\t\t\treturn @ObjectAccessorDeclaration(modifiers, savedToken.type === 'get' ? savedToken.start : undefined, savedToken.type === 'set' ? savedToken.start : undefined);",
            "\t\t}",
            "\t\t@lexer.current = savedToken;",
            "\t\tbreak;",
            "\tcase '*':",
            "\t\treturn @ObjectMethodDeclaration(modifiers, @read, @PropertyName());",
            "}",
            "const name = @PropertyName();",
            "switch (this.lexer.peek().type) {",
            "\tcase '(':",
            "\tcase '<':",
            "\t\treturn @ObjectMethodDeclaration(modifiers, undefined, name);",
            "\tdefault:",
            "\t\treturn @ObjectPropertyDeclaration(modifiers, name);",
            "}"
        ]
    },
    "ObjectAccessorDeclaration": {
        "indent": 8,
        "doc": true,
        "extends": "Declaration",
        "comment": "访问器声明(`get x() {...}`、`set x(value) {...}`)",
        "name": "ObjectAccessorDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "get",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "set",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "PropertyName"
            },
            {
                "optional": false,
                "name": "Parameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "FunctionBody",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "ObjectMemberTail",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "ObjectMethodDeclaration": {
        "indent": 7,
        "doc": true,
        "extends": "Declaration",
        "comment": "方法声明(`x() {...}`)",
        "name": "ObjectMethodDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "*",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "name": "TypeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "Parameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "FunctionBody",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "ObjectMemberTail",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "ObjectPropertyDeclaration": {
        "indent": 7,
        "doc": true,
        "extends": "Declaration",
        "comment": "属性声明(`x: y`)",
        "name": "ObjectPropertyDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "key",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "name": "",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "value",
                "comment": "",
                "args": "Precedence.assignment",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": false,
                "name": "ObjectMemberTail",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "const result = new @ObjectPropertyDeclaration();",
            "@DocComment(result);",
            "result.key = key;",
            "if (this.lexer.peek().type === ':') {",
            "\tresult.colonToken = @readToken(':');",
            "\tresult.value = @Expression(Precedence.assignment);",
            "} else if (this.lexer.peek().type === '=') {",
            "\tresult.equalToken = @readToken('=');",
            "\tresult.value = @Expression(Precedence.assignment);",
            "} else if(key.constructor !== @Identifier && key.constructor !== @MemberCallExpression) {",
            "\t@readToken(':');",
            "}",
            "@ObjectMemberTail(result);",
            "return result;"
        ]
    },
    "NewTargetOrNewExpression": {
        "indent": 3,
        "doc": false,
        "extends": "Expression",
        "comment": "new.target(`new.target`) 或 new 表达式(`new x()`)",
        "name": "NewTargetOrNewExpression",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "const newToken = @readToken('new');",
            "if (this.lexer.peek().type === '.') {",
            "\treturn @NewTargetExpression(newToken);",
            "}",
            "return @NewExpression(newToken);"
        ]
    },
    "NewTargetExpression": {
        "indent": 4,
        "doc": false,
        "extends": "Expression",
        "comment": "new.target 表达式(`new.target`)",
        "name": "NewTargetExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "new",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": ".",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "target",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "const result = new @NewTargetExpression();",
            "result.newToken = newToken;",
            "result.dotToken = @readToken('.');",
            "if (this.lexer.peek().type === 'identifier' && @lexer.peek().data === \"target\") {",
            "\tresult.targetToken = @readToken('identifier');",
            "\treturn result;",
            "}",
            "@error(@lexer.peek(), \"'target' expected; Unexpected token '{0}'.\", getTokenName(this.lexer.peek().type));",
            "return @ErrorIdentifier(newToken);"
        ]
    },
    "NewExpression": {
        "indent": 4,
        "doc": false,
        "extends": "Expression",
        "comment": "new 表达式(`new x()`、`new x`)",
        "name": "NewExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "new",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "target",
                "comment": "",
                "args": "Precedence.member",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": "arguments",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Arguments"
            }
        ],
        "codes": []
    },
    "RegularExpressionLiteral": {
        "indent": 3,
        "doc": false,
        "extends": "Expression",
        "comment": "正则表达式字面量(/abc/)",
        "name": "RegularExpressionLiteral",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "value",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "<stringLiteral>"
            },
            {
                "optional": false,
                "name": "flags?",
                "comment": "标志部分",
                "args": "",
                "equals": "",
                "type": "<stringLiteral>"
            }
        ],
        "codes": [
            "const result = new @RegularExpressionLiteral();",
            "const token = @lexer.readAsRegularExpressionLiteral();",
            "result.start = token.start;",
            "result.value = token.data.pattern;",
            "result.flags = token.data.flags;",
            "result.end = token.end;",
            "return result;"
        ]
    },
    "TemplateLiteral": {
        "indent": 3,
        "doc": false,
        "extends": "Expression",
        "comment": "模板字面量(`\\`abc\\``)",
        "name": "TemplateLiteral",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "spans",
                "comment": "组成部分列表",
                "args": "",
                "equals": "",
                "type": "NodeList<TemplateSpan|Expression>"
            }
        ],
        "codes": [
            "const result = new @TemplateLiteral()();",
            "result.spans = new @NodeList()<@Expression>();",
            "while (true) {",
            "\tresult.spans.push(@TemplateSpan());",
            "\tresult.spans.push(@Expression());",
            "\tif (this.lexer.peek().type !== '}') {",
            "\t\t@readToken('}');",
            "\t\tbreak;",
            "\t}",
            "\tif (@lexer.readAsTemplateMiddleOrTail().type === 'templateTail') {",
            "\t\tresult.spans.push(@TemplateSpan());",
            "\t\tbreak;",
            "\t}",
            "}",
            "return result;"
        ]
    },
    "TemplateSpan": {
        "indent": 4,
        "doc": false,
        "extends": "Node",
        "comment": "模板文本区块(`\\`abc${`、`}abc${`、`}abc\\``)",
        "name": "TemplateSpan",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "value",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "<stringLiteral>"
            }
        ],
        "codes": []
    },
    "ArrowFunctionOrTypeAssertionExpression": {
        "indent": 3,
        "doc": false,
        "extends": "Expression",
        "comment": "箭头函数(`<T>() => {}`)或类型确认表达式(`<T>fn`)",
        "name": "ArrowFunctionOrTypeAssertionExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "allowIn",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": [
            "const savedState = @stashSave();",
            "const typeParameters = @TypeParameters();",
            "const parameters = this.lexer.peek().type === '(' ? @Parameters() : isIdentifierName(this.lexer.peek().type) : @Identifier() : undefined;",
            "if (parameters && @sameLine && (this.lexer.peek().type === '=>' || this.lexer.peek().type === ':' || this.lexer.peek().type === '{')) {",
            "\t@stashClear(savedState);",
            "\treturn @ArrowFunctionExpression(undefined, typeParameters, parameters, allowIn);",
            "}",
            "@stashRestore(savedState);",
            "return @TypeAssertionExpression();"
        ]
    },
    "TypeAssertionExpression": {
        "indent": 4,
        "doc": false,
        "extends": "Expression",
        "comment": "类型确认表达式(<T>xx)",
        "name": "TypeAssertionExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "<",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "type",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "TypeNode"
            },
            {
                "optional": false,
                "name": ">",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "operand",
                "comment": "",
                "args": "Precedence.postfix",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": []
    },
    "YieldExpression": {
        "indent": 3,
        "doc": false,
        "extends": "Expression",
        "comment": "yield 表达式(`yield xx`)",
        "name": "YieldExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "allowIn",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "yield",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "*",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "operand",
                "comment": "",
                "args": "Precedence.assignment, allowIn",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @YieldExpression();",
            "result.yieldToken = @readToken('yield');",
            "if (@sameLine && this.lexer.peek().type === '*') result.asteriskToken = @readToken('*');",
            "if (@sameLine && isExpressionStart(this.lexer.peek().type)) result.operand = @Expression(Precedence.assignment, allowIn);",
            "return result;"
        ]
    },
    "AwaitExpressionOrIdentifier": {
        "indent": 3,
        "doc": false,
        "extends": "Node",
        "comment": "await 表达式(`await xx`)或标识符",
        "name": "AwaitExpressionOrIdentifier",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "allowIn",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": [
            "const savedToken = @lexer.current;",
            "@readToken('await');",
            "if (@sameLine && isExpressionStart(this.lexer.peek().type)) {",
            "\treturn @AwaitExpression(allowIn);",
            "}",
            "@lexer.current = savedToken;",
            "return @Identifier();"
        ]
    },
    "AwaitExpression": {
        "indent": 4,
        "doc": false,
        "extends": "Expression",
        "comment": "await 表达式(`await xx`)",
        "name": "AwaitExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "awaitToken",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "allowIn",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "await",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "operand",
                "comment": "",
                "args": "Precedence.assignment, allowIn",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": []
    },
    "AsyncArrowFunctionOrIdentifier": {
        "indent": 3,
        "doc": false,
        "extends": "Node",
        "comment": "异步函数表达式或标识符",
        "name": "AsyncArrowFunctionOrIdentifier",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "allowIn",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": [
            "const savedState = @stashSave();",
            "const modifiers = @Modifiers();",
            "const typeParameters = @sameLine && this.lexer.peek().type === '<' ? @TypeParameters() : undefined;",
            "if (@sameLine && (this.lexer.peek().type === '(' || isIdentifierName(this.lexer.peek().type))) {",
            "\tconst parameters = this.lexer.peek().type === '(' ? @Parameters() : @Identifier();",
            "\tif (@sameLine && (this.lexer.peek().type === '=>' || this.lexer.peek().type === ':' || this.lexer.peek().type === '{')) {",
            "\t\t@stashClear(savedState);",
            "\t\treturn @ArrowFunctionExpression(modifiers, typeParameters, parameters, allowIn);",
            "\t}",
            "}",
            "@stashRestore(savedState);",
            "return @Identifier();"
        ]
    },
    "UnaryExpression": {
        "indent": 4,
        "doc": false,
        "extends": "Expression",
        "comment": "一元运算表达式(`+x`、`typeof x`、...)",
        "name": "UnaryExpression",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "operator",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "'delete'|'void'|'typeof'|'+'|'-'|'~'|'!'|'++'|'--'|'...'"
            },
            {
                "optional": false,
                "name": "operand",
                "comment": "",
                "args": "Precedence.postfix",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": []
    },
    "MemberCallExpression": {
        "indent": 4,
        "doc": false,
        "extends": "Expression",
        "comment": "成员调用表达式(x.y)",
        "name": "MemberCallExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "target",
                "comment": "目标部分",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": false,
                "name": ".",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "argument",
                "comment": "参数部分",
                "args": "",
                "equals": "@MemberCallArgument()",
                "type": "Identifier"
            }
        ],
        "codes": []
    },
    "MemberCallArgument": {
        "indent": 5,
        "doc": false,
        "extends": "Node",
        "comment": "成员调用参数",
        "name": "MemberCallArgument",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "if (!@sameLine && isStatementStart(this.lexer.peek().type)) {",
            "\tconst savedState = @stashSave();",
            "\t@Statement();",
            "\tconst isStatementStart = !savedState.errors.length;",
            "\t@stashRestore(savedState);",
            "\tif (isStatementStart) {",
            "\t\treturn @ErrorIdentifier();",
            "\t}",
            "}",
            "return @Identifier(true);"
        ]
    },
    "FunctionCallExpression": {
        "indent": 4,
        "doc": false,
        "extends": "Expression",
        "comment": "函数调用表达式(`x()`)",
        "name": "FunctionCallExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "target",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": false,
                "name": "arguments",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Arguments"
            }
        ],
        "codes": []
    },
    "Arguments": {
        "indent": 5,
        "doc": false,
        "extends": "Node",
        "comment": "函数调用参数列表",
        "name": "Arguments",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "Argument",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "... isArgumentStart",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": []
    },
    "Argument": {
        "indent": 6,
        "doc": false,
        "extends": "Node",
        "comment": "函数调用参数(`x`)",
        "name": "Argument",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": true,
                "name": "...",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "value",
                "comment": "",
                "args": "Precedence.assignment",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": []
    },
    "IndexCallExpression": {
        "indent": 4,
        "doc": false,
        "extends": "Expression",
        "comment": "索引调用表达式(`x[y]`)",
        "name": "IndexCallExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "target",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": false,
                "name": "[",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "argument",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": false,
                "name": "]",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "ConditionalExpression": {
        "indent": 4,
        "doc": false,
        "extends": "Expression",
        "comment": "条件表达式(`x ? y : z`)",
        "name": "ConditionalExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "allowIn",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "condition",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": false,
                "name": "then",
                "comment": "则部分",
                "args": "Precedence.assignment",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": false,
                "name": "else",
                "comment": "否则部分",
                "args": "Precedence.assignment, allowIn",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": [
            "? ",
            ": "
        ]
    },
    "PostfixExpression": {
        "indent": 4,
        "doc": false,
        "extends": "Expression",
        "comment": "后缀表达式(`x++`、`x--`)",
        "name": "PostfixExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "operand",
                "comment": "操作数",
                "args": "Precedence.leftHandSide",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": false,
                "name": "operator",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "'++'|'--'"
            }
        ],
        "codes": []
    },
    "TemplateCallExpression": {
        "indent": 4,
        "doc": false,
        "extends": "Expression",
        "comment": "模板调用表达式(`x\\`abc\\``)",
        "name": "TemplateCallExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "target",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": false,
                "name": "argument",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "TemplateLiteral | StringLiteral"
            }
        ],
        "codes": []
    },
    "BinaryExpression": {
        "indent": 2,
        "doc": false,
        "extends": "Expression",
        "comment": "双目表达式(x + y、x = y、...)",
        "name": "BinaryExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "allowIn",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "left",
                "comment": "左值部分",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": false,
                "name": "operator",
                "comment": "运算类型",
                "args": "",
                "equals": "'|'/='|'%='|'+='|'‐='|'<<='|'>>='|'>>>='|'&='|'^='|'|='|'**='|'='|'||'|'&&'|'|'|'^'|'&'|'=='|'!='|'==='|'!=='|'<'|'>'|'<='|'>='|'instanceof'|'in'|'<<'|'>>'|'>>>'|'+'|'-'|'*'|'/'|'%'|'**'",
                "type": "','|'*"
            },
            {
                "optional": false,
                "name": "right",
                "comment": "右值部分",
                "args": "getPrecedence(result.operator",
                "equals": "",
                "type": "Expression + (isRightHandOperator(result.operator) ? 0 : 1), allowIn)"
            }
        ],
        "codes": []
    },
    "Statement": {
        "indent": 0,
        "doc": false,
        "extends": "Node",
        "comment": "语句",
        "name": "Statement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "case 'for'",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "case 'while'",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "case 'switch'",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\tcase 'identifier': ",
            "\t\treturn @LabeledOrExpressionStatement(@Identifier());",
            "\tcase '{':",
            "\t\treturn @BlockStatement();",
            "\tcase 'var':",
            "\tcase 'const':",
            "\t\treturn @VariableStatement();",
            "\tcase 'let': ",
            "\t\treturn @VariableOrExpressionStatement(true);",
            "\tcase 'function':",
            "\t\treturn @FunctionDeclaration();",
            "\tcase 'if':",
            "\t\treturn @IfStatement();",
            "\t\treturn @ForOrForInOrForOfOrForToStatement();",
            "\t\treturn @WhileStatement();",
            "\t\treturn @SwitchStatement();"
        ]
    },
    "LabeledOrExpressionStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "表达式或标签语句",
        "name": "LabeledOrExpressionStatement",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "parsed",
                "equal": "",
                "question": false,
                "type": "@Expression"
            }
        ],
        "parts": [],
        "codes": [
            "if (parsed.constructor === @Identifier && this.lexer.peek().type === ':') {",
            "\treturn @LabelledStatement(<@Identifier>parsed);",
            "}",
            "return @ExpressionStatement(parsed);"
        ]
    },
    "LabelledStatement": {
        "indent": 4,
        "doc": true,
        "extends": "Statement",
        "comment": "标签语句(`x: ...`)",
        "name": "LabelledStatement",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "label",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": false,
                "name": "statement",
                "comment": "主体部分",
                "args": "",
                "equals": "",
                "type": "Statement"
            }
        ],
        "codes": [
            ":"
        ]
    },
    "ExpressionStatement": {
        "indent": 4,
        "doc": false,
        "extends": "Statement",
        "comment": "表达式语句(`x();`)",
        "name": "ExpressionStatement",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "expression",
                "equal": "",
                "question": true,
                "type": "@Expression"
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "expression",
                "comment": "表达式部分",
                "args": "",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @ExpressionStatement();",
            "result.expression = expression || @Expression();",
            "return result;"
        ]
    },
    "BlockStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "语句块(`{...}`)",
        "name": "BlockStatement",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "statements: { Statement ... }"
        ]
    },
    "VariableStatement:": {
        "indent": 3,
        "doc": false,
        "extends": "Node",
        "comment": "变量声明语句(`var x`、`let x`、`const x`)",
        "name": "VariableStatement:",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "allowIn",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "type",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "'var'|'let'|'const'"
            },
            {
                "optional": false,
                "name": "variables",
                "comment": "",
                "args": "",
                "equals": "@DelimitedList(allowIn === false ? @VariableDeclarationWithoutIn : @VariableDeclaration, undefined, undefined, isBindingNameStart)",
                "type": "... VariableDeclaration , ... isBindingNameStart"
            }
        ],
        "codes": []
    },
    "VariableDeclarationWithoutIn": {
        "indent": 4,
        "doc": false,
        "extends": "Node",
        "comment": "变量声明（不带 in）",
        "name": "VariableDeclarationWithoutIn",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": [
            "return @VariableDeclaration(false);"
        ]
    },
    "VariableDeclaration": {
        "indent": 4,
        "doc": false,
        "extends": "Declaration",
        "comment": "变量声明(`x = 1`、`[x] = [1]`、`{a: x} = {a: 1}`)",
        "name": "VariableDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "allowIn",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "mame",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "BindingName"
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Initializer",
                "comment": "",
                "args": "allowIn",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "VariableOrExpressionStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "变量声明(`let x`)或表达式语句(`let(x)`)",
        "name": "VariableOrExpressionStatement",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "allowIn",
                "equal": "true",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": [
            "const savedToken = @lexer.current;",
            "switch (this.lexer.peek().type) {",
            "\tcase 'let':",
            "\tcase 'var':",
            "\tcase 'const':",
            "\t\t@lexer.read();",
            "\t\tconst isBindingName = isBindingNameStart(this.lexer.peek().type);",
            "\t\t@lexer.current = savedToken;",
            "\t\tif (isBindingName) {",
            "\t\t\treturn @VariableStatement(allowIn);",
            "\t\t}",
            "\t\tbreak;",
            "}",
            "return @ExpressionStatement(@Expression(Precedence.any, allowIn));"
        ]
    },
    "IfStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "if 语句(`if (x) ...`)",
        "name": "IfStatement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "if",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "Condition",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "then",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Statement"
            },
            {
                "optional": true,
                "name": "else",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "else",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @IfStatement();",
            "result.ifToken = @readToken('if');",
            "@Condition(result);",
            "result.then = @EmbeddedStatement();",
            "if (this.lexer.peek().type === 'else') {",
            "\tresult.elseToken = @readToken('else');",
            "\tresult.else = @EmbeddedStatement();",
            "}",
            "return result;"
        ]
    },
    "Condition": {
        "indent": 4,
        "doc": false,
        "extends": "Node",
        "comment": "条件表达式",
        "name": "Condition",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "result",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "(",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "condition",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ")",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "const hasParan = this.lexer.peek().type === '(';",
            "if (hasParan || @options.allowMissingParenthese === false) result.openParanToken = @readToken('(');",
            "result.condition = @Expression();",
            "if (hasParan) result.closeParanToken = @readToken(')');"
        ]
    },
    "EmbeddedStatement": {
        "indent": 4,
        "doc": false,
        "extends": "Statement",
        "comment": "内嵌语句",
        "name": "EmbeddedStatement",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "return @Statement();"
        ]
    },
    "ForOrForInOrForOfOrForToStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "for 或 for..in 或 for..of 或 for..to 语句",
        "name": "ForOrForInOrForOfOrForToStatement",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "const forToken = @readToken('for');",
            "const openParan = this.lexer.peek().type === '(' || @options.allowMissingParenthese === false ? @readToken('(') : undefined;",
            "const initializer = this.lexer.peek().type === ';' ? undefined : @VariableOrExpressionStatement(false);",
            "let type = this.lexer.peek().type;",
            "switch (type) {",
            "\t//+ case ';':",
            "\t//+\treturn @ForStatement(forToken, openParan, initializer);",
            "\tcase 'in':",
            "\t\treturn @ForInStatement(forToken, openParan, initializer);",
            "\tcase 'of':",
            "\t\treturn @ForOfStatement(forToken, openParan, initializer);",
            "\tcase 'to':",
            "\t\treturn @ForToStatement(forToken, openParan, initializer);",
            "\tdefault:",
            "\t\treturn @ForStatement(forToken, openParan, initializer);",
            "}"
        ]
    },
    "ForStatement": {
        "indent": 4,
        "doc": false,
        "extends": "Statement",
        "comment": "for 语句(`for(var i = 0; i < 9; i++) ...`)",
        "name": "ForStatement",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "for",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "(",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "initializer",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "VariableStatement | ExpressionStatement"
            },
            {
                "optional": false,
                "name": "firstSemicolon",
                "comment": "条件部分中首个分号",
                "args": "",
                "equals": "",
                "type": "';'"
            },
            {
                "optional": true,
                "name": "condition",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": false,
                "name": "secondSemicolon",
                "comment": "条件部分中第二个分号",
                "args": "",
                "equals": "",
                "type": "';'"
            },
            {
                "optional": true,
                "name": "iterator",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ")",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "statement",
                "comment": "",
                "args": "",
                "equals": "@EmbeddedStatement()",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @ForStatement();",
            "result.forToken = forToken;",
            "if (openParanToken != undefined) result.openParanToken = openParanToken;",
            "if (initializer != undefined) result.initializer = initializer;",
            "result.firstSemicolonToken = @readToken(';');",
            "if (this.lexer.peek().type !== ';') result.condition = @Expression();",
            "result.secondSemicolonToken = @readToken(';');",
            "if (openParanToken == undefined ? isExpressionStart(iterator) : this.lexer.peek().type !== ')') result.iterator = @Expression();",
            "if (openParanToken != undefined) result.closeParanToken = @readToken(')');",
            "result.body = @EmbeddedStatement();",
            "return result;"
        ]
    },
    "ForInStatement": {
        "indent": 4,
        "doc": false,
        "extends": "Statement",
        "comment": "for..in 语句(`for(var x in y) ...`)",
        "name": "ForInStatement",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "for",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "(",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "initializer",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "VariableStatement | ExpressionStatement"
            },
            {
                "optional": false,
                "name": "in",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "condition",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ")",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "statement",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @ForInStatement();",
            "result.forToken = forToken;",
            "if (openParanToken != undefined) result.openParanToken = openParanToken;",
            "result.initializer = initializer;",
            "result.inToken = @readToken('in');",
            "result.condition = @Expression();",
            "if (openParanToken != undefined) result.closeParanToken = @readToken(')');",
            "result.body = @EmbeddedStatement();",
            "return result;"
        ]
    },
    "ForOfStatement": {
        "indent": 4,
        "doc": false,
        "extends": "Statement",
        "comment": "for..of 语句(`for(var x of y) ...`)",
        "name": "ForOfStatement",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "for",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "(",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "initializer",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "VariableStatement | ExpressionStatement"
            },
            {
                "optional": false,
                "name": "of",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "condition",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ")",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "statement",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @ForInStatement();",
            "result.forToken = forToken;",
            "if (openParanToken != undefined) result.openParanToken = openParanToken;",
            "result.initializer = initializer;",
            "result.ofToken = @readToken('of');",
            "result.condition = @Expression();",
            "if (openParanToken != undefined) result.closeParanToken = @readToken(')');",
            "result.body = @EmbeddedStatement();",
            "return result;"
        ]
    },
    "ForToStatement": {
        "indent": 4,
        "doc": false,
        "extends": "Statement",
        "comment": "for..to 语句(`for(var x = 0 to 10) ...`)",
        "name": "ForToStatement",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "for",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "(",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "initializer",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "VariableStatement | ExpressionStatement"
            },
            {
                "optional": false,
                "name": "to",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "expression",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ")",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "statement",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @ForInStatement();",
            "result.forToken = forToken;",
            "if (openParanToken != undefined) result.openParanToken = openParanToken;",
            "result.initializer = initializer;",
            "result.toToken = @readToken('to');",
            "result.condition = @Expression();",
            "if (openParanToken != undefined) result.closeParanToken = @readToken(')');",
            "result.body = @EmbeddedStatement();",
            "return result;"
        ]
    },
    "WhileStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "while 语句(`while(x) ...`)",
        "name": "WhileStatement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "while",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "Condition",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "statement",
                "comment": "",
                "args": "",
                "equals": "@EmbeddedStatement()",
                "type": "Statement"
            }
        ],
        "codes": []
    },
    "SwitchStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "switch 语句(`switch(x) {...}`)",
        "name": "SwitchStatement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "switch",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Condition",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "cases: { ... CaseOrDefaultClause ... }",
            "const result = new @SwitchStatement();",
            "result.switchToken = @readToken('switch');",
            "if (@options.allowMissingSwitchCondition === false || this.lexer.peek().type !== '{') {",
            "\t@Condition(result);",
            "}",
            "result.cases = @NodeList(@CaseOrDefaultClause, '{', '}');",
            "return result;"
        ]
    },
    "CaseOrDefaultClause": {
        "indent": 4,
        "doc": false,
        "extends": "Node",
        "comment": "case(`case x: ...`) 或 default(`default: ...`) 分支",
        "name": "CaseOrDefaultClause",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\tcase 'case':",
            "\t\treturn @CaseClause();",
            "\tcase 'default':",
            "\t\treturn @DefaultClause();",
            "\tdefault:",
            "\t\t@error(@lexer.peek(), \"'case' or 'default' expected; Unexpected token '{0}'.\", getTokenName(this.lexer.peek().type));",
            "\t\treturn;",
            "}"
        ]
    },
    "CaseClause": {
        "indent": 5,
        "doc": false,
        "extends": "Node",
        "comment": "case 分支(`case x: ...`)",
        "name": "CaseClause",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "case",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "labels",
                "comment": "标签列表",
                "args": "",
                "equals": "",
                "type": "CaseClauseLabel , ... isCaseLabelStart"
            },
            {
                "optional": false,
                "name": "statements",
                "comment": "",
                "args": "",
                "equals": "@NodeList(@CaseStatement)",
                "type": "Statement ..."
            }
        ],
        "codes": [
            ":"
        ]
    },
    "CaseClauseLabel": {
        "indent": 6,
        "doc": false,
        "extends": "Node",
        "comment": "case 分支标签(`case x: ...`)",
        "name": "CaseClauseLabel",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": true,
                "name": "else",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "label",
                "comment": "",
                "args": "Precedence.assignment",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @CaseClauseLabel();",
            "if (@options.allowCaseElse !== false && this.lexer.peek().type === 'else') {",
            "\tresult.elseToken = @readToken('else');",
            "} else {",
            "\tresult.label = @Expression(Precedence.assignment);",
            "}",
            "return result;"
        ]
    },
    "DefaultClause": {
        "indent": 5,
        "doc": false,
        "extends": "Node",
        "comment": "default 分支(`default: ...`)",
        "name": "DefaultClause",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "default",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "statements",
                "comment": "",
                "args": "",
                "equals": "@NodeList(@CaseStatement)",
                "type": "Statement ..."
            }
        ],
        "codes": [
            ":"
        ]
    },
    "CaseStatement": {
        "indent": 6,
        "doc": false,
        "extends": "Statement",
        "comment": "case 段语句",
        "name": "CaseStatement",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\tcase 'case':",
            "\tcase 'default':",
            "\tcase '}':",
            "\tcase 'endOfFile':",
            "\t\treturn;",
            "\tdefault:",
            "\t\treturn @Statement();",
            "}"
        ]
    },
    "DoWhileStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "do..while 语句(`do ... while(x);`)",
        "name": "DoWhileStatement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "do",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "statement",
                "comment": "",
                "args": "",
                "equals": "@EmbeddedStatement()",
                "type": "Statement"
            },
            {
                "optional": false,
                "name": "while",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "Condition",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "BreakStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "break 语句(`break xx;`)",
        "name": "BreakStatement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "break",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "label",
                "comment": "",
                "args": "false",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "const result = new @ContinueStatement();",
            "@BreakOrContinueStatement(result, 'continue');",
            "return result;"
        ]
    },
    "ContinueStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "continue 语句(`continue xx;`)",
        "name": "ContinueStatement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "continue",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "label",
                "comment": "",
                "args": "false",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "const result = new @ContinueStatement();",
            "@BreakOrContinueStatement(result, 'continue');",
            "return result;"
        ]
    },
    "BreakOrContinueStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "break(`break xx;`)或 continue(`continue xx;`)语句",
        "name": "BreakOrContinueStatement",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "result",
                "equal": "",
                "question": false,
                "type": "@ContinueStatement"
            },
            {
                "comment": "",
                "name": "token",
                "equal": "",
                "question": false,
                "type": "TokenType"
            }
        ],
        "parts": [],
        "codes": [
            "result.start = @readToken(token);",
            "if (!@tryReadSemicolon(result)) {",
            "\tresult.label = @Identifier();",
            "\t@tryReadSemicolon(result);",
            "}"
        ]
    },
    "ReturnStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "return 语句(`return x;`)",
        "name": "ReturnStatement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "return",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "value",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @ReturnStatement();",
            "result.returnToken = @readToken('return');",
            "if (!@tryReadSemicolon(result)) {",
            "\tresult.value = @Expression();",
            "\t@tryReadSemicolon(result);",
            "}",
            "return result;"
        ]
    },
    "TryStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "try 语句(`try {...} catch(e) {...}`)",
        "name": "TryStatement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "try",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "try",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Statement"
            },
            {
                "optional": false,
                "name": "catch",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "CatchClause"
            },
            {
                "optional": false,
                "name": "finally",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "FinallyClause"
            }
        ],
        "codes": [
            "const result = new @TryStatement();",
            "result.tryToken = @readToken('try');",
            "result.try = @EmbeddedStatement();",
            "if (this.lexer.peek().type === 'catch') result.catch = @CatchClause();",
            "if (this.lexer.peek().type === 'finally') result.catch = @FinallyClause();",
            "if (@options.allowSimpleTryBlock === false && !result.catch && !result.finally) {",
            "\t@error(@lexer.peek(), \"'catch' or 'finally' expected. Unexpected token '{0}'.\", getTokenName(@lexer.peek()));",
            "}",
            "return result;"
        ]
    },
    "CatchClause": {
        "indent": 4,
        "doc": false,
        "extends": "Node",
        "comment": "catch 分句(`catch(e) {...}`)",
        "name": "CatchClause",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "catch",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "(",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "variable",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "BindingName"
            },
            {
                "optional": true,
                "name": ")",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "statement",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @CatchClause();",
            "result.catchToken = @readToken('catch');",
            "const hasParan = this.lexer.peek().type === '(';",
            "if (hasParan || @options.allowMissingParenthese === false) result.openParan = @readToken('(');",
            "if (@options.allowMissingCatchVaribale === false || isBindingName(this.lexer.peek().type)) {",
            "\tresult.variable = @BindingName();",
            "\tif (this.lexer.peek().type === ':') {",
            "\t\t@error(this.lexer.peek().type, \"Catch variable cannot have a type annotation; Unexpected token ':'.\");",
            "\t\t@read;",
            "\t\tif (isTypeNodeStart(this.lexer.peek().type)) {",
            "\t\t\t@TypeNode();",
            "\t\t}",
            "\t}",
            "}",
            "if (hasParan) result.closeParan = @readToken(')');",
            "result.body = @EmbeddedStatement();",
            "return result;"
        ]
    },
    "FinallyClause": {
        "indent": 4,
        "doc": false,
        "extends": "Node",
        "comment": "finally 分句(`finally {...}`)",
        "name": "FinallyClause",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "finally",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "statement",
                "comment": "",
                "args": "",
                "equals": "@EmbeddedStatement()",
                "type": "Statement"
            }
        ],
        "codes": []
    },
    "DebuggerStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "debugger 语句(`debugger;`)",
        "name": "DebuggerStatement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "debugger",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "EmptyStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "空语句(`;`)",
        "name": "EmptyStatement",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            ";"
        ]
    },
    "WithStatement": {
        "indent": 3,
        "doc": false,
        "extends": "Statement",
        "comment": "with 语句(`with (x) ...`)",
        "name": "WithStatement",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "with",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "(",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "value",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "VariableStatement | Expression"
            },
            {
                "optional": true,
                "name": ")",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "body",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @WithStatement();",
            "result.start = @readToken('with');",
            "const hasParan = this.lexer.peek().type === '(';",
            "if (hasParan) result.openParanToken = @readToken('(');",
            "result.value = @options.allowWithVaribale !== false ? @VariableOrExpressionStatement() : @Expression();",
            "if (hasParan) result.closeParanToken = @readToken(')');",
            "result.body = @EmbeddedStatement();",
            "return result;"
        ]
    },
    "Declaration": {
        "indent": 0,
        "doc": false,
        "extends": "Statement",
        "comment": "声明",
        "name": "Declaration",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": []
    },
    "FunctionDeclarationOrExpression": {
        "indent": 1,
        "doc": false,
        "extends": "Expression",
        "comment": "函数声明或表达式",
        "name": "FunctionDeclarationOrExpression",
        "equals": "",
        "params": [
            {
                "comment": "解析的目标节点",
                "name": "result",
                "equal": "",
                "question": false,
                "type": "@FunctionDeclaration | @FunctionExpression"
            },
            {
                "comment": "",
                "name": "modifiers",
                "equal": "",
                "question": false,
                "type": "@NodeList<@Modifier>"
            }
        ],
        "parts": [],
        "codes": [
            "@DocComment(result);",
            "if (modifiers) result.modifiers = modifiers;",
            "result.functionToken = @readToken('function');",
            "if (this.lexer.peek().type === '*') result.asteriskToken = @read;",
            "if (isIdentifierName(this.lexer.peek().type)) result.name = @Identifier();",
            "if (this.lexer.peek().type === '<') result.typeParameters = @TypeParameters();",
            "result.parameters = @Parameters();",
            "@TypeAnnotation(result);",
            "@FunctionBody(result);"
        ]
    },
    "FunctionDeclaration": {
        "indent": 2,
        "doc": true,
        "extends": "Declaration",
        "comment": "函数声明(`function fn() {...}`、`function *fn() {...}`)",
        "name": "FunctionDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Decorators",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "function",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "*",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": "TypeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "Parameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "FunctionBody",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "const result = new @FunctionDeclaration();",
            "if (decorators) result.decorators = decorators;",
            "@FunctionDeclarationOrExpression(result, modifiers);",
            "return result;"
        ]
    },
    "FunctionExpression": {
        "indent": 2,
        "doc": true,
        "extends": "Expression",
        "comment": "函数表达式(`function () {}`)",
        "name": "FunctionExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "function",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "*",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": "TypeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "Parameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "FunctionBody",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "const result = new @FunctionDeclaration();",
            "@FunctionDeclarationOrExpression(result, modifiers);",
            "return result;"
        ]
    },
    "FunctionBody": {
        "indent": 2,
        "doc": false,
        "extends": "Node",
        "comment": "函数主体(`{...}`、`=> xx`、`;`)",
        "name": "FunctionBody",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "result",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "",
                "comment": "",
                "args": "",
                "equals": ">",
                "type": ""
            },
            {
                "optional": true,
                "name": "body",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "BlockStatement | Expression"
            },
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\tcase '{':",
            "\t\tresult.body = @BlockStatement();",
            "\t\tbreak;",
            "\tcase '=>':",
            "\t\tresult.arrowToken = @read;",
            "\t\tresult.body = @Expression(Precedence.assignment);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\t@tryReadSemicolon(result);",
            "\t\tbreak;",
            "}"
        ]
    },
    "ClassDeclarationOrExpression": {
        "indent": 1,
        "doc": false,
        "extends": "Expression",
        "comment": "类声明或类表达式",
        "name": "ClassDeclarationOrExpression",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "result",
                "equal": "",
                "question": false,
                "type": "nodes.ClassDeclaration | nodes.ClassExpression"
            }
        ],
        "parts": [],
        "codes": [
            "@DocComment(result);",
            "result.classToken = @readToken('class');",
            "if (isIdentifierName(this.lexer.peek().type) && this.lexer.peek().type !== 'extends' && this.lexer.peek().type !== 'implements') result.name = @Identifier();",
            "if (this.lexer.peek().type === '<') result.typeParameters = @TypeParameters();",
            "@ExtendsClause(result);",
            "@ImplementsClause(result);",
            "@ClassBody(result);"
        ]
    },
    "ClassDeclaration": {
        "indent": 2,
        "doc": true,
        "extends": "Declaration",
        "comment": "类声明(`class xx {}`)",
        "name": "ClassDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Decorators",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "class",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "name?",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": "TypeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "ExtendsClause",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "ImplementsClause",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "ClassBody",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "const result = new @ClassDeclaration();",
            "if (decorators) result.decorators = decorators;",
            "if (modifiers) result.modifiers = modifiers;",
            "@ClassDeclarationOrExpression(result);",
            "return result;"
        ]
    },
    "ClassExpression": {
        "indent": 2,
        "doc": true,
        "extends": "Expression",
        "comment": "类表达式(`class xx {}`)",
        "name": "ClassExpression",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "class",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "name?",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": "TypeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "ExtendsClause",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "ImplementsClause",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "ClassBody",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "const result = new @ClassExpression();",
            "@ClassDeclarationOrExpression(result);",
            "return result;"
        ]
    },
    "ExtendsClause": {
        "indent": 2,
        "doc": false,
        "extends": "Node",
        "comment": "extends 分句(`extends xx`)",
        "name": "ExtendsClause",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "result",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "extends",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "extends",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "ClassHeritageNode , ... isExpressionStart"
            }
        ],
        "codes": []
    },
    "ImplementsClause": {
        "indent": 2,
        "doc": false,
        "extends": "Node",
        "comment": "implements 分句(`implements xx`)",
        "name": "ImplementsClause",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "result",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "implements",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "implements",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "ClassHeritageNode , ... isExpressionStart"
            }
        ],
        "codes": []
    },
    "ClassHeritageNode": {
        "indent": 2,
        "doc": false,
        "extends": "Node",
        "comment": "extends 或 implements 分句项",
        "name": "ClassHeritageNode",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "value",
                "comment": "",
                "args": "Precedence.leftHandSide",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": []
    },
    "ClassBody": {
        "indent": 2,
        "doc": false,
        "extends": "Node",
        "comment": "类主体(`{...}`、`;`)",
        "name": "ClassBody",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "result",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "?members: { ClassElement ... }",
            "if (this.lexer.peek().type === '{') {",
            "\tresult.members = @NodeList(@ClassElement, '{', '}');",
            "} else {",
            "\t@tryReadSemicolon(result);",
            "}"
        ]
    },
    "ClassElement": {
        "indent": 3,
        "doc": false,
        "extends": "Node",
        "comment": "类成员",
        "name": "ClassElement",
        "equals": "MethodDeclaration | PropertyDeclaration | AccessorDeclaration",
        "params": [],
        "parts": [],
        "codes": [
            "const decorators = @Decorators();",
            "const modifiers = @Modifiers();",
            "switch (this.lexer.peek().type) {",
            "\tcase 'identifier':",
            "\t\tbreak;",
            "\tcase 'get':",
            "\tcase 'set':",
            "\t\tconst savedToken = @lexer.current;",
            "\t\t@lexer.read();",
            "\t\tif (isKeyword(this.lexer.peek().type) || this.lexer.peek().type === '[') {",
            "\t\t\treturn @AccessorDeclaration(decorators, modifiers, savedToken.type === 'get' ? savedToken.start : undefined, savedToken.type === 'set' ? savedToken.start : undefined);",
            "\t\t}",
            "\t\t@lexer.current = savedToken;",
            "\t\tbreak;",
            "\tcase '*':",
            "\t\treturn @MethodDeclaration(decorators, modifiers, @read, @PropertyName());",
            "}",
            "const name = @PropertyName();",
            "switch (this.lexer.peek().type) {",
            "\tcase '(':",
            "\tcase '<':",
            "\t\treturn @MethodDeclaration(decorators, modifiers, undefined, name);",
            "\tdefault:",
            "\t\treturn @PropertyDeclaration(decorators, modifiers, name);",
            "}"
        ]
    },
    "AccessorDeclaration": {
        "indent": 7,
        "doc": true,
        "extends": "Declaration",
        "comment": "访问器声明(`get x() {...}`、`set x(value) {...}`)",
        "name": "AccessorDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Decorators",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "get",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "set",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "PropertyName"
            },
            {
                "optional": false,
                "name": "Parameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "FunctionBody",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "MethodDeclaration": {
        "indent": 6,
        "doc": true,
        "extends": "Declaration",
        "comment": "方法声明(`x() {...}`)",
        "name": "MethodDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Decorators",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "*",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "name": "TypeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "Parameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "FunctionBody",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "PropertyDeclaration": {
        "indent": 6,
        "doc": true,
        "extends": "Declaration",
        "comment": "属性声明(`x: number`)",
        "name": "PropertyDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Decorators",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "name": "TypeAnnotation",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Initializer",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "InterfaceDeclaration": {
        "indent": 1,
        "doc": true,
        "extends": "Declaration",
        "comment": "接口声明(`interface T {...}`)",
        "name": "InterfaceDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Decorators",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "interface",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "false",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": "TypeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "ExtendsClause",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "members: { TypeMemberSignature ... }"
        ]
    },
    "EnumDeclaration": {
        "indent": 1,
        "doc": true,
        "extends": "Declaration",
        "comment": "枚举声明(`enum T {}`)",
        "name": "EnumDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Decorators",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "enum",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "false",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": "ExtendsClause",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "members: { EnumMemberDeclaration , ... isPropertyNameStart }"
        ]
    },
    "EnumMemberDeclaration": {
        "indent": 2,
        "doc": false,
        "extends": "Declaration",
        "comment": "枚举成员声明(`x`、`x = 1`)",
        "name": "EnumMemberDeclaration",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "name": "Initializer",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "NamespaceOrModuleDeclaration": {
        "indent": 1,
        "doc": true,
        "extends": "Declaration",
        "comment": "命名空间或模块声明",
        "name": "NamespaceOrModuleDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "result",
                "equal": "",
                "question": false,
                "type": "@NamespaceDeclaration | @ModuleDeclaration"
            },
            {
                "comment": "",
                "name": "decorators",
                "equal": "",
                "question": false,
                "type": "@NodeList<@Decorator>"
            },
            {
                "comment": "",
                "name": "modifiers",
                "equal": "",
                "question": false,
                "type": "@NodeList<@Modifier>"
            },
            {
                "comment": "",
                "name": "type",
                "equal": "",
                "question": false,
                "type": "TokenType"
            }
        ],
        "parts": [],
        "codes": [
            "@DocComment(result);",
            "if (decorators) result.decorators = decorators;",
            "if (modifiers) result.modifiers = modifiers;",
            "if (type === @namespace) result.namespaceToken = @readToken(type);",
            "else result.moduleToken = @readToken(type);",
            "if (type === 'module' && this.lexer.peek().type === 'stringLiteral') {",
            "\t(<@ModuleDeclaration>result).name = @StringLiteral();",
            "} else {",
            "\tresult.name = @Identifier();",
            "\twhile (this.lexer.peek().type === '.') {",
            "\t\tresult.name = @MemberCallExpression(result.name);",
            "\t}",
            "}",
            "@BlockBody(result);"
        ]
    },
    "NamespaceDeclaration": {
        "indent": 2,
        "doc": true,
        "extends": "Declaration",
        "comment": "命名空间声明(`namespace T {}`)",
        "name": "NamespaceDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Decorators",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "namespace",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Identifier | MemberCallExpression"
            },
            {
                "optional": true,
                "name": "BlockBody",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "const result = new @NamespaceDeclaration();",
            "@NamespaceOrModuleDeclaration(result, decorators, modifiers, 'namespace');",
            "return result;"
        ]
    },
    "ModuleDeclaration": {
        "indent": 2,
        "doc": true,
        "extends": "Declaration",
        "comment": "模块声明(`module T {}`)",
        "name": "ModuleDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Decorators",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "module",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Identifier | MemberCallExpression | StringLiteral"
            },
            {
                "optional": true,
                "name": "BlockBody",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "const result = new @ModuleDeclaration();",
            "@NamespaceOrModuleDeclaration(result, decorators, modifiers, 'module');",
            "return result;"
        ]
    },
    "BlockBody": {
        "indent": 2,
        "doc": false,
        "extends": "Node",
        "comment": "语句块主体(`{...}`)",
        "name": "BlockBody",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "result",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": [
            "statements: { Statement ... }"
        ]
    },
    "ExtensionDeclaration": {
        "indent": 1,
        "doc": true,
        "extends": "Declaration",
        "comment": "扩展声明(`extends T {}`)",
        "name": "ExtensionDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "Decorators",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "Modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "extends",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "type",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "TypeNode"
            },
            {
                "optional": true,
                "name": "ExtendsClause",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "ImplementsClause",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "ClassBody",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "DeclarationOrExpressionStatement": {
        "indent": 1,
        "doc": false,
        "extends": "Statement",
        "comment": "声明或表达式语句",
        "name": "DeclarationOrExpressionStatement",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "const savedState = @stashSave();",
            "const decorators = @Decorators();",
            "const modifiers = @Modifiers();",
            "switch (this.lexer.peek().type) {",
            "\tcase 'function':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @FunctionDeclaration(decorators, modifiers);",
            "\tcase 'class':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @ClassDeclaration(decorators, modifiers);",
            "\tcase 'interface':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @InterfaceDeclaration(decorators, modifiers);",
            "\tcase 'enum':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @EnumDeclaration(decorators, modifiers);",
            "\tcase 'namespace':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @NamespaceDeclaration(decorators, modifiers);",
            "\tcase 'module':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @ModuleDeclaration(decorators, modifiers);",
            "\tcase 'extends':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @ExtensionDeclaration(decorators, modifiers);",
            "\tdefault:",
            "\t\t@stashRestore(savedState);",
            "\t\treturn @ExpressionStatement(@Expression());",
            "}"
        ]
    },
    "Decorators": {
        "indent": 1,
        "doc": false,
        "extends": "Node",
        "comment": "修饰器列表",
        "name": "Decorators",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "decorators",
                "comment": "修饰器列表",
                "args": "",
                "equals": "",
                "type": "Decorator ..."
            }
        ],
        "codes": [
            "let result: @NodeList<@Decorator>;",
            "while (this.lexer.peek().type === '@') {",
            "\tif (!result) result = new @NodeList()<nodes.Modifier>();",
            "\tresult.push(@Decorator());",
            "}",
            "return result;"
        ]
    },
    "Decorator": {
        "indent": 2,
        "doc": false,
        "extends": "Node",
        "comment": "修饰器(`@x`)",
        "name": "Decorator",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "@",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "body",
                "comment": "",
                "args": "Precedence.leftHandSide",
                "equals": "",
                "type": "Expression"
            }
        ],
        "codes": []
    },
    "Modifiers": {
        "indent": 1,
        "doc": false,
        "extends": "Node",
        "comment": "修饰符列表",
        "name": "Modifiers",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Modifier ..."
            }
        ],
        "codes": [
            "let result: nodes.NodeList<nodes.Modifier>;",
            "while (isModifier(this.lexer.peek().type)) {",
            "\tconst savedToken = @lexer.current;",
            "\tconst modifier = @Modifier();",
            "\tswitch (modifier.type) {",
            "\t\tcase 'export':",
            "\t\t\tif (!result) result = new @NodeList()<@Modifier>();",
            "\t\t\tresult.push(modifier);",
            "\t\t\tif (this.lexer.peek().type === 'default') {",
            "\t\t\t\tresult.push(@Modifier());",
            "\t\t\t}",
            "\t\t\tcontinue;",
            "\t\tcase 'const':",
            "\t\t\tif (this.lexer.peek().type === 'enum') {",
            "\t\t\t\tif (!result) result = new @NodeList()<@Modifier>();",
            "\t\t\t\tresult.push(modifier);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tif (@sameLine) {",
            "\t\t\t\tif (!result) result = new @NodeList()<@Modifier>();",
            "\t\t\t\tresult.push(modifier);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t}",
            "\t@lexer.current = savedToken;",
            "\tbreak;",
            "}",
            "return result;"
        ]
    },
    "Modifier": {
        "indent": 2,
        "doc": false,
        "extends": "Node",
        "comment": "修饰符(`static`、`private`、...)",
        "name": "Modifier",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "type",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "'export'|'default'|'declare'|'const'|'static'|'abstract'|'readonly'|'async'|'public'|'protected'|'private'"
            }
        ],
        "codes": []
    },
    "TypeAliasDeclaration": {
        "indent": 1,
        "doc": false,
        "extends": "Declaration",
        "comment": "类型别名声明(`type A = number;`)",
        "name": "TypeAliasDeclaration",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "type",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "name",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": "TypeParameters",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "TypeNode",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "ImportAssignmentOrImportDeclaration": {
        "indent": 1,
        "doc": false,
        "extends": "Declaration",
        "comment": "import 赋值或 import 声明",
        "name": "ImportAssignmentOrImportDeclaration",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "const importToken = @read;",
            "const imports = @DelimitedList(@ImportClause, undefined, undefined, isBindingNameStart);",
            "if (this.lexer.peek().type === '=' && imports.length === 1 && imports[0].constructor === @SimpleImportClause && (<@SimpleImportClause>imports[0]).name == null) {",
            "\treturn @ImportAssignmentDeclaration(importToken, (<@SimpleImportClause>imports[0]).variable);",
            "}",
            "return @ImportDeclaration(importToken, imports);"
        ]
    },
    "ImportAssignmentDeclaration": {
        "indent": 2,
        "doc": false,
        "extends": "Declaration",
        "comment": "import 赋值声明",
        "name": "ImportAssignmentDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "import",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "variable",
                "comment": "别名",
                "args": "",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": false,
                "name": "",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "value",
                "comment": "",
                "args": "Precedence.assignment",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "ImportDeclaration": {
        "indent": 2,
        "doc": false,
        "extends": "Declaration",
        "comment": "import 声明(`import x from '...';`)",
        "name": "ImportDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            },
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "import",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": true,
                "name": "names",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "... ImportClause , ..."
            },
            {
                "optional": true,
                "name": "from ",
                "comment": "",
                "args": "",
                "equals": "imports ? @readToken(@from) : undefined",
                "type": ""
            },
            {
                "optional": false,
                "name": "expression",
                "comment": "导入模块名",
                "args": "",
                "equals": "",
                "type": "StringLiteral"
            },
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": [
            "const result = new @ImportDeclaration();",
            "if (names) {",
            "\tresult.names = names;",
            "\tresult.from = @readToken('from');",
            "}",
            "result.target = @StringLiteral();",
            "return result;"
        ]
    },
    "ImportClause": {
        "indent": 3,
        "doc": false,
        "extends": "Node",
        "comment": "import 分句(`x`、`{x}`、...)",
        "name": "ImportClause",
        "equals": "SimpleImportOrExportClause | NamespaceImportClause | NamedImportClause",
        "params": [],
        "parts": [],
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\t//+ case 'identifier':",
            "\t//+\t\treturn @SimpleImportOrExportClause(true);",
            "\tcase '*':",
            "\t\treturn @NamespaceImportClause();",
            "\tcase '{':",
            "\t\treturn @NamedImportClause();",
            "\tdefault:",
            "\t\treturn @SimpleImportClause();",
            "}"
        ]
    },
    "NamespaceImportClause": {
        "indent": 6,
        "doc": false,
        "extends": "Node",
        "comment": "命名空间导入分句(`* as x`)",
        "name": "NamespaceImportClause",
        "equals": "",
        "params": [],
        "parts": [
            {
                "optional": false,
                "name": "*",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "as",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "variable",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Identifier"
            }
        ],
        "codes": []
    },
    "NamedImportClause": {
        "indent": 6,
        "doc": false,
        "extends": "Node",
        "comment": "对象导入分句(`{x, x as y}`)",
        "name": "NamedImportClause",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "elements: { SimpleImportOrExportClause , ... }",
            "const result = new @NamedImportClause();",
            "result.elements = @DelimitedList(@SimpleImportClause, '{', '}', isIdentifierName);",
            "return result;"
        ]
    },
    "SimpleImportClause": {
        "indent": 6,
        "doc": false,
        "extends": "Node",
        "comment": "简单导入分句",
        "name": "SimpleImportClause",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "return @SimpleImportOrExportClause(true);"
        ]
    },
    "SimpleImportOrExportClause": {
        "indent": 4,
        "doc": false,
        "extends": "Node",
        "comment": "简单导入或导出分句(`x`、`x as y`)",
        "name": "SimpleImportOrExportClause",
        "equals": "",
        "params": [
            {
                "comment": "解析 import 分句",
                "name": "importClause",
                "equal": "",
                "question": false,
                "type": "boolean"
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "name",
                "comment": "导入或导出的名称",
                "args": "true",
                "equals": "",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": "as",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "variable",
                "comment": "导入或导出的变量",
                "args": "",
                "equals": "",
                "type": "Identifier"
            }
        ],
        "codes": [
            "const result = new @SimpleImportOrExportClause();",
            "const nameOrVariable = @Identifier(true);",
            "if (this.lexer.peek().type === @as) {",
            "\tresult.name = nameOrVariable;",
            "\tresult.asToken = @read;",
            "\tresult.variable = @Identifier(!importClause);",
            "} else {",
            "\tif (importClause && !isIdentifierName(@current)) {",
            "\t\t@error(@lexer.current, \"Identifier expected; Keyword '{0}' cannot be used as an identifier.\", getTokenName(@current));",
            "\t}",
            "\tresult.variable = nameOrVariable;",
            "}",
            "return result;"
        ]
    },
    "ExportAssignmentOrExportDeclaration": {
        "indent": 1,
        "doc": false,
        "extends": "Declaration",
        "comment": "export 赋值或 export 声明",
        "name": "ExportAssignmentOrExportDeclaration",
        "equals": "",
        "params": [],
        "parts": [],
        "codes": [
            "const savedState = @lexer.current;",
            "const exportToekn = @read;",
            "switch (this.lexer.peek().type) {",
            "\tcase 'function':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @FunctionDeclaration(undefined, @Modifiers());",
            "\tcase 'class':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @ClassDeclaration(undefined, @Modifiers());",
            "\tcase 'interface':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @InterfaceDeclaration(undefined, @Modifiers());",
            "\tcase 'enum':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @EnumDeclaration(undefined, @Modifiers());",
            "\tcase 'namespace':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @NamespaceDeclaration(undefined, @Modifiers());",
            "\tcase 'module':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @ModuleDeclaration(undefined, @Modifiers());",
            "\tcase 'var':",
            "\tcase 'let':",
            "\tcase 'const':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @VariableStatement(@Modifiers());",
            "\tcase '*':",
            "\t\treturn @ExportNamespaceDeclaration(exportToekn);",
            "\tcase '{':",
            "\t\treturn @ExportListDeclaration(exportToekn);",
            "\tcase '=':",
            "\t\treturn @ExportAssignmentDeclaration(start);",
            "\tdefault:",
            "\t\t// @lexer.current = savedState;",
            "\t\t// @error(this.lexer.peek().type, \"Declaration or statement expected. Unexpected token '{0}'.\", getTokenName(this.lexer.peek().type));",
            "\t\treturn @ExportDefaultDeclaration(@Modifiers());",
            "}"
        ]
    },
    "ExportNamespaceDeclaration": {
        "indent": 4,
        "doc": false,
        "extends": "Declaration",
        "comment": "导出列表声明(`export * from ...`)",
        "name": "ExportNamespaceDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "export",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "*",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "from",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "expression",
                "comment": "导入模块名",
                "args": "",
                "equals": "",
                "type": "StringLiteral"
            },
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "ExportListDeclaration": {
        "indent": 4,
        "doc": false,
        "extends": "Declaration",
        "comment": "导出列表声明(`export a from ...`)",
        "name": "ExportListDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "export",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "names",
                "comment": "",
                "args": "",
                "equals": "@DelimitedList(@SimpleImportOrExportClause, '{', '}', false)",
                "type": "{ SimpleImportOrExportClause ... }"
            },
            {
                "optional": false,
                "name": "from",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "expression",
                "comment": "导入模块名",
                "args": "",
                "equals": "",
                "type": "StringLiteral"
            },
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "ExportAssignmentDeclaration": {
        "indent": 4,
        "doc": false,
        "extends": "Declaration",
        "comment": "导出赋值声明(`export = 1;`)",
        "name": "ExportAssignmentDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": false,
                "name": "export",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            },
            {
                "optional": false,
                "name": "value",
                "comment": "",
                "args": "Precedence.assignment",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "ExportDefaultDeclaration": {
        "indent": 4,
        "doc": false,
        "extends": "Declaration",
        "comment": "export default 声明(`export default x = 1;`)",
        "name": "ExportDefaultDeclaration",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "*",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [
            {
                "optional": true,
                "name": "modifiers",
                "comment": "",
                "args": "",
                "equals": "",
                "type": "Modifiers"
            },
            {
                "optional": false,
                "name": "expression",
                "comment": "",
                "args": "Precedence.assignment",
                "equals": "",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ";",
                "comment": "",
                "args": "",
                "equals": "",
                "type": ""
            }
        ],
        "codes": []
    },
    "DocComment": {
        "indent": 0,
        "doc": false,
        "extends": "Node",
        "comment": "文档注释",
        "name": "DocComment",
        "equals": "",
        "params": [
            {
                "comment": "",
                "name": "result",
                "equal": "",
                "question": false,
                "type": ""
            }
        ],
        "parts": [],
        "codes": []
    }
}