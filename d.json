{
    "TypeNode": {
        "region": "类型节点",
        "name": "TypeNode",
        "params": [
            {
                "comment": "允许解析的最低操作符优先级。",
                "name": "precedence",
                "equal": "Precedence.any"
            }
        ],
        "extends": "Node",
        "comment": "解析一个类型节点。",
        "codes": [
            "let result: @TypeNode;",
            "if (isPredefinedType(this.lexer.peek().type)) {",
            "\tresult = @PredefinedTypeNode();",
            "} else {",
            "\tswitch (this.lexer.peek().type) {",
            "\t\t//+ case 'identifier':",
            "\t\t//+ \tresult = @GenericTypeOrTypeReferenceNode();",
            "\t\t//+ \tbreak;",
            "\t\tcase '(':",
            "\t\t\tresult = @FunctionOrParenthesizedTypeNode();",
            "\t\t\tbreak;",
            "\t\tcase '[':",
            "\t\t\tresult = @TupleTypeNode();",
            "\t\t\tbreak;",
            "\t\tcase '{':",
            "\t\t\tresult = @ObjectTypeNode();",
            "\t\t\tbreak;",
            "\t\tcase 'new':",
            "\t\t\treturn @ConstructorTypeNode();",
            "\t\tcase '<':",
            "\t\t\treturn @FunctionTypeNode(@TypeParameters(), @Parameters());",
            "\t\tcase 'typeof':",
            "\t\t\tresult = @TypeQueryNode();",
            "\t\t\tbreak;",
            "\t\tcase '=>':",
            "\t\t\treturn @FunctionTypeNode();",
            "\t\tcase 'numericLiteral':",
            "\t\tcase 'stringLiteral':",
            "\t\tcase 'true':",
            "\t\tcase 'false':",
            "\t\t\tresult = @LiteralTypeNode();",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tresult = @GenericTypeOrTypeReferenceNode();",
            "\t\t\tbreak;",
            "\t}",
            "}",
            "while (getPrecedence(this.lexer.peek().type) >= precedence) {",
            "\tswitch (this.lexer.peek().type) {",
            "\t\tcase '.':",
            "\t\t\tresult = @QualifiedNameTypeNode(result);",
            "\t\t\tcontinue;",
            "\t\tcase '[':",
            "\t\t\tif (@sameLine) {",
            "\t\t\t\tresult = @ArrayTypeNode(result);",
            "\t\t\t}",
            "\t\t\tcontinue;",
            "\t\tcase '&':",
            "\t\tcase '|':",
            "\t\tcase 'is':",
            "\t\t\tresult = @BinaryTypeNode(result);",
            "\t\t\tcontinue;",
            "\t}",
            "\tbreak;",
            "}",
            "return result;"
        ]
    },
    "PredefinedTypeNode": {
        "region": "类型节点",
        "name": "PredefinedTypeNode",
        "extends": "Node",
        "comment": "解析一个内置类型节点(`number`、`string`、...)。",
        "parts": [
            {
                "name": "type",
                "comment": "获取当前内置类型节点的类型。合法的值有：`any`、`number`、`boolean`、`string`、`symbol`、`void`、`never`、`this`、`null`、`undefined`、`char`、`byte`、`int`、`long`、`short`、`uint`、`ulong`、`ushort`、`float`、`double`、`*`、`?`。",
                "equals": "@read",
                "type": "number",
                "tokens": [
                    "any",
                    "number",
                    "boolean",
                    "string",
                    "symbol",
                    "void",
                    "never",
                    "this",
                    "null",
                    "undefined",
                    "char",
                    "byte",
                    "int",
                    "long",
                    "short",
                    "uint",
                    "ulong",
                    "ushort",
                    "float",
                    "double",
                    "*",
                    "?"
                ]
            }
        ],
        "codes": [
            "const result = new @PredefinedTypeNode();",
            "result.type = @read;",
            "return result;"
        ],
        "classComment": "表示一个内置类型节点(`number`、`string`、...)。"
    },
    "GenericTypeOrTypeReferenceNode": {
        "region": "类型节点",
        "name": "GenericTypeOrTypeReferenceNode",
        "extends": "Node",
        "comment": "解析一个泛型类型节点(`x<T>`)或类型引用节点(`x`)。",
        "codes": [
            "let result = @TypeReferenceNode();",
            "if (@sameLine && this.lexer.peek().type === '<') {",
            "\treturn @GenericTypeNode(result);",
            "}",
            "return result;"
        ]
    },
    "GenericTypeNode": {
        "region": "类型节点",
        "name": "GenericTypeNode",
        "params": [
            {
                "comment": "undefined。",
                "name": "target",
                "type": "TypeReferenceNode"
            }
        ],
        "extends": "Node",
        "comment": "解析一个泛型类型节点(`Array<number>`)。",
        "parts": [
            {
                "name": "target",
                "comment": "获取当前泛型类型节点的目标部分。",
                "equals": "target",
                "type": "TypeReferenceNode"
            },
            {
                "name": "typeArguments",
                "comment": "获取当前泛型类型节点的类型参数部分。",
                "equals": "@DelimitedList(@TypeArgument, '<', '>', false, @isTypeNodeStart)",
                "type": "@NodeList<@TypeArgument>"
            }
        ],
        "codes": [
            "const result = new @GenericTypeNode();",
            "result.target = target;",
            "result.typeArguments = @DelimitedList(@TypeArgument, '<', '>', false, @isTypeNodeStart);",
            "return result;"
        ],
        "classComment": "表示一个泛型类型节点(`Array<number>`)。"
    },
    "TypeArguments": {
        "region": "类型节点",
        "name": "TypeArguments",
        "extends": "Node",
        "list": {
            "element": "TypeArgument",
            "open": "<",
            "close": ">",
            "continue": "isTypeNodeStart",
            "seperator": ",",
            "optional": false,
            "type": "@NodeList<@TypeArgument>",
            "equals": "@DelimitedList(@TypeArgument, '<', '>', false, @isTypeNodeStart)"
        },
        "comment": "解析一个类型参数列表(`<number>`)。"
    },
    "TypeArgument": {
        "region": "类型节点",
        "name": "TypeArgument",
        "extends": "Node",
        "comment": "解析一个类型参数(`number`)。",
        "parts": [
            {
                "name": "value",
                "comment": "获取当前类型参数的值。",
                "args": "Precedence.assignment",
                "equals": "@TypeNode(Precedence.assignment)",
                "type": "TypeNode"
            }
        ],
        "codes": [
            "const result = new @TypeArgument();",
            "result.value = @TypeNode(Precedence.assignment);",
            "return result;"
        ],
        "classComment": "表示一个类型参数(`number`)。"
    },
    "TypeReferenceNode": {
        "region": "类型节点",
        "name": "TypeReferenceNode",
        "extends": "TypeNode",
        "comment": "解析一个类型引用节点(`x`)。",
        "parts": [
            {
                "name": "value",
                "comment": "获取当前类型引用节点的值部分。",
                "equals": "@readToken('identifier')",
                "type": "number",
                "tokens": [
                    "identifier"
                ]
            }
        ],
        "codes": [
            "if (isIdentifierName(this.lexer.peek().type)) {",
            "\tconst result = new @TypeReferenceNode();",
            "\tresult.start = @read;",
            "\tresult.value = @lexer.current.value;",
            "\tresult.end = @lexer.current.end;",
            "\treturn result;",
            "}",
            "@error(@lexer.peek(), \"Type expected. Unexpected token '{0}'.\", getTokenName(this.lexer.peek().type));",
            "return @ErrorTypeNode();"
        ],
        "classComment": "表示一个类型引用节点(`x`)。"
    },
    "ErrorTypeNode": {
        "region": "类型节点",
        "name": "ErrorTypeNode",
        "params": [
            {
                "comment": "标记的开始位置。",
                "name": "start",
                "equal": "@lexer.current.end"
            }
        ],
        "extends": "Node",
        "comment": "解析一个错误的类型节点。",
        "codes": [
            "const result = new @ErrorTypeNode();",
            "result.start = start;",
            "result.end = @lexer.current.end;",
            "return result;"
        ]
    },
    "FunctionOrParenthesizedTypeNode": {
        "region": "类型节点",
        "name": "FunctionOrParenthesizedTypeNode",
        "extends": "Node",
        "comment": "解析一个函数(`()=> void`)或括号类型节点(`(x)`)。",
        "codes": [
            "const savedState = @stashSave();",
            "const parameters = @Parameters();",
            "if (this.lexer.peek().type === '=>') {",
            "\t@stashClear(savedState);",
            "\treturn @FunctionTypeNode(undefined, parameters);",
            "}",
            "@stashRestore(savedState);",
            "return @ParenthesizedTypeNode();"
        ]
    },
    "FunctionTypeNode": {
        "region": "类型节点",
        "name": "FunctionTypeNode",
        "params": [
            {
                "comment": "undefined。",
                "name": "typeParameters",
                "type": "TypeParameters"
            },
            {
                "comment": "undefined。",
                "name": "parameters",
                "type": "Parameters"
            }
        ],
        "extends": "Node",
        "comment": "解析一个函数类型节点(`(x: number) => void`)。。",
        "parts": [
            {
                "optional": true,
                "name": "typeParameters",
                "comment": "获取当前函数类型节点。的(可能不存在)。",
                "equals": "typeParameters",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "optional": true,
                "name": "parameters",
                "comment": "获取当前函数类型节点。的(可能不存在)。",
                "equals": "parameters",
                "type": "@NodeList<@ParameterDeclaration>"
            },
            {
                "name": "=>Token",
                "comment": "获取当前函数类型节点。的=>Token 的位置。",
                "equals": "@readToken('=>')",
                "type": "number",
                "tokens": [
                    "=>"
                ]
            },
            {
                "name": "returnType",
                "comment": "获取当前函数类型节点。的undefined。",
                "equals": "@TypeNode()()",
                "type": "TypeNode()"
            }
        ],
        "codes": [
            "const result = new @FunctionTypeNode();",
            "result.typeParameters = typeParameters;",
            "result.parameters = parameters;",
            "result.=>Token = @readToken('=>');",
            "result.returnType = @TypeNode()();",
            "return result;"
        ],
        "classComment": "表示一个函数类型节点(`(x: number) => void`)。。"
    },
    "TypeParameters": {
        "region": "类型节点",
        "name": "TypeParameters",
        "extends": "Node",
        "list": {
            "element": "TypeParameterDeclaration",
            "open": "<",
            "close": ">",
            "continue": "isIdentifierName",
            "seperator": ",",
            "optional": false,
            "type": "@NodeList<@TypeParameterDeclaration>",
            "equals": "@DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName)"
        },
        "comment": "解析一个类型参数列表(`<T>`)。"
    },
    "TypeParameterDeclaration": {
        "region": "类型节点",
        "name": "TypeParameterDeclaration",
        "extends": "Declaration",
        "comment": "解析一个类型参数声明(`T`、`T extends R`)。",
        "parts": [
            {
                "name": "name",
                "comment": "获取当前类型参数声明的(可能不存在)。",
                "equals": "@Identifier()",
                "type": "Identifier"
            },
            {
                "optional": true,
                "comment": "获取当前类型参数声明的(可能不存在)。",
                "equals": "@extends()",
                "type": "extends"
            },
            {
                "optional": true,
                "name": "extends",
                "comment": "获取当前类型参数声明的(可能不存在)。",
                "equals": "@TypeNode()",
                "type": "TypeNode"
            }
        ],
        "codes": [
            "const result = new @TypeParameterDeclaration();",
            "result.name = @Identifier();",
            "if (this.lexer.peek().type === 'extends') {",
            "\tresult.extendsToken = @readToken('extends');",
            "\tresult.extends = @TypeNode();",
            "}",
            "return result;"
        ],
        "classComment": "表示一个类型参数声明(`T`、`T extends R`)。"
    },
    "Parameters": {
        "region": "类型节点",
        "name": "Parameters",
        "extends": "Node",
        "list": {
            "element": "ParameterDeclaration",
            "open": "(",
            "close": ")",
            "continue": "isBindingElementStart",
            "seperator": ",",
            "optional": true,
            "type": "@NodeList<@ParameterDeclaration>",
            "equals": "@DelimitedList(@ParameterDeclaration, '(', ')', true, @isBindingElementStart)"
        },
        "comment": "解析一个参数列表(`(x, y)`)。"
    },
    "ParameterDeclaration": {
        "region": "类型节点",
        "name": "ParameterDeclaration",
        "extends": "Declaration",
        "comment": "解析一个参数声明(`x`、`x?: number`)。",
        "parts": [
            {
                "optional": true,
                "name": "modifiers",
                "comment": "获取当前参数声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "optional": true,
                "name": "...Token",
                "comment": "获取当前参数声明的...Token 的位置(可能不存在)。",
                "equals": "@readToken('...')",
                "type": "number",
                "tokens": [
                    "..."
                ]
            },
            {
                "name": "name",
                "comment": "获取当前参数声明的(可能不存在)。",
                "equals": "@BindingName()",
                "type": "BindingName"
            },
            {
                "optional": true,
                "name": "?Token",
                "comment": "获取当前参数声明的?Token 的位置(可能不存在)。",
                "equals": "@readToken('?')",
                "type": "number",
                "tokens": [
                    "?"
                ]
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前参数声明的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            },
            {
                "inlined": true,
                "name": "=Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "initializer",
                "type": "Expression",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前参数声明的(可能不存在)。",
                "equals": "@Initializer()",
                "type": "Initializer"
            }
        ],
        "codes": [
            "const result = new @ParameterDeclaration();",
            "result.modifiers = @Modifiers();",
            "if (@peek === '...') result....Token = @readToken('...');",
            "result.name = @BindingName();",
            "if (@peek === '?') result.?Token = @readToken('?');",
            "result.:Token = undefined;",
            "result.type = undefined;",
            "result. = @TypeAnnotation();",
            "result.=Token = undefined;",
            "result.initializer = undefined;",
            "result. = @Initializer();",
            "return result;"
        ],
        "classComment": "表示一个参数声明(`x`、`x?: number`)。"
    },
    "BindingName": {
        "region": "类型节点",
        "name": "BindingName",
        "extends": "Node",
        "alias": "Identifier | ArrayBindingPattern | ObjectBindingPattern",
        "comment": "解析一个绑定名称(`x`, `[x]`, `{x: x}`)。"
    },
    "ArrayBindingPattern": {
        "region": "类型节点",
        "name": "ArrayBindingPattern",
        "extends": "Node",
        "comment": "解析一个数组绑定模式项(`[x]`)。",
        "parts": [
            {
                "name": "elements",
                "comment": "获取当前数组绑定模式项的所有元素。",
                "equals": "@DelimitedList(@ArrayBindingElement, '[', ']', true, @isArrayBindingElementStart)",
                "type": "[ ?ArrayBindingElement , ...isArrayBindingElementStart ]",
                "list": {
                    "element": "ArrayBindingElement",
                    "open": "[",
                    "close": "]",
                    "continue": "isArrayBindingElementStart",
                    "seperator": ",",
                    "optional": true,
                    "type": "@NodeList<@ArrayBindingElement>",
                    "equals": "@DelimitedList(@ArrayBindingElement, '[', ']', true, @isArrayBindingElementStart)"
                }
            }
        ],
        "codes": [
            "const result = new @ArrayBindingPattern();",
            "result.elements = @DelimitedList(@ArrayBindingElement, '[', ']', true, @isArrayBindingElementStart);",
            "return result;"
        ],
        "classComment": "表示一个数组绑定模式项(`[x]`)。"
    },
    "ArrayBindingElement": {
        "region": "类型节点",
        "name": "ArrayBindingElement",
        "extends": "Node",
        "comment": "解析一个数组绑定模式项(`x`)。",
        "parts": [
            {
                "optional": true,
                "name": "...Token",
                "comment": "获取当前数组绑定模式项的...Token 的位置(可能不存在)。",
                "equals": "@readToken('...')",
                "type": "number",
                "tokens": [
                    "..."
                ]
            },
            {
                "optional": true,
                "name": "value",
                "comment": "获取当前数组绑定模式项的(可能不存在)。",
                "equals": "@BindingName()",
                "type": "BindingName"
            },
            {
                "inlined": true,
                "name": "=Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "initializer",
                "type": "Expression",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前数组绑定模式项的(可能不存在)。",
                "equals": "@Initializer()",
                "type": "Initializer"
            }
        ],
        "codes": [
            "const result = new @ArrayBindingElement();",
            "if (this.lexer.peek().type !== ',' && this.lexer.peek().type !== ']') {",
            "\tif (this.lexer.peek().type === '...') result.dotDotDotToken = @readToken('...');",
            "\tresult.value = @BindingName();",
            "\t@Initializer(result);",
            "}",
            "return result;"
        ],
        "classComment": "表示一个数组绑定模式项(`x`)。"
    },
    "ObjectBindingPattern": {
        "region": "类型节点",
        "name": "ObjectBindingPattern",
        "extends": "Node",
        "comment": "解析一个对象绑定模式项(`{x: x}`)。",
        "parts": [
            {
                "name": "elements",
                "comment": "获取当前对象绑定模式项的所有元素。",
                "equals": "@DelimitedList(@ObjectBindingElement, '{', '}', true, @isObjectBindingElementStart)",
                "type": "{ ?ObjectBindingElement , ...isObjectBindingElementStart }",
                "list": {
                    "element": "ObjectBindingElement",
                    "open": "{",
                    "close": "}",
                    "continue": "isObjectBindingElementStart",
                    "seperator": ",",
                    "optional": true,
                    "type": "@NodeList<@ObjectBindingElement>",
                    "equals": "@DelimitedList(@ObjectBindingElement, '{', '}', true, @isObjectBindingElementStart)"
                }
            }
        ],
        "codes": [
            "const result = new @ObjectBindingPattern();",
            "result.elements = @DelimitedList(@ObjectBindingElement, '{', '}', true, @isObjectBindingElementStart);",
            "return result;"
        ],
        "classComment": "表示一个对象绑定模式项(`{x: x}`)。"
    },
    "ObjectBindingElement": {
        "region": "类型节点",
        "name": "ObjectBindingElement",
        "extends": "Node",
        "comment": "解析一个对象绑定模式项(`x`)。",
        "parts": [
            {
                "optional": true,
                "name": "...Token",
                "comment": "获取当前对象绑定模式项的...Token 的位置(可能不存在)。",
                "equals": "@readToken('...')",
                "type": "number",
                "tokens": [
                    "..."
                ]
            },
            {
                "name": "key",
                "comment": "获取当前对象绑定模式项的undefined。",
                "equals": "@PropertyName,()",
                "type": "PropertyName,"
            },
            {
                "optional": true,
                "name": ":Token",
                "comment": "获取当前对象绑定模式项的:Token 的位置(可能不存在)。",
                "equals": "@readToken(':')",
                "type": "number",
                "tokens": [
                    ":"
                ]
            },
            {
                "name": "value",
                "comment": "获取当前对象绑定模式项的值。",
                "equals": "@BindingName()",
                "type": "BindingName"
            },
            {
                "inlined": true,
                "name": "=Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "initializer",
                "type": "Expression",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前对象绑定模式项的(可能不存在)。",
                "equals": "@Initializer()",
                "type": "Initializer"
            }
        ],
        "codes": [
            "const result = new @ObjectBindingElement();",
            "if (@peek === '...') result....Token = @readToken('...');",
            "result.key = @PropertyName,();",
            "if (@peek === ':') result.:Token = @readToken(':');",
            "result.value = @BindingName();",
            "result.=Token = undefined;",
            "result.initializer = undefined;",
            "result. = @Initializer();",
            "return result;"
        ],
        "classComment": "表示一个对象绑定模式项(`x`)。"
    },
    "PropertyName": {
        "region": "类型节点",
        "name": "PropertyName",
        "extends": "Node",
        "alias": "Identifier | NumericLiteral | StringLiteral | ComputedPropertyName",
        "comment": "解析一个属性名称(`xx`、`\"xx\"`、`0`、`[xx]`)。",
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\t//+ case 'identifier':",
            "\t//+ \treturn @Identifier(true);",
            "\tcase 'stringLiteral':",
            "\t\treturn @StringLiteral();",
            "\tcase 'numericLiteral':",
            "\t\treturn @NumericLiteral();",
            "\tcase '[':",
            "\t\treturn @ComputedPropertyName();",
            "\tdefault:",
            "\t\treturn @Identifier(true);",
            "}"
        ]
    },
    "ComputedPropertyName": {
        "region": "类型节点",
        "name": "ComputedPropertyName",
        "extends": "Node",
        "comment": "解析一个已计算的属性名(`[1]`)。",
        "parts": [
            {
                "name": "body",
                "comment": "获取当前已计算的属性名的主体部分。",
                "args": "Precedence.assignment",
                "equals": "@Expression(Precedence.assignment)",
                "type": "Expression"
            }
        ],
        "codes": [
            "[ ",
            "]"
        ],
        "classComment": "表示一个已计算的属性名(`[1]`)。"
    },
    "TypeAnnotation": {
        "region": "类型节点",
        "name": "TypeAnnotation",
        "params": [
            {
                "comment": "存放结果的目标节点。",
                "name": "result",
                "type": "{':'?: number, type?: TypeNode}"
            }
        ],
        "extends": "Node",
        "comment": "解析一个类型注解(`: number`)。",
        "parts": [
            {
                "optional": true,
                "name": ":Token",
                "comment": "获取当前类型注解的:Token 的位置(可能不存在)。",
                "equals": "@readToken(':')",
                "type": "number",
                "tokens": [
                    ":"
                ]
            },
            {
                "optional": true,
                "name": "type",
                "comment": "获取当前类型注解的类型部分(可能不存在)。",
                "equals": "@TypeNode()",
                "type": "TypeNode"
            }
        ],
        "codes": [
            "if (@peek === ':') result.:Token = @readToken(':');",
            "result.type = @TypeNode();"
        ],
        "inline": true,
        "classComment": "表示一个类型注解(`: number`)。"
    },
    "Initializer": {
        "region": "类型节点",
        "name": "Initializer",
        "params": [
            {
                "comment": "存放结果的目标节点。",
                "name": "result",
                "type": "{'='?: number, initializer?: Expression}"
            },
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "type": "boolean"
            }
        ],
        "extends": "Node",
        "comment": "解析一个初始值。",
        "parts": [
            {
                "optional": true,
                "name": "=Token",
                "comment": "获取当前初始值的=Token 的位置(可能不存在)。",
                "equals": "@readToken('=')",
                "type": "number",
                "tokens": [
                    "="
                ]
            },
            {
                "optional": true,
                "name": "initializer",
                "comment": "获取当前初始值的(可能不存在)。",
                "args": "Precedence.assignment, allowIn",
                "equals": "@Expression(Precedence.assignment, allowIn)",
                "type": "Expression"
            }
        ],
        "codes": [
            "if (@peek === '=') result.=Token = @readToken('=');",
            "result.initializer = @Expression(Precedence.assignment, allowIn);"
        ],
        "inline": true,
        "classComment": "表示一个初始值。"
    },
    "ParenthesizedTypeNode": {
        "region": "类型节点",
        "name": "ParenthesizedTypeNode",
        "extends": "Node",
        "comment": "解析一个括号类型节点(`(number)`)。",
        "parts": [
            {
                "name": "(Token",
                "comment": "获取当前括号类型节点的(Token 的位置。",
                "equals": "@readToken('(')",
                "type": "number",
                "tokens": [
                    "("
                ]
            },
            {
                "name": "body",
                "comment": "获取当前括号类型节点的主体部分。",
                "equals": "@TypeNode()()",
                "type": "TypeNode()"
            },
            {
                "name": ")Token",
                "comment": "获取当前括号类型节点的)Token 的位置。",
                "equals": "@readToken(')')",
                "type": "number",
                "tokens": [
                    ")"
                ]
            }
        ],
        "codes": [
            "const result = new @ParenthesizedTypeNode();",
            "result.(Token = @readToken('(');",
            "result.body = @TypeNode()();",
            "result.)Token = @readToken(')');",
            "return result;"
        ],
        "classComment": "表示一个括号类型节点(`(number)`)。"
    },
    "TupleTypeNode": {
        "region": "类型节点",
        "name": "TupleTypeNode",
        "extends": "Node",
        "comment": "解析一个元祖类型节点(`[string, number]`)。",
        "parts": [
            {
                "name": "elements",
                "comment": "获取当前元祖类型节点的所有元素。",
                "equals": "@DelimitedList(@TupleTypeElement, '[', ']', true, @isTypeNodeStart)",
                "type": "[ ?TupleTypeElement , ...isTypeNodeStart ]",
                "list": {
                    "element": "TupleTypeElement",
                    "open": "[",
                    "close": "]",
                    "continue": "isTypeNodeStart",
                    "seperator": ",",
                    "optional": true,
                    "type": "@NodeList<@TupleTypeElement>",
                    "equals": "@DelimitedList(@TupleTypeElement, '[', ']', true, @isTypeNodeStart)"
                }
            }
        ],
        "codes": [
            "const result = new @TupleTypeNode();",
            "result.elements = @DelimitedList(@TupleTypeElement, '[', ']', true, @isTypeNodeStart);",
            "return result;"
        ],
        "classComment": "表示一个元祖类型节点(`[string, number]`)。"
    },
    "TupleTypeElement": {
        "region": "类型节点",
        "name": "TupleTypeElement",
        "extends": "Node",
        "comment": "解析一个元祖类型节点元素(`x`)。",
        "parts": [
            {
                "name": "value",
                "comment": "获取当前元祖类型节点元素的值。",
                "args": "Precedence.assignment",
                "equals": "@TypeNode(Precedence.assignment)",
                "type": "TypeNode"
            }
        ],
        "codes": [
            "const result = new @TupleTypeElement();",
            "result.value = @TypeNode(Precedence.assignment);",
            "return result;"
        ],
        "classComment": "表示一个元祖类型节点元素(`x`)。"
    },
    "ObjectTypeNode": {
        "region": "类型节点",
        "name": "ObjectTypeNode",
        "extends": "Node",
        "comment": "解析一个对象类型节点(`{x: number}`)。",
        "parts": [
            {
                "name": "elements",
                "comment": "获取当前对象类型节点的所有元素。",
                "equals": "@NodeList(@TypeMemberSignature, '{', '}')",
                "type": "{ TypeMemberSignature ... }",
                "list": {
                    "element": "TypeMemberSignature",
                    "open": "{",
                    "close": "}",
                    "continue": "",
                    "seperator": "",
                    "optional": false,
                    "type": "@NodeList<@TypeMemberSignature>",
                    "equals": "@NodeList(@TypeMemberSignature, '{', '}')"
                }
            }
        ],
        "codes": [
            "const result = new @ObjectTypeNode();",
            "result.elements = @NodeList(@TypeMemberSignature, '{', '}');",
            "return result;"
        ],
        "classComment": "表示一个对象类型节点(`{x: number}`)。"
    },
    "TypeMemberSignature": {
        "region": "类型节点",
        "name": "TypeMemberSignature",
        "extends": "Node",
        "alias": "PropertySignature | CallSignature | ConstructSignature | IndexSignature | MethodSignature | AccessorSignature",
        "comment": "解析一个类型成员签名(`x： y`、`x() {...}`)。",
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\t//+ case 'identifier':",
            "\t//+ \tbreak;",
            "\tcase 'get':",
            "\tcase 'set':",
            "\t\tconst savedToken = @lexer.current;",
            "\t\t@lexer.read();",
            "\t\tif (isKeyword(this.lexer.peek().type) || this.lexer.peek().type === '[') {",
            "\t\t\treturn @AccessorSignature(savedToken.type === 'get' ? savedToken.start : undefined, savedToken.type === 'set' ? savedToken.start : undefined);",
            "\t\t}",
            "\t\t@lexer.current = savedToken;",
            "\t\tbreak;",
            "\tcase '[':",
            "\t\tlet isIndexSignature;",
            "\t\tconst savedToken = @lexer.current;",
            "\t\t@lexer.read();",
            "\t\tif (isIdentifierName(this.lexer.peek().type)) {",
            "\t\t\t@lexer.read();",
            "\t\t\tisIndexSignature = this.lexer.peek().type === ':';",
            "\t\t}",
            "\t\t@lexer.current = savedToken;",
            "\t\tif (isIndexSignature) {",
            "\t\t\treturn @IndexSignature();",
            "\t\t}",
            "\t\tbreak;",
            "\tcase '(':",
            "\t\treturn @CallSignature();",
            "\tcase 'new':",
            "\t\treturn @ConstructSignature();",
            "}",
            "const name = @PropertyName();",
            "const questionToken = this.lexer.peek().type === '?' ? @readToken('?') : undefined;",
            "switch (this.lexer.peek().type) {",
            "\tcase '(':",
            "\tcase '<':",
            "\t\treturn @MethodSignature(name, questionToken);",
            "\tdefault:",
            "\t\treturn @PropertySignature(name, questionToken);",
            "}"
        ]
    },
    "PropertySignature": {
        "region": "类型节点",
        "name": "PropertySignature",
        "params": [
            {
                "comment": "undefined。",
                "name": "name",
                "type": "PropertyName"
            },
            {
                "comment": "undefined。",
                "name": "?Token",
                "type": "number"
            }
        ],
        "doc": true,
        "extends": "Node",
        "comment": "解析一个属性签名(`x: number`)。",
        "parts": [
            {
                "name": "name",
                "comment": "获取当前属性签名的(可能不存在)。",
                "equals": "name",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "name": "?Token",
                "comment": "获取当前属性签名的?Token 的位置(可能不存在)。",
                "equals": "?Token",
                "type": "number",
                "tokens": [
                    "?"
                ]
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前属性签名的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            }
        ],
        "codes": [
            "ObjectMemberTail"
        ],
        "classComment": "表示一个属性签名(`x: number`)。"
    },
    "CallSignature": {
        "region": "类型节点",
        "name": "CallSignature",
        "doc": true,
        "extends": "Node",
        "comment": "解析一个函数签名(`(): number`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前函数签名的(可能不存在)。",
                "equals": "@DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName)",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前函数签名的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            }
        ],
        "codes": [
            "Parameters",
            "ObjectMemberTail"
        ],
        "classComment": "表示一个函数签名(`(): number`)。"
    },
    "ConstructSignature": {
        "region": "类型节点",
        "name": "ConstructSignature",
        "doc": true,
        "extends": "Node",
        "comment": "解析一个构造函数签名(`new x(): number`)。",
        "parts": [
            {
                "name": "newToken",
                "comment": "获取当前构造函数签名的newToken 的位置。",
                "equals": "@readToken('new')",
                "type": "number",
                "tokens": [
                    "new"
                ]
            },
            {
                "optional": true,
                "comment": "获取当前构造函数签名的(可能不存在)。",
                "equals": "@DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName)",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前构造函数签名的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            }
        ],
        "codes": [
            "Parameters",
            "ObjectMemberTail"
        ],
        "classComment": "表示一个构造函数签名(`new x(): number`)。"
    },
    "IndexSignature": {
        "region": "类型节点",
        "name": "IndexSignature",
        "doc": true,
        "extends": "Node",
        "comment": "解析一个索引器声明(`get x() {...}`、`set x(value) {...}`)。",
        "parts": [
            {
                "name": "[Token",
                "comment": "获取当前索引器声明的[Token 的位置。",
                "equals": "@readToken('[')",
                "type": "number",
                "tokens": [
                    "["
                ]
            },
            {
                "name": "argument",
                "comment": "获取当前索引器声明的参数部分。",
                "equals": "@Identifier()",
                "type": "Identifier"
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前索引器声明的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            },
            {
                "name": "]Token",
                "comment": "获取当前索引器声明的]Token 的位置。",
                "equals": "@readToken(']')",
                "type": "number",
                "tokens": [
                    "]"
                ]
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前索引器声明的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            }
        ],
        "codes": [
            "ObjectMemberTail"
        ],
        "classComment": "表示一个索引器声明(`get x() {...}`、`set x(value) {...}`)。"
    },
    "MethodSignature": {
        "region": "类型节点",
        "name": "MethodSignature",
        "params": [
            {
                "comment": "undefined。",
                "name": "name",
                "type": "PropertyName"
            },
            {
                "comment": "undefined。",
                "name": "?Token",
                "type": "number"
            }
        ],
        "doc": true,
        "extends": "Node",
        "comment": "解析一个方法签名(`x(): number`)。",
        "parts": [
            {
                "name": "name",
                "comment": "获取当前方法签名的(可能不存在)。",
                "equals": "name",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "name": "?Token",
                "comment": "获取当前方法签名的?Token 的位置(可能不存在)。",
                "equals": "?Token",
                "type": "number",
                "tokens": [
                    "?"
                ]
            },
            {
                "optional": true,
                "comment": "获取当前方法签名的(可能不存在)。",
                "equals": "@DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName)",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前方法签名的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            }
        ],
        "codes": [
            "Parameters",
            "ObjectMemberTail"
        ],
        "classComment": "表示一个方法签名(`x(): number`)。"
    },
    "AccessorSignature": {
        "region": "类型节点",
        "name": "AccessorSignature",
        "params": [
            {
                "comment": "undefined。",
                "name": "getToken",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "setToken",
                "type": "number"
            }
        ],
        "doc": true,
        "extends": "Node",
        "comment": "解析一个访问器签名(`get x(): number`、`set x(value): void`)。",
        "parts": [
            {
                "optional": true,
                "name": "getToken",
                "comment": "获取当前访问器签名的getToken 的位置(可能不存在)。",
                "equals": "getToken",
                "type": "number",
                "tokens": [
                    "get"
                ]
            },
            {
                "optional": true,
                "name": "setToken",
                "comment": "获取当前访问器签名的setToken 的位置(可能不存在)。",
                "equals": "setToken",
                "type": "number",
                "tokens": [
                    "set"
                ]
            },
            {
                "name": "name",
                "comment": "获取当前访问器签名的(可能不存在)。",
                "equals": "@PropertyName()",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "name": "?Token",
                "comment": "获取当前访问器签名的?Token 的位置(可能不存在)。",
                "equals": "@readToken('?')",
                "type": "number",
                "tokens": [
                    "?"
                ]
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前访问器签名的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            }
        ],
        "codes": [
            "Parameters",
            "ObjectMemberTail"
        ],
        "classComment": "表示一个访问器签名(`get x(): number`、`set x(value): void`)。"
    },
    "ObjectMemberTail": {
        "region": "类型节点",
        "name": "ObjectMemberTail",
        "params": [
            {
                "comment": "存放结果的目标节点。",
                "name": "result",
                "type": "{','?: number, ';'?: number}"
            }
        ],
        "extends": "Node",
        "comment": "解析一个对象成员尾部。",
        "parts": [
            {
                "optional": true,
                "name": ",Token",
                "comment": "获取当前对象成员尾部的,Token 的位置(可能不存在)。",
                "equals": "@readToken(',')",
                "type": "number",
                "tokens": [
                    ","
                ]
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前对象成员尾部的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "if (this.lexer.peek().type === ';') {",
            "\tresult.semicolonToken = @readToken(';');",
            "} else if (this.lexer.peek().type === ',') {",
            "\tresult.commaToken = @readToken(',');",
            "} else if (@sameLine) {",
            "\tthis.error({ start: this.lexer.current.end, end: this.lexer.current.end }, \"Missing ';' after property.\");",
            "}"
        ],
        "inline": true,
        "classComment": "表示一个对象成员尾部。"
    },
    "ConstructorTypeNode": {
        "region": "类型节点",
        "name": "ConstructorTypeNode",
        "extends": "Node",
        "comment": "解析一个构造函数类型节点(`new () => void`)。",
        "parts": [
            {
                "name": "newToken",
                "comment": "获取当前构造函数类型节点的newToken 的位置。",
                "equals": "@readToken('new')",
                "type": "number",
                "tokens": [
                    "new"
                ]
            },
            {
                "optional": true,
                "comment": "获取当前构造函数类型节点的(可能不存在)。",
                "equals": "@DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName)",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "name": "=>Token",
                "comment": "获取当前构造函数类型节点的=>Token 的位置。",
                "equals": "@readToken('=>')",
                "type": "number",
                "tokens": [
                    "=>"
                ]
            },
            {
                "name": "return",
                "comment": "获取当前构造函数类型节点的undefined。",
                "equals": "@TypeNode()",
                "type": "TypeNode"
            }
        ],
        "codes": [
            "Parameters "
        ],
        "classComment": "表示一个构造函数类型节点(`new () => void`)。"
    },
    "TypeQueryNode": {
        "region": "类型节点",
        "name": "TypeQueryNode",
        "extends": "TypeNode",
        "comment": "解析一个类型查询节点(`typeof x`)。",
        "parts": [
            {
                "name": "typeofToken",
                "comment": "获取当前类型查询节点的typeofToken 的位置。",
                "equals": "@readToken('typeof')",
                "type": "number",
                "tokens": [
                    "typeof"
                ]
            },
            {
                "name": "operand",
                "comment": "获取当前类型查询节点的(可能不存在)。",
                "args": "Precedence.postfix",
                "equals": "@Expression(Precedence.postfix)",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @TypeQueryNode();",
            "result.typeofToken = @readToken('typeof');",
            "result.operand = @Expression(Precedence.postfix);",
            "return result;"
        ],
        "classComment": "表示一个类型查询节点(`typeof x`)。"
    },
    "LiteralTypeNode": {
        "region": "类型节点",
        "name": "LiteralTypeNode",
        "extends": "Expression",
        "comment": "解析一个字面量类型节点(`\"abc\"`、`true`)。",
        "parts": [
            {
                "name": "value",
                "comment": "获取当前字面量类型节点的值。",
                "args": "Precedence.primary",
                "equals": "@Expression(Precedence.primary)",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @LiteralTypeNode();",
            "result.value = @Expression(Precedence.primary);",
            "return result;"
        ],
        "classComment": "表示一个字面量类型节点(`\"abc\"`、`true`)。"
    },
    "QualifiedNameTypeNode": {
        "region": "类型节点",
        "name": "QualifiedNameTypeNode",
        "params": [
            {
                "comment": "undefined。",
                "name": "target",
                "type": "TypeNode"
            }
        ],
        "extends": "Node",
        "comment": "解析一个限定名称类型节点(`\"abc\"`、`true`)。",
        "parts": [
            {
                "name": "target",
                "comment": "获取当前限定名称类型节点的目标部分。",
                "equals": "target",
                "type": "TypeNode"
            },
            {
                "name": ".Token",
                "comment": "获取当前限定名称类型节点的.Token 的位置。",
                "equals": "@readToken('.')",
                "type": "number",
                "tokens": [
                    "."
                ]
            },
            {
                "name": "argument",
                "comment": "获取当前限定名称类型节点的参数部分。",
                "args": "true",
                "equals": "@MemberCallArgument()",
                "type": "Identifier"
            }
        ],
        "codes": [
            "const result = new @QualifiedNameTypeNode();",
            "result.target = target;",
            "result..Token = @readToken('.');",
            "result.argument = @MemberCallArgument();",
            "return result;"
        ],
        "classComment": "表示一个限定名称类型节点(`\"abc\"`、`true`)。"
    },
    "ArrayTypeNode": {
        "region": "类型节点",
        "name": "ArrayTypeNode",
        "params": [
            {
                "comment": "undefined。",
                "name": "target",
                "type": "TypeNode"
            }
        ],
        "extends": "Node",
        "comment": "解析一个数组类型节点(`T[]`)。",
        "parts": [
            {
                "name": "target",
                "comment": "获取当前数组类型节点的目标部分。",
                "equals": "target",
                "type": "TypeNode"
            },
            {
                "name": "[Token",
                "comment": "获取当前数组类型节点的[Token 的位置。",
                "equals": "@readToken('[')",
                "type": "number",
                "tokens": [
                    "["
                ]
            },
            {
                "name": "]Token",
                "comment": "获取当前数组类型节点的]Token 的位置。",
                "equals": "@readToken(']')",
                "type": "number",
                "tokens": [
                    "]"
                ]
            }
        ],
        "codes": [
            "const result = new @ArrayTypeNode();",
            "result.target = target;",
            "result.[Token = @readToken('[');",
            "result.]Token = @readToken(']');",
            "return result;"
        ],
        "classComment": "表示一个数组类型节点(`T[]`)。"
    },
    "BinaryTypeNode": {
        "region": "类型节点",
        "name": "BinaryTypeNode",
        "params": [
            {
                "comment": "undefined。",
                "name": "left",
                "type": "TypeNode"
            }
        ],
        "extends": "Node",
        "comment": "解析一个双目表达式(x + y、x = y、...)。",
        "parts": [
            {
                "name": "left",
                "comment": "获取当前双目表达式的左值部分。",
                "equals": "left",
                "type": "TypeNode"
            },
            {
                "name": "operator",
                "comment": "获取当前双目表达式的运算类型。合法的值有：`&`、`|`、`is`。",
                "equals": "@read",
                "type": "number",
                "tokens": [
                    "&",
                    "|",
                    "is"
                ]
            },
            {
                "name": "right",
                "comment": "获取当前双目表达式的右值部分。",
                "args": "getPrecedence(result.operator",
                "equals": "@TypeNode + 1)(getPrecedence(result.operator)",
                "type": "TypeNode + 1)"
            }
        ],
        "codes": [
            "const result = new @BinaryTypeNode();",
            "result.left = left;",
            "result.operator = @read;",
            "result.right = @TypeNode + 1)(getPrecedence(result.operator);",
            "return result;"
        ],
        "classComment": "表示一个双目表达式(x + y、x = y、...)。"
    },
    "Expression": {
        "region": "表达式",
        "name": "Expression",
        "params": [
            {
                "comment": "允许解析的最低操作符优先级。",
                "name": "precedence",
                "equal": "Precedence.any"
            },
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "equal": "true",
                "type": "boolean"
            }
        ],
        "extends": "Node",
        "comment": "解析一个表达式。",
        "codes": [
            "let result: @Expression;",
            "switch (this.lexer.peek().type) {",
            "\tcase 'identifier':",
            "\t\tresult = @ArrowFunctionOrGenericExpressionOrIdentifier(allowIn);",
            "\t\tbreak;",
            "\tcase 'this':",
            "\tcase 'null':",
            "\tcase 'true':",
            "\tcase 'false':",
            "\tcase 'super':",
            "\t\tresult = @SimpleLiteral();",
            "\t\tbreak;",
            "\tcase '(':",
            "\t\tresult = @ArrowFunctionOrParenthesizedExpression(allowIn);",
            "\t\tbreak;",
            "\tcase 'numericLiteral':",
            "\t\tresult = @NumericLiteral();",
            "\t\tbreak;",
            "\tcase 'stringLiteral':",
            "\tcase 'noSubstitutionTemplateLiteral':",
            "\t\tresult = @StringLiteral();",
            "\t\tbreak;",
            "\tcase '[':",
            "\t\tresult = @ArrayLiteral();",
            "\t\tbreak;",
            "\tcase '{':",
            "\t\tresult = @ObjectLiteral();",
            "\t\tbreak;",
            "\tcase 'function':",
            "\t\tresult = @FunctionExpression();",
            "\t\tbreak;",
            "\tcase 'new':",
            "\t\tresult = @NewTargetOrNewExpression();",
            "\t\tbreak;",
            "\tcase '/':",
            "\tcase '/=':\t",
            "\t\tresult = @RegularExpressionLiteral();",
            "\t\tbreak;",
            "\tcase 'templateHead':",
            "\t\tresult = @TemplateLiteral();",
            "\t\tbreak;",
            "\tcase '<':",
            "\t\tresult = @ArrowFunctionOrTypeAssertionExpression(allowIn);",
            "\t\tbreak;",
            "\tcase 'yield':",
            "\t\tresult = @YieldExpression(allowIn);",
            "\t\tbreak;",
            "\tcase 'await':",
            "\t\tresult = @AwaitExpressionOrIdentifier(allowIn);",
            "\t\tbreak;",
            "\tcase 'class':",
            "\t\tresult = @ClassExpression();",
            "\t\tbreak;",
            "\tcase 'async':",
            "\t\tresult = @AsyncFunctionExpressionOrIdentifier(allowIn);",
            "\t\tbreak;",
            "\tcase '=>':",
            "\t\tresult = @ArrowFunctionExpression(undefined, undefined, undefined, allowIn);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (isUnaryOperator(this.lexer.peek().type)) {",
            "\t\t\tresult = @UnaryExpression();",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (isIdentifierName(this.lexer.peek().type)) {",
            "\t\t\tresult = @ArrowFunctionOrGenericExpressionOrIdentifier(allowIn);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t@error(@lexer.peek(), @isKeyword(this.lexer.peek().type) ? \"Expression expected; '{0}' is a keyword.\" : \"Expression expected; Unexpected token '{0}'.\", getTokenName(this.lexer.peek().type));",
            "\t\treturn @ErrorIdentifier(isStatementStart(this.lexer.peek().type) ? @lexer.current.end : @read);",
            "}",
            "while (getPrecedence(this.lexer.peek().type) >= precedence) {",
            "\tswitch (this.lexer.peek().type) {",
            "\t\tcase '.':",
            "\t\t\tresult = @MemberCallExpression(result);",
            "\t\t\tcontinue;",
            "\t\t//+ case '=':",
            "\t\t//+ \tbreak;",
            "\t\tcase '(':",
            "\t\t\tresult = @FunctionCallExpression(result);",
            "\t\t\tcontinue;",
            "\t\tcase '[':",
            "\t\t\tresult = @IndexCallExpression(result);",
            "\t\t\tcontinue;",
            "\t\tcase '?':",
            "\t\t\tresult = @ConditionalExpression(result, allowIn);",
            "\t\t\tcontinue;",
            "\t\tcase '++':",
            "\t\tcase '--':",
            "\t\t\tif (!@sameLine) {",
            "\t\t\t\treturn result;",
            "\t\t\t}",
            "\t\t\tresult = @PostfixExpression(result);",
            "\t\t\tcontinue;",
            "\t\tcase 'noSubstitutionTemplateLiteral':",
            "\t\t\tresult = @TemplateCallExpression(parsed, @StringLiteral());",
            "\t\t\tcontinue;",
            "\t\tcase 'templateHead':",
            "\t\t\tresult = @TemplateCallExpression(parsed, @TemplateLiteral());",
            "\t\t\tcontinue;",
            "\t\tcase '>':",
            "\t\t\tconst savedToken = @lexer.current;",
            "\t\t\t@lexer.readAsGreaterThanTokens();",
            "\t\t\t@lexer.current = savedToken;",
            "\t\t\tbreak;",
            "\t\tcase 'in':",
            "\t\t\tif (allowIn === false) {",
            "\t\t\t\treturn result;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t}",
            "\tresult = @BinaryExpression(result, allowIn);",
            "}",
            "return result;"
        ]
    },
    "ArrowFunctionOrGenericExpressionOrIdentifier": {
        "region": "表达式",
        "name": "ArrowFunctionOrGenericExpressionOrIdentifier",
        "params": [
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "type": "boolean"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个箭头函数(`x => y`)或泛型表达式(`x<T>`)或标识符(`x`)。",
        "codes": [
            "let result = @Identifier();",
            "switch (this.lexer.peek().type) {",
            "\tcase '=>':",
            "\t\tresult = @ArrowFunctionExpression(undefined, undefined, result, allowIn);",
            "\t\tbreak;",
            "\tcase '<':",
            "\t\tif (@sameLine) {",
            "\t\t\tconst savedState = @stashSave();",
            "\t\t\tconst typeArguments = @TypeArguments();",
            "\t\t\tif (@current === '>' && (isBinaryOperator(this.lexer.peek().type) || !isUnaryOperator(this.lexer.peek().type))) {",
            "\t\t\t\t@stashClear(savedState);",
            "\t\t\t\tresult = @GenericExpression(result, typeArguments);",
            "\t\t\t} else {",
            "\t\t\t\t@stashRestore(savedState);",
            "\t\t\t}",
            "\t\t}",
            "\t\tbreak;",
            "}",
            "return result;"
        ]
    },
    "GenericExpression": {
        "region": "表达式",
        "name": "GenericExpression",
        "params": [
            {
                "comment": "undefined。",
                "name": "target",
                "type": "Identifier"
            },
            {
                "comment": "undefined。",
                "name": "typeArguments",
                "type": "TypeArguments"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个泛型表达式(`x<number>`)。",
        "parts": [
            {
                "name": "target",
                "comment": "获取当前泛型表达式的目标部分。",
                "equals": "target",
                "type": "Identifier"
            },
            {
                "name": "typeArguments",
                "comment": "获取当前泛型表达式的类型参数部分。",
                "equals": "typeArguments",
                "type": "@NodeList<@TypeArgument>"
            }
        ],
        "codes": [
            "const result = new @GenericExpression();",
            "result.target = target;",
            "result.typeArguments = typeArguments;",
            "return result;"
        ],
        "classComment": "表示一个泛型表达式(`x<number>`)。"
    },
    "Identifier": {
        "region": "表达式",
        "name": "Identifier",
        "params": [
            {
                "comment": "是否允许解析关键字。",
                "name": "allowKeyword",
                "equal": "false"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个标识符(`x`)。",
        "parts": [
            {
                "name": "value",
                "comment": "获取当前标识符的值部分。",
                "equals": "@readToken('identifier')",
                "type": "number",
                "tokens": [
                    "identifier"
                ]
            }
        ],
        "codes": [
            "if (isIdentifierName(this.lexer.peek().type) || (allowKeyword && isKeyword(this.lexer.peek().type))) {",
            "\tconst result = new @Identifier();",
            "\tresult.start = @read;",
            "\tresult.value = @lexer.current.value;",
            "\tresult.end = @lexer.current.end;",
            "\treturn result;",
            "}",
            "@error(@lexer.peek(), isKeyword(this.lexer.peek().type) ? \"Identifier expected; Keyword '{0}' cannot be used as an identifier.\" : \"Identifier expected; Unexpected token '{0}'.\", getTokenName(this.lexer.peek().type));",
            "return @ErrorIdentifier();"
        ],
        "classComment": "表示一个标识符(`x`)。"
    },
    "ErrorIdentifier": {
        "region": "表达式",
        "name": "ErrorIdentifier",
        "params": [
            {
                "comment": "标记的开始位置。",
                "name": "start",
                "equal": "@lexer.current.end"
            }
        ],
        "extends": "Node",
        "comment": "解析一个错误的标识符占位符。",
        "codes": [
            "const result = new @ErrorIdentifier();",
            "result.start = start;",
            "result.end = @lexer.current.end;",
            "return result;"
        ]
    },
    "SimpleLiteral": {
        "region": "表达式",
        "name": "SimpleLiteral",
        "extends": "Expression",
        "comment": "解析一个简单字面量(`null`、`true`、`false`、`this`、`super`)。",
        "parts": [
            {
                "name": "type",
                "comment": "获取当前简单字面量的类型。合法的值有：`this`、`null`、`true`、`false`、`super`。",
                "equals": "@read",
                "type": "number",
                "tokens": [
                    "this",
                    "null",
                    "true",
                    "false",
                    "super"
                ]
            }
        ],
        "codes": [
            "const result = new @SimpleLiteral();",
            "result.type = @read;",
            "return result;"
        ],
        "classComment": "表示一个简单字面量(`null`、`true`、`false`、`this`、`super`)。"
    },
    "ArrowFunctionOrParenthesizedExpression": {
        "region": "表达式",
        "name": "ArrowFunctionOrParenthesizedExpression",
        "params": [
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "type": "boolean"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个箭头(`()=>...`)或括号表达式(`(x)`)。",
        "codes": [
            "const savedState = @stashSave();",
            "const parameters = @Parameters();",
            "if (@sameLine && (this.lexer.peek().type === '=>' || this.lexer.peek().type === ':' || this.lexer.peek().type === '{')) {",
            "\t@stashClear(savedState);",
            "\treturn @ArrowFunctionExpression(undefined, undefined, parameters, allowIn);",
            "}",
            "@stashRestore(savedState);",
            "return @ParenthesizedExpression();"
        ]
    },
    "ArrowFunctionExpression": {
        "region": "表达式",
        "name": "ArrowFunctionExpression",
        "params": [
            {
                "comment": "undefined。",
                "name": "modifiers",
                "type": "Modifiers"
            },
            {
                "comment": "undefined。",
                "name": "typeParameters",
                "type": "TypeParameters"
            },
            {
                "comment": "undefined。",
                "name": "parameters",
                "type": "NodeList<ParameterDeclaration> | Identifier"
            },
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "type": "boolean"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个箭头函数表达式(`x => {...}`、`(x, y) => {...}`)。。",
        "parts": [
            {
                "optional": true,
                "name": "modifiers",
                "comment": "获取当前箭头函数表达式。的(可能不存在)。",
                "equals": "modifiers",
                "type": "Modifiers"
            },
            {
                "optional": true,
                "name": "typeParameters",
                "comment": "获取当前箭头函数表达式。的(可能不存在)。",
                "equals": "typeParameters",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "optional": true,
                "name": "parameters",
                "comment": "获取当前箭头函数表达式。的参数部分(可能不存在)。",
                "equals": "parameters",
                "type": "NodeList<ParameterDeclaration> | Identifier"
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前箭头函数表达式。的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            },
            {
                "name": "body",
                "comment": "获取当前箭头函数表达式。的主体部分。",
                "equals": "@peek === '{' ? @BlockStatement() : @Expression(Precedence.assignment, allowIn)",
                "type": "BlockStatement | Expression"
            }
        ],
        "codes": [
            "=> "
        ],
        "classComment": "表示一个箭头函数表达式(`x => {...}`、`(x, y) => {...}`)。。"
    },
    "ParenthesizedExpression": {
        "region": "表达式",
        "name": "ParenthesizedExpression",
        "extends": "Expression",
        "comment": "解析一个括号表达式(`(x)`)。",
        "parts": [
            {
                "name": "(Token",
                "comment": "获取当前括号表达式的(Token 的位置。",
                "equals": "@readToken('(')",
                "type": "number",
                "tokens": [
                    "("
                ]
            },
            {
                "name": "body",
                "comment": "获取当前括号表达式的主体部分。",
                "equals": "@Expression()",
                "type": "Expression"
            },
            {
                "name": ")Token",
                "comment": "获取当前括号表达式的)Token 的位置。",
                "equals": "@readToken(')')",
                "type": "number",
                "tokens": [
                    ")"
                ]
            }
        ],
        "codes": [
            "const result = new @ParenthesizedExpression();",
            "result.(Token = @readToken('(');",
            "result.body = @Expression();",
            "result.)Token = @readToken(')');",
            "return result;"
        ],
        "classComment": "表示一个括号表达式(`(x)`)。"
    },
    "NumericLiteral": {
        "region": "表达式",
        "name": "NumericLiteral",
        "extends": "Expression",
        "comment": "解析一个数字字面量(`1`)。",
        "parts": [
            {
                "name": "value",
                "comment": "获取当前数字字面量的value 的位置。",
                "equals": "@readToken('numericLiteral')",
                "type": "number",
                "tokens": [
                    "numericLiteral"
                ]
            }
        ],
        "codes": [
            "const result = new @NumericLiteral();",
            "result.value = @readToken('numericLiteral');",
            "return result;"
        ],
        "classComment": "表示一个数字字面量(`1`)。"
    },
    "StringLiteral": {
        "region": "表达式",
        "name": "StringLiteral",
        "extends": "Expression",
        "comment": "解析一个字符串字面量(`'abc'`、`\"abc\"`、`\\`abc\\``)。",
        "parts": [
            {
                "name": "value",
                "comment": "获取当前字符串字面量的value 的位置。",
                "equals": "@readToken('stringLiteral')",
                "type": "number",
                "tokens": [
                    "stringLiteral"
                ]
            }
        ],
        "codes": [
            "const result = new @StringLiteral();",
            "result.value = @readToken('stringLiteral');",
            "return result;"
        ],
        "classComment": "表示一个字符串字面量(`'abc'`、`\"abc\"`、`\\`abc\\``)。"
    },
    "ArrayLiteral": {
        "region": "表达式",
        "name": "ArrayLiteral",
        "extends": "Expression",
        "comment": "解析一个数组字面量(`[x, y]`)。",
        "parts": [
            {
                "name": "elements",
                "comment": "获取当前数组字面量的元素列表。",
                "equals": "@DelimitedList(@ArrayLiteralElement, '[', ']', true, @isExpressionStart)",
                "type": "[ ?ArrayLiteralElement , ...isExpressionStart ]",
                "list": {
                    "element": "ArrayLiteralElement",
                    "open": "[",
                    "close": "]",
                    "continue": "isExpressionStart",
                    "seperator": ",",
                    "optional": true,
                    "type": "@NodeList<@ArrayLiteralElement>",
                    "equals": "@DelimitedList(@ArrayLiteralElement, '[', ']', true, @isExpressionStart)"
                }
            }
        ],
        "codes": [
            "const result = new @ArrayLiteral();",
            "result.elements = @DelimitedList(@ArrayLiteralElement, '[', ']', true, @isExpressionStart);",
            "return result;"
        ],
        "classComment": "表示一个数组字面量(`[x, y]`)。"
    },
    "ArrayLiteralElement": {
        "region": "表达式",
        "name": "ArrayLiteralElement",
        "extends": "Expression",
        "comment": "解析一个数组字面量元素(`x`)。",
        "parts": [
            {
                "optional": true,
                "name": "...Token",
                "comment": "获取当前数组字面量元素的...Token 的位置(可能不存在)。",
                "equals": "@readToken('...')",
                "type": "number",
                "tokens": [
                    "..."
                ]
            },
            {
                "optional": true,
                "name": "value",
                "comment": "获取当前数组字面量元素的(可能不存在)。",
                "args": "Precedence.assignment",
                "equals": "@Expression(Precedence.assignment)",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @ArrayLiteralElement();",
            "if (this.lexer.peek().type !== ',' && this.lexer.peek().type !== ']') {",
            "\tif (this.lexer.peek().type === '...') result.dotDotDotToken = @readToken('...');",
            "\tresult.value = @Expression(Precedence.assignment);",
            "}",
            "return result;"
        ],
        "classComment": "表示一个数组字面量元素(`x`)。"
    },
    "ObjectLiteral": {
        "region": "表达式",
        "name": "ObjectLiteral",
        "extends": "Expression",
        "comment": "解析一个对象字面量(`{x: y}`)。",
        "parts": [
            {
                "name": "elements",
                "comment": "获取当前对象字面量的所有元素。",
                "equals": "@NodeList(@ObjectLiteralElement, '{', '}')",
                "type": "{ ?ObjectLiteralElement ... }",
                "list": {
                    "element": "ObjectLiteralElement",
                    "open": "{",
                    "close": "}",
                    "continue": "",
                    "seperator": "",
                    "optional": true,
                    "type": "@NodeList<@ObjectLiteralElement>",
                    "equals": "@NodeList(@ObjectLiteralElement, '{', '}')"
                }
            }
        ],
        "codes": [
            "const result = new @ObjectLiteral();",
            "result.elements = @NodeList(@ObjectLiteralElement, '{', '}');",
            "return result;"
        ],
        "classComment": "表示一个对象字面量(`{x: y}`)。"
    },
    "ObjectLiteralElement": {
        "region": "表达式",
        "name": "ObjectLiteralElement",
        "extends": "Expression",
        "alias": "ObjectPropertyDeclaration | ObjectMethodDeclaration | ObjectAccessorDeclaration",
        "comment": "解析一个对象字面量元素(`x: y`、`x() {...}`)。",
        "codes": [
            "const modifiers = @Modifiers();",
            "switch (this.lexer.peek().type) {",
            "\t//+ case 'identifier':",
            "\t//+ \tbreak;",
            "\tcase 'get':",
            "\tcase 'set':",
            "\t\tconst savedToken = @lexer.current;",
            "\t\t@lexer.read();",
            "\t\tif (isKeyword(this.lexer.peek().type) || this.lexer.peek().type === '[') {",
            "\t\t\treturn @ObjectAccessorDeclaration(modifiers, savedToken.type === 'get' ? savedToken.start : undefined, savedToken.type === 'set' ? savedToken.start : undefined);",
            "\t\t}",
            "\t\t@lexer.current = savedToken;",
            "\t\tbreak;",
            "\tcase '*':",
            "\t\treturn @ObjectMethodDeclaration(modifiers, @read, @PropertyName());",
            "}",
            "const name = @PropertyName();",
            "switch (this.lexer.peek().type) {",
            "\tcase '(':",
            "\tcase '<':",
            "\t\treturn @ObjectMethodDeclaration(modifiers, undefined, name);",
            "\tdefault:",
            "\t\treturn @ObjectPropertyDeclaration(modifiers, name);",
            "}"
        ]
    },
    "ObjectAccessorDeclaration": {
        "region": "表达式",
        "name": "ObjectAccessorDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Modifiers"
            },
            {
                "comment": "undefined。",
                "name": "getToken",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "setToken",
                "type": "number"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个访问器声明(`get x() {...}`、`set x(value) {...}`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前访问器声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "optional": true,
                "name": "getToken",
                "comment": "获取当前访问器声明的getToken 的位置(可能不存在)。",
                "equals": "getToken",
                "type": "number",
                "tokens": [
                    "get"
                ]
            },
            {
                "optional": true,
                "name": "setToken",
                "comment": "获取当前访问器声明的setToken 的位置(可能不存在)。",
                "equals": "setToken",
                "type": "number",
                "tokens": [
                    "set"
                ]
            },
            {
                "name": "name",
                "comment": "获取当前访问器声明的(可能不存在)。",
                "equals": "@PropertyName()",
                "type": "PropertyName"
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前访问器声明的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            },
            {
                "inlined": true,
                "name": "=>Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "body",
                "type": "BlockStatement | Expression",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": ";Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前访问器声明的(可能不存在)。",
                "equals": "@FunctionBody()",
                "type": "FunctionBody"
            }
        ],
        "codes": [
            "Parameters",
            "ObjectMemberTail"
        ],
        "classComment": "表示一个访问器声明(`get x() {...}`、`set x(value) {...}`)。"
    },
    "ObjectMethodDeclaration": {
        "region": "表达式",
        "name": "ObjectMethodDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Modifiers"
            },
            {
                "comment": "undefined。",
                "name": "*Token",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "name",
                "type": "PropertyName"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个方法声明(`x() {...}`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前方法声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "optional": true,
                "name": "*Token",
                "comment": "获取当前方法声明的*Token 的位置(可能不存在)。",
                "equals": "*Token",
                "type": "number",
                "tokens": [
                    "*"
                ]
            },
            {
                "optional": true,
                "name": "name",
                "comment": "获取当前方法声明的(可能不存在)。",
                "equals": "name",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "comment": "获取当前方法声明的(可能不存在)。",
                "equals": "@DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName)",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前方法声明的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            },
            {
                "inlined": true,
                "name": "=>Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "body",
                "type": "BlockStatement | Expression",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": ";Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前方法声明的(可能不存在)。",
                "equals": "@FunctionBody()",
                "type": "FunctionBody"
            }
        ],
        "codes": [
            "Parameters",
            "ObjectMemberTail"
        ],
        "classComment": "表示一个方法声明(`x() {...}`)。"
    },
    "ObjectPropertyDeclaration": {
        "region": "表达式",
        "name": "ObjectPropertyDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Modifiers"
            },
            {
                "comment": "undefined。",
                "name": "key",
                "type": "PropertyName"
            },
            {
                "comment": "undefined。",
                "name": ":Token",
                "type": "number"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个属性声明(`x: y`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前属性声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "name": "key",
                "comment": "获取当前属性声明的undefined。",
                "equals": "key",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "name": ":Token",
                "comment": "获取当前属性声明的:Token 的位置(可能不存在)。",
                "equals": ":Token",
                "type": "number",
                "tokens": [
                    ":"
                ]
            },
            {
                "optional": true,
                "name": "=Token",
                "comment": "获取当前属性声明的=Token 的位置(可能不存在)。",
                "equals": "@readToken('=')",
                "type": "number",
                "tokens": [
                    "="
                ]
            },
            {
                "optional": true,
                "name": "value",
                "comment": "获取当前属性声明的(可能不存在)。",
                "args": "Precedence.assignment",
                "equals": "@Expression(Precedence.assignment)",
                "type": "Expression"
            }
        ],
        "codes": [
            "ObjectMemberTail",
            "const result = new @ObjectPropertyDeclaration();",
            "@DocComment(result);",
            "result.key = key;",
            "if (this.lexer.peek().type === ':') {",
            "\tresult.colonToken = @readToken(':');",
            "\tresult.value = @Expression(Precedence.assignment);",
            "} else if (this.lexer.peek().type === '=') {",
            "\tresult.equalToken = @readToken('=');",
            "\tresult.value = @Expression(Precedence.assignment);",
            "} else if(key.constructor !== @Identifier && key.constructor !== @MemberCallExpression) {",
            "\t@readToken(':');",
            "}",
            "@ObjectMemberTail(result);",
            "return result;"
        ],
        "classComment": "表示一个属性声明(`x: y`)。"
    },
    "NewTargetOrNewExpression": {
        "region": "表达式",
        "name": "NewTargetOrNewExpression",
        "extends": "Expression",
        "comment": "解析一个new.target(`new.target`) 或 new 表达式(`new x()`)。",
        "codes": [
            "const newToken = @readToken('new');",
            "if (this.lexer.peek().type === '.') {",
            "\treturn @NewTargetExpression(newToken);",
            "}",
            "return @NewExpression(newToken);"
        ]
    },
    "NewTargetExpression": {
        "region": "表达式",
        "name": "NewTargetExpression",
        "params": [
            {
                "comment": "undefined。",
                "name": "newToken",
                "type": "number"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个new.target 表达式(`new.target`)。",
        "parts": [
            {
                "name": "newToken",
                "comment": "获取当前new.target 表达式的newToken 的位置。",
                "equals": "newToken",
                "type": "number",
                "tokens": [
                    "new"
                ]
            },
            {
                "name": ".Token",
                "comment": "获取当前new.target 表达式的.Token 的位置。",
                "equals": "@readToken('.')",
                "type": "number",
                "tokens": [
                    "."
                ]
            }
        ],
        "codes": [
            "target",
            "const result = new @NewTargetExpression();",
            "result.newToken = newToken;",
            "result.dotToken = @readToken('.');",
            "if (this.lexer.peek().type === 'identifier' && @lexer.peek().data === \"target\") {",
            "\tresult.targetToken = @readToken('identifier');",
            "\treturn result;",
            "}",
            "@error(@lexer.peek(), \"'target' expected; Unexpected token '{0}'.\", getTokenName(this.lexer.peek().type));",
            "return @ErrorIdentifier(newToken);"
        ],
        "classComment": "表示一个new.target 表达式(`new.target`)。"
    },
    "NewExpression": {
        "region": "表达式",
        "name": "NewExpression",
        "params": [
            {
                "comment": "undefined。",
                "name": "newToken",
                "type": "number"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个new 表达式(`new x()`、`new x`)。",
        "parts": [
            {
                "name": "newToken",
                "comment": "获取当前new 表达式的newToken 的位置。",
                "equals": "newToken",
                "type": "number",
                "tokens": [
                    "new"
                ]
            },
            {
                "name": "target",
                "comment": "获取当前new 表达式的目标部分。",
                "args": "Precedence.member",
                "equals": "@Expression(Precedence.member)",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": "arguments",
                "comment": "获取当前new 表达式的(可能不存在)。",
                "equals": "@DelimitedList(@Argument, '(', ')', false, @isArgumentStart)",
                "type": "@NodeList<@Argument>"
            }
        ],
        "codes": [
            "const result = new @NewExpression();",
            "result.newToken = newToken;",
            "result.target = @Expression(Precedence.member);",
            "result.arguments = @DelimitedList(@Argument, '(', ')', false, @isArgumentStart);",
            "return result;"
        ],
        "classComment": "表示一个new 表达式(`new x()`、`new x`)。"
    },
    "RegularExpressionLiteral": {
        "region": "表达式",
        "name": "RegularExpressionLiteral",
        "extends": "Expression",
        "comment": "解析一个正则表达式字面量(/abc/)。",
        "parts": [
            {
                "name": "value",
                "comment": "获取当前正则表达式字面量的value 的位置。",
                "equals": "@readToken('stringLiteral')",
                "type": "number",
                "tokens": [
                    "stringLiteral"
                ]
            },
            {
                "optional": true,
                "name": "flags",
                "comment": "获取当前正则表达式字面量的标志部分(可能不存在)。",
                "equals": "@readToken('stringLiteral')",
                "type": "number",
                "tokens": [
                    "stringLiteral"
                ]
            }
        ],
        "codes": [
            "const result = new @RegularExpressionLiteral();",
            "const token = @lexer.readAsRegularExpressionLiteral();",
            "result.start = token.start;",
            "result.value = token.data.pattern;",
            "result.flags = token.data.flags;",
            "result.end = token.end;",
            "return result;"
        ],
        "classComment": "表示一个正则表达式字面量(/abc/)。"
    },
    "TemplateLiteral": {
        "region": "表达式",
        "name": "TemplateLiteral",
        "extends": "Expression",
        "comment": "解析一个模板字面量(`\\`abc\\``)。",
        "parts": [
            {
                "name": "spans",
                "comment": "获取当前模板字面量的组成部分列表。",
                "equals": "@NodeList<TemplateSpan|Expression>()",
                "type": "NodeList<TemplateSpan|Expression>"
            }
        ],
        "codes": [
            "const result = new @TemplateLiteral()();",
            "result.spans = new @NodeList()<@Expression>();",
            "while (true) {",
            "\tresult.spans.push(@TemplateSpan());",
            "\tresult.spans.push(@Expression());",
            "\tif (this.lexer.peek().type !== '}') {",
            "\t\t@readToken('}');",
            "\t\tbreak;",
            "\t}",
            "\tif (@lexer.readAsTemplateMiddleOrTail().type === 'templateTail') {",
            "\t\tresult.spans.push(@TemplateSpan());",
            "\t\tbreak;",
            "\t}",
            "}",
            "return result;"
        ],
        "classComment": "表示一个模板字面量(`\\`abc\\``)。"
    },
    "TemplateSpan": {
        "region": "表达式",
        "name": "TemplateSpan",
        "extends": "Node",
        "comment": "解析一个模板文本区块(`\\`abc${`、`}abc${`、`}abc\\``)。",
        "parts": [
            {
                "name": "value",
                "comment": "获取当前模板文本区块的value 的位置。",
                "equals": "@readToken('stringLiteral')",
                "type": "number",
                "tokens": [
                    "stringLiteral"
                ]
            }
        ],
        "codes": [
            "const result = new @TemplateSpan();",
            "result.value = @readToken('stringLiteral');",
            "return result;"
        ],
        "classComment": "表示一个模板文本区块(`\\`abc${`、`}abc${`、`}abc\\``)。"
    },
    "ArrowFunctionOrTypeAssertionExpression": {
        "region": "表达式",
        "name": "ArrowFunctionOrTypeAssertionExpression",
        "params": [
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "type": "boolean"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个箭头函数(`<T>() => {}`)或类型确认表达式(`<T>fn`)。",
        "codes": [
            "const savedState = @stashSave();",
            "const typeParameters = @TypeParameters();",
            "const parameters = this.lexer.peek().type === '(' ? @Parameters() : isIdentifierName(this.lexer.peek().type) : @Identifier() : undefined;",
            "if (parameters && @sameLine && (this.lexer.peek().type === '=>' || this.lexer.peek().type === ':' || this.lexer.peek().type === '{')) {",
            "\t@stashClear(savedState);",
            "\treturn @ArrowFunctionExpression(undefined, typeParameters, parameters, allowIn);",
            "}",
            "@stashRestore(savedState);",
            "return @TypeAssertionExpression();"
        ]
    },
    "TypeAssertionExpression()": {
        "region": "表达式",
        "name": "TypeAssertionExpression()",
        "extends": "Expression",
        "comment": "解析一个类型确认表达式(<T>xx)。",
        "parts": [
            {
                "name": "<Token",
                "comment": "获取当前类型确认表达式的<Token 的位置。",
                "equals": "@readToken('<')",
                "type": "number",
                "tokens": [
                    "<"
                ]
            },
            {
                "name": "type",
                "comment": "获取当前类型确认表达式的类型。合法的值有：`any`、`number`、`boolean`、`string`、`symbol`、`void`、`never`、`this`、`null`、`undefined`、`char`、`byte`、`int`、`long`、`short`、`uint`、`ulong`、`ushort`、`float`、`double`、`*`、`?`。",
                "equals": "@TypeNode()",
                "type": "TypeNode"
            },
            {
                "name": ">Token",
                "comment": "获取当前类型确认表达式的>Token 的位置。",
                "equals": "@readToken('>')",
                "type": "number",
                "tokens": [
                    ">"
                ]
            },
            {
                "name": "operand",
                "comment": "获取当前类型确认表达式的(可能不存在)。",
                "args": "Precedence.postfix",
                "equals": "@Expression(Precedence.postfix)",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @TypeAssertionExpression()();",
            "result.<Token = @readToken('<');",
            "result.type = @TypeNode();",
            "result.>Token = @readToken('>');",
            "result.operand = @Expression(Precedence.postfix);",
            "return result;"
        ],
        "classComment": "表示一个类型确认表达式(<T>xx)。"
    },
    "YieldExpression": {
        "region": "表达式",
        "name": "YieldExpression",
        "params": [
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "type": "boolean"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个yield 表达式(`yield xx`)。",
        "parts": [
            {
                "name": "yieldToken",
                "comment": "获取当前yield 表达式的yieldToken 的位置。",
                "equals": "@readToken('yield')",
                "type": "number",
                "tokens": [
                    "yield"
                ]
            },
            {
                "optional": true,
                "name": "*Token",
                "comment": "获取当前yield 表达式的*Token 的位置(可能不存在)。",
                "equals": "@readToken('*')",
                "type": "number",
                "tokens": [
                    "*"
                ]
            },
            {
                "optional": true,
                "name": "operand",
                "comment": "获取当前yield 表达式的(可能不存在)。",
                "args": "Precedence.assignment, allowIn",
                "equals": "@Expression(Precedence.assignment, allowIn)",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @YieldExpression();",
            "result.yieldToken = @readToken('yield');",
            "if (@sameLine && this.lexer.peek().type === '*') result.asteriskToken = @readToken('*');",
            "if (@sameLine && isExpressionStart(this.lexer.peek().type)) result.operand = @Expression(Precedence.assignment, allowIn);",
            "return result;"
        ],
        "classComment": "表示一个yield 表达式(`yield xx`)。"
    },
    "AwaitExpressionOrIdentifier": {
        "region": "表达式",
        "name": "AwaitExpressionOrIdentifier",
        "params": [
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "type": "boolean"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个await 表达式(`await xx`)或标识符。",
        "codes": [
            "const savedToken = @lexer.current;",
            "@readToken('await');",
            "if (@sameLine && isExpressionStart(this.lexer.peek().type)) {",
            "\treturn @AwaitExpression(allowIn);",
            "}",
            "@lexer.current = savedToken;",
            "return @Identifier();"
        ]
    },
    "AwaitExpression": {
        "region": "表达式",
        "name": "AwaitExpression",
        "params": [
            {
                "comment": "undefined。",
                "name": "awaitToken",
                "type": "number"
            },
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "type": "boolean"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个await 表达式(`await xx`)。",
        "parts": [
            {
                "name": "awaitToken",
                "comment": "获取当前await 表达式的awaitToken 的位置。",
                "equals": "awaitToken",
                "type": "number",
                "tokens": [
                    "await"
                ]
            },
            {
                "name": "operand",
                "comment": "获取当前await 表达式的(可能不存在)。",
                "args": "Precedence.assignment, allowIn",
                "equals": "@Expression(Precedence.assignment, allowIn)",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @AwaitExpression();",
            "result.awaitToken = awaitToken;",
            "result.operand = @Expression(Precedence.assignment, allowIn);",
            "return result;"
        ],
        "classComment": "表示一个await 表达式(`await xx`)。"
    },
    "AsyncArrowFunctionOrIdentifier": {
        "region": "表达式",
        "name": "AsyncArrowFunctionOrIdentifier",
        "params": [
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "type": "boolean"
            }
        ],
        "extends": "Node",
        "comment": "解析一个异步函数表达式或标识符。",
        "codes": [
            "const savedState = @stashSave();",
            "const modifiers = @Modifiers();",
            "const typeParameters = @sameLine && this.lexer.peek().type === '<' ? @TypeParameters() : undefined;",
            "if (@sameLine && (this.lexer.peek().type === '(' || isIdentifierName(this.lexer.peek().type))) {",
            "\tconst parameters = this.lexer.peek().type === '(' ? @Parameters() : @Identifier();",
            "\tif (@sameLine && (this.lexer.peek().type === '=>' || this.lexer.peek().type === ':' || this.lexer.peek().type === '{')) {",
            "\t\t@stashClear(savedState);",
            "\t\treturn @ArrowFunctionExpression(modifiers, typeParameters, parameters, allowIn);",
            "\t}",
            "}",
            "@stashRestore(savedState);",
            "return @Identifier();"
        ]
    },
    "UnaryExpression": {
        "region": "表达式",
        "name": "UnaryExpression",
        "extends": "Expression",
        "comment": "解析一个一元运算表达式(`+x`、`typeof x`、...)。",
        "parts": [
            {
                "name": "operator",
                "comment": "获取当前一元运算表达式的operator 的位置。合法的值有：`delete`、`void`、`typeof`、`+`、`-`、`~`、`!`、`++`、`--`、`...`。",
                "equals": "@read",
                "type": "number",
                "tokens": [
                    "delete",
                    "void",
                    "typeof",
                    "+",
                    "-",
                    "~",
                    "!",
                    "++",
                    "--",
                    "..."
                ]
            },
            {
                "name": "operand",
                "comment": "获取当前一元运算表达式的(可能不存在)。",
                "args": "Precedence.postfix",
                "equals": "@Expression(Precedence.postfix)",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @UnaryExpression();",
            "result.operator = @read;",
            "result.operand = @Expression(Precedence.postfix);",
            "return result;"
        ],
        "classComment": "表示一个一元运算表达式(`+x`、`typeof x`、...)。"
    },
    "MemberCallExpression": {
        "region": "表达式",
        "name": "MemberCallExpression",
        "params": [
            {
                "comment": "undefined。",
                "name": "target",
                "type": "Expression"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个成员调用表达式(x.y)。",
        "parts": [
            {
                "name": "target",
                "comment": "获取当前成员调用表达式的目标部分。",
                "equals": "target",
                "type": "Expression"
            },
            {
                "name": ".Token",
                "comment": "获取当前成员调用表达式的.Token 的位置。",
                "equals": "@readToken('.')",
                "type": "number",
                "tokens": [
                    "."
                ]
            },
            {
                "name": "argument",
                "comment": "获取当前成员调用表达式的参数部分。",
                "equals": "@MemberCallArgument()",
                "type": "Identifier"
            }
        ],
        "codes": [
            "const result = new @MemberCallExpression();",
            "result.target = target;",
            "result..Token = @readToken('.');",
            "result.argument = @MemberCallArgument();",
            "return result;"
        ],
        "classComment": "表示一个成员调用表达式(x.y)。"
    },
    "MemberCallArgument": {
        "region": "表达式",
        "name": "MemberCallArgument",
        "extends": "Node",
        "comment": "解析一个成员调用参数。",
        "codes": [
            "if (!@sameLine && isStatementStart(this.lexer.peek().type)) {",
            "\tconst savedState = @stashSave();",
            "\t@Statement();",
            "\tconst isStatementStart = !savedState.errors.length;",
            "\t@stashRestore(savedState);",
            "\tif (isStatementStart) {",
            "\t\treturn @ErrorIdentifier();",
            "\t}",
            "}",
            "return @Identifier(true);"
        ]
    },
    "FunctionCallExpression": {
        "region": "表达式",
        "name": "FunctionCallExpression",
        "params": [
            {
                "comment": "undefined。",
                "name": "target",
                "type": "Expression"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个函数调用表达式(`x()`)。",
        "parts": [
            {
                "name": "target",
                "comment": "获取当前函数调用表达式的目标部分。",
                "equals": "target",
                "type": "Expression"
            },
            {
                "name": "arguments",
                "comment": "获取当前函数调用表达式的(可能不存在)。",
                "equals": "@DelimitedList(@Argument, '(', ')', false, @isArgumentStart)",
                "type": "@NodeList<@Argument>"
            }
        ],
        "codes": [
            "const result = new @FunctionCallExpression();",
            "result.target = target;",
            "result.arguments = @DelimitedList(@Argument, '(', ')', false, @isArgumentStart);",
            "return result;"
        ],
        "classComment": "表示一个函数调用表达式(`x()`)。"
    },
    "Arguments": {
        "region": "表达式",
        "name": "Arguments",
        "extends": "Node",
        "list": {
            "element": "Argument",
            "open": "(",
            "close": ")",
            "continue": "isArgumentStart",
            "seperator": ",",
            "optional": false,
            "type": "@NodeList<@Argument>",
            "equals": "@DelimitedList(@Argument, '(', ')', false, @isArgumentStart)"
        },
        "comment": "解析一个函数调用参数列表。"
    },
    "Argument": {
        "region": "表达式",
        "name": "Argument",
        "extends": "Node",
        "comment": "解析一个函数调用参数(`x`)。",
        "parts": [
            {
                "optional": true,
                "name": "...Token",
                "comment": "获取当前函数调用参数的...Token 的位置(可能不存在)。",
                "equals": "@readToken('...')",
                "type": "number",
                "tokens": [
                    "..."
                ]
            },
            {
                "name": "value",
                "comment": "获取当前函数调用参数的值。",
                "args": "Precedence.assignment",
                "equals": "@Expression(Precedence.assignment)",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @Argument();",
            "if (@peek === '...') result....Token = @readToken('...');",
            "result.value = @Expression(Precedence.assignment);",
            "return result;"
        ],
        "classComment": "表示一个函数调用参数(`x`)。"
    },
    "IndexCallExpression": {
        "region": "表达式",
        "name": "IndexCallExpression",
        "params": [
            {
                "comment": "undefined。",
                "name": "target",
                "type": "Expression"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个索引调用表达式(`x[y]`)。",
        "parts": [
            {
                "name": "target",
                "comment": "获取当前索引调用表达式的目标部分。",
                "equals": "target",
                "type": "Expression"
            },
            {
                "name": "[Token",
                "comment": "获取当前索引调用表达式的[Token 的位置。",
                "equals": "@readToken('[')",
                "type": "number",
                "tokens": [
                    "["
                ]
            },
            {
                "name": "argument",
                "comment": "获取当前索引调用表达式的参数部分。",
                "equals": "@Expression()",
                "type": "Expression"
            },
            {
                "name": "]Token",
                "comment": "获取当前索引调用表达式的]Token 的位置。",
                "equals": "@readToken(']')",
                "type": "number",
                "tokens": [
                    "]"
                ]
            }
        ],
        "codes": [
            "const result = new @IndexCallExpression();",
            "result.target = target;",
            "result.[Token = @readToken('[');",
            "result.argument = @Expression();",
            "result.]Token = @readToken(']');",
            "return result;"
        ],
        "classComment": "表示一个索引调用表达式(`x[y]`)。"
    },
    "ConditionalExpression": {
        "region": "表达式",
        "name": "ConditionalExpression",
        "params": [
            {
                "comment": "undefined。",
                "name": "condition",
                "type": "Expression"
            },
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "type": "boolean"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个条件表达式(`x ? y : z`)。",
        "parts": [
            {
                "name": "condition",
                "comment": "获取当前条件表达式的(可能不存在)。",
                "equals": "condition",
                "type": "Expression"
            },
            {
                "optional": true,
                "comment": "获取当前条件表达式的(可能不存在)。",
                "equals": "@undefined()"
            },
            {
                "name": "then",
                "comment": "获取当前条件表达式的则部分。",
                "args": "Precedence.assignment",
                "equals": "@Expression(Precedence.assignment)",
                "type": "Expression"
            },
            {
                "name": "else",
                "comment": "获取当前条件表达式的否则部分。",
                "args": "Precedence.assignment, allowIn",
                "equals": "@Expression(Precedence.assignment, allowIn)",
                "type": "Expression"
            }
        ],
        "codes": [
            ": "
        ],
        "classComment": "表示一个条件表达式(`x ? y : z`)。"
    },
    "PostfixExpression": {
        "region": "表达式",
        "name": "PostfixExpression",
        "params": [
            {
                "comment": "undefined。",
                "name": "operand",
                "type": "Expression"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个后缀表达式(`x++`、`x--`)。",
        "parts": [
            {
                "name": "operand",
                "comment": "获取当前后缀表达式的操作数。",
                "args": "Precedence.leftHandSide",
                "equals": "operand",
                "type": "Expression"
            },
            {
                "name": "operator",
                "comment": "获取当前后缀表达式的operator 的位置。合法的值有：`++`、`--`。",
                "equals": "@read",
                "type": "number",
                "tokens": [
                    "++",
                    "--"
                ]
            }
        ],
        "codes": [
            "const result = new @PostfixExpression();",
            "result.operand = operand;",
            "result.operator = @read;",
            "return result;"
        ],
        "classComment": "表示一个后缀表达式(`x++`、`x--`)。"
    },
    "TemplateCallExpression": {
        "region": "表达式",
        "name": "TemplateCallExpression",
        "params": [
            {
                "comment": "undefined。",
                "name": "target",
                "type": "Expression"
            },
            {
                "comment": "undefined。",
                "name": "argument",
                "type": "TemplateLiteral | StringLiteral"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个模板调用表达式(`x\\`abc\\``)。",
        "parts": [
            {
                "name": "target",
                "comment": "获取当前模板调用表达式的目标部分。",
                "equals": "target",
                "type": "Expression"
            },
            {
                "name": "argument",
                "comment": "获取当前模板调用表达式的参数部分。",
                "equals": "argument",
                "type": "TemplateLiteral | StringLiteral"
            }
        ],
        "codes": [
            "const result = new @TemplateCallExpression();",
            "result.target = target;",
            "result.argument = argument;",
            "return result;"
        ],
        "classComment": "表示一个模板调用表达式(`x\\`abc\\``)。"
    },
    "BinaryExpression": {
        "region": "表达式",
        "name": "BinaryExpression",
        "params": [
            {
                "comment": "undefined。",
                "name": "left",
                "type": "Expression"
            },
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "type": "boolean"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个双目表达式(x + y、x = y、...)。",
        "parts": [
            {
                "name": "left",
                "comment": "获取当前双目表达式的左值部分。",
                "equals": "left",
                "type": "Expression"
            },
            {
                "name": "operator",
                "comment": "获取当前双目表达式的运算类型。合法的值有：`,`、`*=`、`/=`、`%=`、`+=`、`‐=`、`<<=`、`>>=`、`>>>=`、`&=`、`^=`、`|=`、`**=`、`=`、`||`、`&&`、`|`、`^`、`&`、`==`、`!=`、`===`、`!==`、`<`、`>`、`<=`、`>=`、`instanceof`、`in`、`<<`、`>>`、`>>>`、`+`、`-`、`*`、`/`、`%`、`**`。",
                "equals": "@read",
                "type": "number",
                "tokens": [
                    ",",
                    "*=",
                    "/=",
                    "%=",
                    "+=",
                    "‐=",
                    "<<=",
                    ">>=",
                    ">>>=",
                    "&=",
                    "^=",
                    "|=",
                    "**=",
                    "=",
                    "||",
                    "&&",
                    "|",
                    "^",
                    "&",
                    "==",
                    "!=",
                    "===",
                    "!==",
                    "<",
                    ">",
                    "<=",
                    ">=",
                    "instanceof",
                    "in",
                    "<<",
                    ">>",
                    ">>>",
                    "+",
                    "-",
                    "*",
                    "/",
                    "%",
                    "**"
                ]
            },
            {
                "name": "right",
                "comment": "获取当前双目表达式的右值部分。",
                "equals": "@Expression()",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @BinaryExpression();",
            "result.left = left;",
            "result.operator = @read;",
            "result.right = Expression(getPrecedence(result.operator) + (isRightHandOperator(result.operator) ? 0 : 1), allowIn);",
            "return result;"
        ],
        "classComment": "表示一个双目表达式(x + y、x = y、...)。"
    },
    "Statement": {
        "region": "语句",
        "name": "Statement",
        "extends": "Node",
        "comment": "解析一个语句。",
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\tcase 'identifier': ",
            "\t\treturn @LabeledOrExpressionStatement(@Identifier());",
            "\tcase '{':",
            "\t\treturn @BlockStatement();",
            "\tcase 'var':",
            "\tcase 'const':",
            "\t\treturn @VariableStatement();",
            "\tcase 'let': ",
            "\t\treturn @VariableOrExpressionStatement(true);",
            "\tcase 'function':",
            "\t\treturn @FunctionDeclaration();",
            "\tcase 'if':",
            "\t\treturn @IfStatement();",
            "\tcase 'for'",
            "\t\treturn @ForOrForInOrForOfOrForToStatement();",
            "\tcase 'while'",
            "\t\treturn @WhileStatement();",
            "\tcase 'switch'",
            "\t\treturn @SwitchStatement();"
        ]
    },
    "LabeledOrExpressionStatement": {
        "region": "语句",
        "name": "LabeledOrExpressionStatement",
        "params": [
            {
                "comment": "undefined。",
                "name": "parsed",
                "type": "@Expression"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个表达式或标签语句。",
        "codes": [
            "if (parsed.constructor === @Identifier && this.lexer.peek().type === ':') {",
            "\treturn @LabelledStatement(<@Identifier>parsed);",
            "}",
            "return @ExpressionStatement(parsed);"
        ]
    },
    "LabelledStatement": {
        "region": "语句",
        "name": "LabelledStatement",
        "params": [
            {
                "comment": "undefined。",
                "name": "label",
                "type": "Identifier"
            }
        ],
        "doc": true,
        "extends": "Statement",
        "comment": "解析一个标签语句(`x: ...`)。",
        "parts": [
            {
                "name": "label",
                "comment": "获取当前标签语句的(可能不存在)。",
                "equals": "label",
                "type": "Identifier"
            },
            {
                "name": ":Token",
                "comment": "获取当前标签语句的:Token 的位置。",
                "equals": "@readToken(':')",
                "type": "number",
                "tokens": [
                    ":"
                ]
            },
            {
                "name": "statement",
                "comment": "获取当前标签语句的主体部分。",
                "equals": "@Statement()",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @LabelledStatement();",
            "result.label = label;",
            "result.:Token = @readToken(':');",
            "result.statement = @Statement();",
            "return result;"
        ],
        "classComment": "表示一个标签语句(`x: ...`)。"
    },
    "ExpressionStatement": {
        "region": "语句",
        "name": "ExpressionStatement",
        "params": [
            {
                "comment": "表达式部分。",
                "name": "expression",
                "question": true,
                "type": "@Expression"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个表达式语句(`x();`)。",
        "parts": [
            {
                "name": "expression",
                "comment": "获取当前表达式语句的表达式部分。",
                "equals": "@Expression()",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @ExpressionStatement();",
            "result.expression = expression || @Expression();",
            "return result;"
        ],
        "classComment": "表示一个表达式语句(`x();`)。"
    },
    "BlockStatement": {
        "region": "语句",
        "name": "BlockStatement",
        "extends": "Statement",
        "comment": "解析一个语句块(`{...}`)。",
        "parts": [
            {
                "name": "statements",
                "comment": "获取当前语句块的undefined。",
                "equals": "@NodeList(@Statement, '{', '}')",
                "type": "{ ?Statement ... }",
                "list": {
                    "element": "Statement",
                    "open": "{",
                    "close": "}",
                    "continue": "",
                    "seperator": "",
                    "optional": true,
                    "type": "@NodeList<@Statement>",
                    "equals": "@NodeList(@Statement, '{', '}')"
                }
            }
        ],
        "codes": [
            "const result = new @BlockStatement();",
            "result.statements = @NodeList(@Statement, '{', '}');",
            "return result;"
        ],
        "classComment": "表示一个语句块(`{...}`)。"
    },
    "VariableStatement:": {
        "region": "语句",
        "name": "VariableStatement:",
        "params": [
            {
                "comment": "undefined。",
                "type": "Modifiers"
            },
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "type": "boolean"
            }
        ],
        "extends": "Statement",
        "comment": "解析一个变量声明语句(`var x`、`let x`、`const x`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前变量声明语句的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "name": "type",
                "comment": "获取当前变量声明语句的type 的位置。合法的值有：`var`、`let`、`const`。",
                "equals": "@read",
                "type": "number",
                "tokens": [
                    "var",
                    "let",
                    "const"
                ]
            },
            {
                "name": "variables",
                "comment": "获取当前变量声明语句的(可能不存在)。",
                "equals": "@DelimitedList(allowIn === false ? @VariableDeclarationWithoutIn : @VariableDeclaration, undefined, undefined, isBindingNameStart)",
                "type": "VariableDeclaration , ...isBindingNameStart",
                "list": {
                    "element": "VariableDeclaration",
                    "open": "",
                    "close": "",
                    "continue": "isBindingNameStart",
                    "seperator": ",",
                    "optional": false,
                    "type": "@NodeList<@VariableDeclaration>",
                    "equals": "@DelimitedList(@VariableDeclaration, undefined, undefined, false, @isBindingNameStart)"
                }
            }
        ],
        "codes": [
            "const result = new @VariableStatement:();",
            "result. = @Modifiers();",
            "result.type = @read;",
            "result.variables = @DelimitedList(allowIn === false ? @VariableDeclarationWithoutIn : @VariableDeclaration, undefined, undefined, isBindingNameStart);",
            "return result;"
        ],
        "classComment": "表示一个变量声明语句(`var x`、`let x`、`const x`)。"
    },
    "VariableDeclarationWithoutIn()": {
        "region": "语句",
        "name": "VariableDeclarationWithoutIn()",
        "extends": "Declaration",
        "comment": "解析一个变量声明（不带 in）。",
        "codes": [
            "return @VariableDeclaration(false);"
        ]
    },
    "VariableDeclaration": {
        "region": "语句",
        "name": "VariableDeclaration",
        "params": [
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "type": "boolean"
            }
        ],
        "extends": "Declaration",
        "comment": "解析一个变量声明(`x = 1`、`[x] = [1]`、`{a: x} = {a: 1}`)。",
        "parts": [
            {
                "name": "mame",
                "comment": "获取当前变量声明的undefined。",
                "equals": "@BindingName()",
                "type": "BindingName"
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前变量声明的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            },
            {
                "inlined": true,
                "name": "=Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "initializer",
                "type": "Expression",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前变量声明的(可能不存在)。",
                "args": "allowIn",
                "equals": "@Initializer(allowIn)",
                "type": "Initializer"
            }
        ],
        "codes": [
            "const result = new @VariableDeclaration();",
            "result.mame = @BindingName();",
            "result.:Token = undefined;",
            "result.type = undefined;",
            "result. = @TypeAnnotation();",
            "result.=Token = undefined;",
            "result.initializer = undefined;",
            "result. = @Initializer(allowIn);",
            "return result;"
        ],
        "classComment": "表示一个变量声明(`x = 1`、`[x] = [1]`、`{a: x} = {a: 1}`)。"
    },
    "VariableOrExpressionStatement": {
        "region": "语句",
        "name": "VariableOrExpressionStatement",
        "params": [
            {
                "comment": "是否解析 in 表达式。。",
                "name": "allowIn",
                "equal": "true",
                "type": "boolean"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个变量声明(`let x`)或表达式语句(`let(x)`)。",
        "codes": [
            "const savedToken = @lexer.current;",
            "switch (this.lexer.peek().type) {",
            "\tcase 'let':",
            "\tcase 'var':",
            "\tcase 'const':",
            "\t\t@lexer.read();",
            "\t\tconst isBindingName = isBindingNameStart(this.lexer.peek().type);",
            "\t\t@lexer.current = savedToken;",
            "\t\tif (isBindingName) {",
            "\t\t\treturn @VariableStatement(allowIn);",
            "\t\t}",
            "\t\tbreak;",
            "}",
            "return @ExpressionStatement(@Expression(Precedence.any, allowIn));"
        ]
    },
    "IfStatement": {
        "region": "语句",
        "name": "IfStatement",
        "extends": "Statement",
        "comment": "解析一个if 语句(`if (x) ...`)。",
        "parts": [
            {
                "name": "ifToken",
                "comment": "获取当前if 语句的ifToken 的位置。",
                "equals": "@readToken('if')",
                "type": "number",
                "tokens": [
                    "if"
                ]
            },
            {
                "name": "then",
                "comment": "获取当前if 语句的则部分。",
                "equals": "@Statement()",
                "type": "Statement"
            },
            {
                "optional": true,
                "name": "elseToken",
                "comment": "获取当前if 语句的elseToken 的位置(可能不存在)。",
                "equals": "@readToken('else')",
                "type": "number",
                "tokens": [
                    "else"
                ]
            },
            {
                "optional": true,
                "name": "else",
                "comment": "获取当前if 语句的(可能不存在)。",
                "equals": "@Statement()",
                "type": "Statement"
            }
        ],
        "codes": [
            "Condition",
            "const result = new @IfStatement();",
            "result.ifToken = @readToken('if');",
            "@Condition(result);",
            "result.then = @EmbeddedStatement();",
            "if (this.lexer.peek().type === 'else') {",
            "\tresult.elseToken = @readToken('else');",
            "\tresult.else = @EmbeddedStatement();",
            "}",
            "return result;"
        ],
        "classComment": "表示一个if 语句(`if (x) ...`)。"
    },
    "Condition": {
        "region": "语句",
        "name": "Condition",
        "params": [
            {
                "comment": "存放结果的目标节点。",
                "name": "result",
                "type": "{'('?: number, condition?: Expression(), ')'?: number}"
            }
        ],
        "extends": "Node",
        "comment": "解析一个条件表达式。",
        "parts": [
            {
                "optional": true,
                "name": "(Token",
                "comment": "获取当前条件表达式的(Token 的位置(可能不存在)。",
                "equals": "@readToken('(')",
                "type": "number",
                "tokens": [
                    "("
                ]
            },
            {
                "name": "condition",
                "comment": "获取当前条件表达式的(可能不存在)。",
                "equals": "@Expression()()",
                "type": "Expression()"
            },
            {
                "optional": true,
                "name": ")Token",
                "comment": "获取当前条件表达式的)Token 的位置(可能不存在)。",
                "equals": "@readToken(')')",
                "type": "number",
                "tokens": [
                    ")"
                ]
            }
        ],
        "codes": [
            "const hasParan = this.lexer.peek().type === '(';",
            "if (hasParan || @options.allowMissingParenthese === false) result.openParanToken = @readToken('(');",
            "result.condition = @Expression();",
            "if (hasParan) result.closeParanToken = @readToken(')');"
        ],
        "inline": true,
        "classComment": "表示一个条件表达式。"
    },
    "EmbeddedStatement": {
        "region": "语句",
        "name": "EmbeddedStatement",
        "extends": "Statement",
        "comment": "解析一个内嵌语句。",
        "codes": [
            "return @Statement();"
        ]
    },
    "ForOrForInOrForOfOrForToStatement": {
        "region": "语句",
        "name": "ForOrForInOrForOfOrForToStatement",
        "extends": "Statement",
        "comment": "解析一个for 或 for..in 或 for..of 或 for..to 语句。",
        "codes": [
            "const forToken = @readToken('for');",
            "const openParan = this.lexer.peek().type === '(' || @options.allowMissingParenthese === false ? @readToken('(') : undefined;",
            "const initializer = this.lexer.peek().type === ';' ? undefined : @VariableOrExpressionStatement(false);",
            "let type = this.lexer.peek().type;",
            "switch (type) {",
            "\t//+ case ';':",
            "\t//+\treturn @ForStatement(forToken, openParan, initializer);",
            "\tcase 'in':",
            "\t\treturn @ForInStatement(forToken, openParan, initializer);",
            "\tcase 'of':",
            "\t\treturn @ForOfStatement(forToken, openParan, initializer);",
            "\tcase 'to':",
            "\t\treturn @ForToStatement(forToken, openParan, initializer);",
            "\tdefault:",
            "\t\treturn @ForStatement(forToken, openParan, initializer);",
            "}"
        ]
    },
    "ForStatement": {
        "region": "语句",
        "name": "ForStatement",
        "params": [
            {
                "comment": "undefined。",
                "name": "forToken",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "(Token",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "initializer",
                "type": "VariableStatement | ExpressionStatement"
            }
        ],
        "extends": "Statement",
        "comment": "解析一个for 语句(`for(var i = 0; i < 9; i++) ...`)。",
        "parts": [
            {
                "name": "forToken",
                "comment": "获取当前for 语句的forToken 的位置。",
                "equals": "forToken",
                "type": "number",
                "tokens": [
                    "for"
                ]
            },
            {
                "optional": true,
                "name": "(Token",
                "comment": "获取当前for 语句的(Token 的位置(可能不存在)。",
                "equals": "(Token",
                "type": "number",
                "tokens": [
                    "("
                ]
            },
            {
                "optional": true,
                "name": "initializer",
                "comment": "获取当前for 语句的(可能不存在)。",
                "equals": "initializer",
                "type": "VariableStatement | ExpressionStatement"
            },
            {
                "name": "firstSemicolon",
                "comment": "获取当前for 语句的条件部分中首个分号。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            },
            {
                "optional": true,
                "name": "condition",
                "comment": "获取当前for 语句的(可能不存在)。",
                "equals": "@Expression()",
                "type": "Expression"
            },
            {
                "name": "secondSemicolon",
                "comment": "获取当前for 语句的条件部分中第二个分号。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            },
            {
                "optional": true,
                "name": "iterator",
                "comment": "获取当前for 语句的(可能不存在)。",
                "equals": "@Expression()",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ")Token",
                "comment": "获取当前for 语句的)Token 的位置(可能不存在)。",
                "equals": "@readToken(')')",
                "type": "number",
                "tokens": [
                    ")"
                ]
            },
            {
                "name": "statement",
                "comment": "获取当前for 语句的主体部分。",
                "equals": "@EmbeddedStatement()",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @ForStatement();",
            "result.forToken = forToken;",
            "if (openParanToken != undefined) result.openParanToken = openParanToken;",
            "if (initializer != undefined) result.initializer = initializer;",
            "result.firstSemicolonToken = @readToken(';');",
            "if (this.lexer.peek().type !== ';') result.condition = @Expression();",
            "result.secondSemicolonToken = @readToken(';');",
            "if (openParanToken == undefined ? isExpressionStart(iterator) : this.lexer.peek().type !== ')') result.iterator = @Expression();",
            "if (openParanToken != undefined) result.closeParanToken = @readToken(')');",
            "result.body = @EmbeddedStatement();",
            "return result;"
        ],
        "classComment": "表示一个for 语句(`for(var i = 0; i < 9; i++) ...`)。"
    },
    "ForInStatement": {
        "region": "语句",
        "name": "ForInStatement",
        "params": [
            {
                "comment": "undefined。",
                "name": "forToken",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "(Token",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "initializer",
                "type": "VariableStatement | ExpressionStatement"
            }
        ],
        "extends": "Statement",
        "comment": "解析一个for..in 语句(`for(var x in y) ...`)。",
        "parts": [
            {
                "name": "forToken",
                "comment": "获取当前for..in 语句的forToken 的位置。",
                "equals": "forToken",
                "type": "number",
                "tokens": [
                    "for"
                ]
            },
            {
                "optional": true,
                "name": "(Token",
                "comment": "获取当前for..in 语句的(Token 的位置(可能不存在)。",
                "equals": "(Token",
                "type": "number",
                "tokens": [
                    "("
                ]
            },
            {
                "name": "initializer",
                "comment": "获取当前for..in 语句的(可能不存在)。",
                "equals": "initializer",
                "type": "VariableStatement | ExpressionStatement"
            },
            {
                "name": "inToken",
                "comment": "获取当前for..in 语句的inToken 的位置。",
                "equals": "@readToken('in')",
                "type": "number",
                "tokens": [
                    "in"
                ]
            },
            {
                "name": "condition",
                "comment": "获取当前for..in 语句的(可能不存在)。",
                "equals": "@Expression()",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ")Token",
                "comment": "获取当前for..in 语句的)Token 的位置(可能不存在)。",
                "equals": "@readToken(')')",
                "type": "number",
                "tokens": [
                    ")"
                ]
            },
            {
                "name": "statement",
                "comment": "获取当前for..in 语句的主体部分。",
                "equals": "@Statement()",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @ForInStatement();",
            "result.forToken = forToken;",
            "if (openParanToken != undefined) result.openParanToken = openParanToken;",
            "result.initializer = initializer;",
            "result.inToken = @readToken('in');",
            "result.condition = @Expression();",
            "if (openParanToken != undefined) result.closeParanToken = @readToken(')');",
            "result.body = @EmbeddedStatement();",
            "return result;"
        ],
        "classComment": "表示一个for..in 语句(`for(var x in y) ...`)。"
    },
    "ForOfStatement": {
        "region": "语句",
        "name": "ForOfStatement",
        "params": [
            {
                "comment": "undefined。",
                "name": "forToken",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "(Token",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "initializer",
                "type": "VariableStatement | ExpressionStatement"
            }
        ],
        "extends": "Statement",
        "comment": "解析一个for..of 语句(`for(var x of y) ...`)。",
        "parts": [
            {
                "name": "forToken",
                "comment": "获取当前for..of 语句的forToken 的位置。",
                "equals": "forToken",
                "type": "number",
                "tokens": [
                    "for"
                ]
            },
            {
                "optional": true,
                "name": "(Token",
                "comment": "获取当前for..of 语句的(Token 的位置(可能不存在)。",
                "equals": "(Token",
                "type": "number",
                "tokens": [
                    "("
                ]
            },
            {
                "name": "initializer",
                "comment": "获取当前for..of 语句的(可能不存在)。",
                "equals": "initializer",
                "type": "VariableStatement | ExpressionStatement"
            },
            {
                "name": "ofToken",
                "comment": "获取当前for..of 语句的ofToken 的位置。",
                "equals": "@readToken('of')",
                "type": "number",
                "tokens": [
                    "of"
                ]
            },
            {
                "name": "condition",
                "comment": "获取当前for..of 语句的(可能不存在)。",
                "equals": "@Expression()",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ")Token",
                "comment": "获取当前for..of 语句的)Token 的位置(可能不存在)。",
                "equals": "@readToken(')')",
                "type": "number",
                "tokens": [
                    ")"
                ]
            },
            {
                "name": "statement",
                "comment": "获取当前for..of 语句的主体部分。",
                "equals": "@Statement()",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @ForInStatement();",
            "result.forToken = forToken;",
            "if (openParanToken != undefined) result.openParanToken = openParanToken;",
            "result.initializer = initializer;",
            "result.ofToken = @readToken('of');",
            "result.condition = @Expression();",
            "if (openParanToken != undefined) result.closeParanToken = @readToken(')');",
            "result.body = @EmbeddedStatement();",
            "return result;"
        ],
        "classComment": "表示一个for..of 语句(`for(var x of y) ...`)。"
    },
    "ForToStatement": {
        "region": "语句",
        "name": "ForToStatement",
        "params": [
            {
                "comment": "undefined。",
                "name": "forToken",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "(Token",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "initializer",
                "type": "VariableStatement | ExpressionStatement"
            }
        ],
        "extends": "Statement",
        "comment": "解析一个for..to 语句(`for(var x = 0 to 10) ...`)。",
        "parts": [
            {
                "name": "forToken",
                "comment": "获取当前for..to 语句的forToken 的位置。",
                "equals": "forToken",
                "type": "number",
                "tokens": [
                    "for"
                ]
            },
            {
                "optional": true,
                "name": "(Token",
                "comment": "获取当前for..to 语句的(Token 的位置(可能不存在)。",
                "equals": "(Token",
                "type": "number",
                "tokens": [
                    "("
                ]
            },
            {
                "name": "initializer",
                "comment": "获取当前for..to 语句的(可能不存在)。",
                "equals": "initializer",
                "type": "VariableStatement | ExpressionStatement"
            },
            {
                "name": "toToken",
                "comment": "获取当前for..to 语句的toToken 的位置。",
                "equals": "@readToken('to')",
                "type": "number",
                "tokens": [
                    "to"
                ]
            },
            {
                "name": "expression",
                "comment": "获取当前for..to 语句的表达式部分。",
                "equals": "@Expression()",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ")Token",
                "comment": "获取当前for..to 语句的)Token 的位置(可能不存在)。",
                "equals": "@readToken(')')",
                "type": "number",
                "tokens": [
                    ")"
                ]
            },
            {
                "name": "statement",
                "comment": "获取当前for..to 语句的主体部分。",
                "equals": "@Statement()",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @ForInStatement();",
            "result.forToken = forToken;",
            "if (openParanToken != undefined) result.openParanToken = openParanToken;",
            "result.initializer = initializer;",
            "result.toToken = @readToken('to');",
            "result.condition = @Expression();",
            "if (openParanToken != undefined) result.closeParanToken = @readToken(')');",
            "result.body = @EmbeddedStatement();",
            "return result;"
        ],
        "classComment": "表示一个for..to 语句(`for(var x = 0 to 10) ...`)。"
    },
    "WhileStatement": {
        "region": "语句",
        "name": "WhileStatement",
        "extends": "Statement",
        "comment": "解析一个while 语句(`while(x) ...`)。",
        "parts": [
            {
                "name": "whileToken",
                "comment": "获取当前while 语句的whileToken 的位置。",
                "equals": "@readToken('while')",
                "type": "number",
                "tokens": [
                    "while"
                ]
            },
            {
                "name": "statement",
                "comment": "获取当前while 语句的主体部分。",
                "equals": "@EmbeddedStatement()",
                "type": "Statement"
            }
        ],
        "codes": [
            "Condition"
        ],
        "classComment": "表示一个while 语句(`while(x) ...`)。"
    },
    "SwitchStatement": {
        "region": "语句",
        "name": "SwitchStatement",
        "extends": "Statement",
        "comment": "解析一个switch 语句(`switch(x) {...}`)。",
        "parts": [
            {
                "name": "switchToken",
                "comment": "获取当前switch 语句的switchToken 的位置。",
                "equals": "@readToken('switch')",
                "type": "number",
                "tokens": [
                    "switch"
                ]
            },
            {
                "inlined": true,
                "name": "(Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "condition",
                "type": "Expression()",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": ")Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前switch 语句的(可能不存在)。",
                "equals": "@Condition()",
                "type": "Condition"
            },
            {
                "name": "cases",
                "comment": "获取当前switch 语句的undefined。",
                "equals": "@NodeList(@CaseOrDefaultClause, '{', '}')",
                "type": "{ ?CaseOrDefaultClause ... }",
                "list": {
                    "element": "CaseOrDefaultClause",
                    "open": "{",
                    "close": "}",
                    "continue": "",
                    "seperator": "",
                    "optional": true,
                    "type": "@NodeList<@CaseOrDefaultClause>",
                    "equals": "@NodeList(@CaseOrDefaultClause, '{', '}')"
                }
            }
        ],
        "codes": [
            "const result = new @SwitchStatement();",
            "result.switchToken = @readToken('switch');",
            "if (@options.allowMissingSwitchCondition === false || this.lexer.peek().type !== '{') {",
            "\t@Condition(result);",
            "}",
            "result.cases = @NodeList(@CaseOrDefaultClause, '{', '}');",
            "return result;"
        ],
        "classComment": "表示一个switch 语句(`switch(x) {...}`)。"
    },
    "CaseOrDefaultClause": {
        "region": "语句",
        "name": "CaseOrDefaultClause",
        "extends": "Node",
        "comment": "解析一个case(`case x: ...`) 或 default(`default: ...`) 分支。",
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\tcase 'case':",
            "\t\treturn @CaseClause();",
            "\tcase 'default':",
            "\t\treturn @DefaultClause();",
            "\tdefault:",
            "\t\t@error(@lexer.peek(), \"'case' or 'default' expected; Unexpected token '{0}'.\", getTokenName(this.lexer.peek().type));",
            "\t\treturn;",
            "}"
        ]
    },
    "CaseClause": {
        "region": "语句",
        "name": "CaseClause",
        "extends": "Node",
        "comment": "解析一个case 分支(`case x: ...`)。",
        "parts": [
            {
                "name": "caseToken",
                "comment": "获取当前case 分支的caseToken 的位置。",
                "equals": "@readToken('case')",
                "type": "number",
                "tokens": [
                    "case"
                ]
            },
            {
                "name": "labels",
                "comment": "获取当前case 分支的标签列表。",
                "equals": "@DelimitedList(@CaseClauseLabel, undefined, undefined, false, @isCaseLabelStart)",
                "type": "CaseClauseLabel , ...isCaseLabelStart",
                "list": {
                    "element": "CaseClauseLabel",
                    "open": "",
                    "close": "",
                    "continue": "isCaseLabelStart",
                    "seperator": ",",
                    "optional": false,
                    "type": "@NodeList<@CaseClauseLabel>",
                    "equals": "@DelimitedList(@CaseClauseLabel, undefined, undefined, false, @isCaseLabelStart)"
                }
            },
            {
                "name": ":Token",
                "comment": "获取当前case 分支的:Token 的位置。",
                "equals": "@readToken(':')",
                "type": "number",
                "tokens": [
                    ":"
                ]
            },
            {
                "name": "statements",
                "comment": "获取当前case 分支的undefined。",
                "equals": "@NodeList(@CaseStatement)",
                "type": "Statement ...",
                "list": {
                    "element": "Statement",
                    "open": "",
                    "close": "",
                    "continue": "",
                    "seperator": "",
                    "optional": false,
                    "type": "@NodeList<@Statement>",
                    "equals": "@NodeList(@Statement)"
                }
            }
        ],
        "codes": [
            "const result = new @CaseClause();",
            "result.caseToken = @readToken('case');",
            "result.labels = @DelimitedList(@CaseClauseLabel, undefined, undefined, false, @isCaseLabelStart);",
            "result.:Token = @readToken(':');",
            "result.statements = @NodeList(@CaseStatement);",
            "return result;"
        ],
        "classComment": "表示一个case 分支(`case x: ...`)。"
    },
    "CaseClauseLabel": {
        "region": "语句",
        "name": "CaseClauseLabel",
        "extends": "Node",
        "comment": "解析一个case 分支标签(`case x: ...`)。",
        "parts": [
            {
                "optional": true,
                "name": "elseToken",
                "comment": "获取当前case 分支标签的elseToken 的位置(可能不存在)。",
                "equals": "@readToken('else')",
                "type": "number",
                "tokens": [
                    "else"
                ]
            },
            {
                "optional": true,
                "name": "label",
                "comment": "获取当前case 分支标签的(可能不存在)。",
                "args": "Precedence.assignment",
                "equals": "@Expression(Precedence.assignment)",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @CaseClauseLabel();",
            "if (@options.allowCaseElse !== false && this.lexer.peek().type === 'else') {",
            "\tresult.elseToken = @readToken('else');",
            "} else {",
            "\tresult.label = @Expression(Precedence.assignment);",
            "}",
            "return result;"
        ],
        "classComment": "表示一个case 分支标签(`case x: ...`)。"
    },
    "DefaultClause": {
        "region": "语句",
        "name": "DefaultClause",
        "extends": "Node",
        "comment": "解析一个default 分支(`default: ...`)。",
        "parts": [
            {
                "name": "defaultToken",
                "comment": "获取当前default 分支的defaultToken 的位置。",
                "equals": "@readToken('default')",
                "type": "number",
                "tokens": [
                    "default"
                ]
            },
            {
                "name": ":Token",
                "comment": "获取当前default 分支的:Token 的位置。",
                "equals": "@readToken(':')",
                "type": "number",
                "tokens": [
                    ":"
                ]
            },
            {
                "name": "statements",
                "comment": "获取当前default 分支的undefined。",
                "equals": "@NodeList(@CaseStatement)",
                "type": "Statement ...",
                "list": {
                    "element": "Statement",
                    "open": "",
                    "close": "",
                    "continue": "",
                    "seperator": "",
                    "optional": false,
                    "type": "@NodeList<@Statement>",
                    "equals": "@NodeList(@Statement)"
                }
            }
        ],
        "codes": [
            "const result = new @DefaultClause();",
            "result.defaultToken = @readToken('default');",
            "result.:Token = @readToken(':');",
            "result.statements = @NodeList(@CaseStatement);",
            "return result;"
        ],
        "classComment": "表示一个default 分支(`default: ...`)。"
    },
    "CaseStatement": {
        "region": "语句",
        "name": "CaseStatement",
        "extends": "Statement",
        "comment": "解析一个case 段语句。",
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\tcase 'case':",
            "\tcase 'default':",
            "\tcase '}':",
            "\tcase 'endOfFile':",
            "\t\treturn;",
            "\tdefault:",
            "\t\treturn @Statement();",
            "}"
        ]
    },
    "DoWhileStatement": {
        "region": "语句",
        "name": "DoWhileStatement",
        "extends": "Statement",
        "comment": "解析一个do..while 语句(`do ... while(x);`)。",
        "parts": [
            {
                "name": "doToken",
                "comment": "获取当前do..while 语句的doToken 的位置。",
                "equals": "@readToken('do')",
                "type": "number",
                "tokens": [
                    "do"
                ]
            },
            {
                "name": "statement",
                "comment": "获取当前do..while 语句的主体部分。",
                "equals": "@EmbeddedStatement()",
                "type": "Statement"
            },
            {
                "name": "whileToken",
                "comment": "获取当前do..while 语句的whileToken 的位置。",
                "equals": "@readToken('while')",
                "type": "number",
                "tokens": [
                    "while"
                ]
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前do..while 语句的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "Condition"
        ],
        "classComment": "表示一个do..while 语句(`do ... while(x);`)。"
    },
    "BreakStatement": {
        "region": "语句",
        "name": "BreakStatement",
        "extends": "Statement",
        "comment": "解析一个break 语句(`break xx;`)。",
        "parts": [
            {
                "name": "breakToken",
                "comment": "获取当前break 语句的breakToken 的位置。",
                "equals": "@readToken('break')",
                "type": "number",
                "tokens": [
                    "break"
                ]
            },
            {
                "optional": true,
                "name": "label",
                "comment": "获取当前break 语句的(可能不存在)。",
                "args": "false",
                "equals": "@Identifier(false)",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前break 语句的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "const result = new @ContinueStatement();",
            "@BreakOrContinueStatement(result, 'continue');",
            "return result;"
        ],
        "classComment": "表示一个break 语句(`break xx;`)。"
    },
    "ContinueStatement": {
        "region": "语句",
        "name": "ContinueStatement",
        "extends": "Statement",
        "comment": "解析一个continue 语句(`continue xx;`)。",
        "parts": [
            {
                "name": "continueToken",
                "comment": "获取当前continue 语句的continueToken 的位置。",
                "equals": "@readToken('continue')",
                "type": "number",
                "tokens": [
                    "continue"
                ]
            },
            {
                "optional": true,
                "name": "label",
                "comment": "获取当前continue 语句的(可能不存在)。",
                "args": "false",
                "equals": "@Identifier(false)",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前continue 语句的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "const result = new @ContinueStatement();",
            "@BreakOrContinueStatement(result, 'continue');",
            "return result;"
        ],
        "classComment": "表示一个continue 语句(`continue xx;`)。"
    },
    "BreakOrContinueStatement": {
        "region": "语句",
        "name": "BreakOrContinueStatement",
        "params": [
            {
                "comment": "存放结果的目标节点。",
                "name": "result",
                "type": "{}"
            },
            {
                "comment": "undefined。",
                "name": "token",
                "type": "TokenType"
            }
        ],
        "extends": "Statement",
        "comment": "解析一个break(`break xx;`)或 continue(`continue xx;`)语句。",
        "codes": [
            "result.start = @readToken(token);",
            "if (!@tryReadSemicolon(result)) {",
            "\tresult.label = @Identifier();",
            "\t@tryReadSemicolon(result);",
            "}"
        ],
        "inline": true
    },
    "ReturnStatement": {
        "region": "语句",
        "name": "ReturnStatement",
        "extends": "Statement",
        "comment": "解析一个return 语句(`return x;`)。",
        "parts": [
            {
                "name": "returnToken",
                "comment": "获取当前return 语句的returnToken 的位置。",
                "equals": "@readToken('return')",
                "type": "number",
                "tokens": [
                    "return"
                ]
            },
            {
                "optional": true,
                "name": "value",
                "comment": "获取当前return 语句的(可能不存在)。",
                "equals": "@Expression()",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前return 语句的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "const result = new @ReturnStatement();",
            "result.returnToken = @readToken('return');",
            "if (!@tryReadSemicolon(result)) {",
            "\tresult.value = @Expression();",
            "\t@tryReadSemicolon(result);",
            "}",
            "return result;"
        ],
        "classComment": "表示一个return 语句(`return x;`)。"
    },
    "TryStatement": {
        "region": "语句",
        "name": "TryStatement",
        "extends": "Statement",
        "comment": "解析一个try 语句(`try {...} catch(e) {...}`)。",
        "parts": [
            {
                "name": "tryToken",
                "comment": "获取当前try 语句的tryToken 的位置。",
                "equals": "@readToken('try')",
                "type": "number",
                "tokens": [
                    "try"
                ]
            },
            {
                "name": "try",
                "comment": "获取当前try 语句的undefined。",
                "equals": "@Statement()",
                "type": "Statement"
            },
            {
                "name": "catch",
                "comment": "获取当前try 语句的undefined。",
                "equals": "@CatchClause()",
                "type": "CatchClause"
            },
            {
                "name": "finally",
                "comment": "获取当前try 语句的undefined。",
                "equals": "@FinallyClause()",
                "type": "FinallyClause"
            }
        ],
        "codes": [
            "const result = new @TryStatement();",
            "result.tryToken = @readToken('try');",
            "result.try = @EmbeddedStatement();",
            "if (this.lexer.peek().type === 'catch') result.catch = @CatchClause();",
            "if (this.lexer.peek().type === 'finally') result.catch = @FinallyClause();",
            "if (@options.allowSimpleTryBlock === false && !result.catch && !result.finally) {",
            "\t@error(@lexer.peek(), \"'catch' or 'finally' expected. Unexpected token '{0}'.\", getTokenName(@lexer.peek()));",
            "}",
            "return result;"
        ],
        "classComment": "表示一个try 语句(`try {...} catch(e) {...}`)。"
    },
    "CatchClause": {
        "region": "语句",
        "name": "CatchClause",
        "extends": "Node",
        "comment": "解析一个catch 分句(`catch(e) {...}`)。",
        "parts": [
            {
                "name": "catchToken",
                "comment": "获取当前catch 分句的catchToken 的位置。",
                "equals": "@readToken('catch')",
                "type": "number",
                "tokens": [
                    "catch"
                ]
            },
            {
                "optional": true,
                "name": "(Token",
                "comment": "获取当前catch 分句的(Token 的位置(可能不存在)。",
                "equals": "@readToken('(')",
                "type": "number",
                "tokens": [
                    "("
                ]
            },
            {
                "optional": true,
                "name": "variable",
                "comment": "获取当前catch 分句的(可能不存在)。",
                "equals": "@BindingName()",
                "type": "BindingName"
            },
            {
                "optional": true,
                "name": ")Token",
                "comment": "获取当前catch 分句的)Token 的位置(可能不存在)。",
                "equals": "@readToken(')')",
                "type": "number",
                "tokens": [
                    ")"
                ]
            },
            {
                "name": "statement",
                "comment": "获取当前catch 分句的主体部分。",
                "equals": "@Statement()",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @CatchClause();",
            "result.catchToken = @readToken('catch');",
            "const hasParan = this.lexer.peek().type === '(';",
            "if (hasParan || @options.allowMissingParenthese === false) result.openParan = @readToken('(');",
            "if (@options.allowMissingCatchVaribale === false || isBindingName(this.lexer.peek().type)) {",
            "\tresult.variable = @BindingName();",
            "\tif (this.lexer.peek().type === ':') {",
            "\t\t@error(this.lexer.peek().type, \"Catch variable cannot have a type annotation; Unexpected token ':'.\");",
            "\t\t@read;",
            "\t\tif (isTypeNodeStart(this.lexer.peek().type)) {",
            "\t\t\t@TypeNode();",
            "\t\t}",
            "\t}",
            "}",
            "if (hasParan) result.closeParan = @readToken(')');",
            "result.body = @EmbeddedStatement();",
            "return result;"
        ],
        "classComment": "表示一个catch 分句(`catch(e) {...}`)。"
    },
    "FinallyClause": {
        "region": "语句",
        "name": "FinallyClause",
        "extends": "Node",
        "comment": "解析一个finally 分句(`finally {...}`)。",
        "parts": [
            {
                "name": "finallyToken",
                "comment": "获取当前finally 分句的finallyToken 的位置。",
                "equals": "@readToken('finally')",
                "type": "number",
                "tokens": [
                    "finally"
                ]
            },
            {
                "name": "statement",
                "comment": "获取当前finally 分句的主体部分。",
                "equals": "@EmbeddedStatement()",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @FinallyClause();",
            "result.finallyToken = @readToken('finally');",
            "result.statement = @EmbeddedStatement();",
            "return result;"
        ],
        "classComment": "表示一个finally 分句(`finally {...}`)。"
    },
    "DebuggerStatement": {
        "region": "语句",
        "name": "DebuggerStatement",
        "extends": "Statement",
        "comment": "解析一个debugger 语句(`debugger;`)。",
        "parts": [
            {
                "name": "debuggerToken",
                "comment": "获取当前debugger 语句的debuggerToken 的位置。",
                "equals": "@readToken('debugger')",
                "type": "number",
                "tokens": [
                    "debugger"
                ]
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前debugger 语句的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "const result = new @DebuggerStatement();",
            "result.debuggerToken = @readToken('debugger');",
            "if (@peek === ';') result.;Token = @readToken(';');",
            "return result;"
        ],
        "classComment": "表示一个debugger 语句(`debugger;`)。"
    },
    "EmptyStatement": {
        "region": "语句",
        "name": "EmptyStatement",
        "extends": "Statement",
        "comment": "解析一个空语句(`;`)。",
        "parts": [
            {
                "name": ";Token",
                "comment": "获取当前空语句的;Token 的位置。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "const result = new @EmptyStatement();",
            "result.;Token = @readToken(';');",
            "return result;"
        ],
        "classComment": "表示一个空语句(`;`)。"
    },
    "WithStatement": {
        "region": "语句",
        "name": "WithStatement",
        "extends": "Statement",
        "comment": "解析一个with 语句(`with (x) ...`)。",
        "parts": [
            {
                "name": "withToken",
                "comment": "获取当前with 语句的withToken 的位置。",
                "equals": "@readToken('with')",
                "type": "number",
                "tokens": [
                    "with"
                ]
            },
            {
                "optional": true,
                "name": "(Token",
                "comment": "获取当前with 语句的(Token 的位置(可能不存在)。",
                "equals": "@readToken('(')",
                "type": "number",
                "tokens": [
                    "("
                ]
            },
            {
                "name": "value",
                "comment": "获取当前with 语句的值。",
                "equals": "@VariableStatement | Expression()",
                "type": "VariableStatement | Expression"
            },
            {
                "optional": true,
                "name": ")Token",
                "comment": "获取当前with 语句的)Token 的位置(可能不存在)。",
                "equals": "@readToken(')')",
                "type": "number",
                "tokens": [
                    ")"
                ]
            },
            {
                "name": "body",
                "comment": "获取当前with 语句的主体部分。",
                "equals": "@Statement()",
                "type": "Statement"
            }
        ],
        "codes": [
            "const result = new @WithStatement();",
            "result.start = @readToken('with');",
            "const hasParan = this.lexer.peek().type === '(';",
            "if (hasParan) result.openParanToken = @readToken('(');",
            "result.value = @options.allowWithVaribale !== false ? @VariableOrExpressionStatement() : @Expression();",
            "if (hasParan) result.closeParanToken = @readToken(')');",
            "result.body = @EmbeddedStatement();",
            "return result;"
        ],
        "classComment": "表示一个with 语句(`with (x) ...`)。"
    },
    "Declaration": {
        "region": "声明",
        "name": "Declaration",
        "extends": "Statement",
        "comment": "解析一个声明。"
    },
    "FunctionDeclarationOrExpression": {
        "region": "声明",
        "name": "FunctionDeclarationOrExpression",
        "params": [
            {
                "comment": "解析的目标节点。",
                "name": "result",
                "type": "{}"
            },
            {
                "comment": "(可能不存在)。",
                "name": "modifiers",
                "type": "@NodeList<@Modifier>"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个函数声明或表达式。",
        "codes": [
            "@DocComment(result);",
            "if (modifiers) result.modifiers = modifiers;",
            "result.functionToken = @readToken('function');",
            "if (this.lexer.peek().type === '*') result.asteriskToken = @read;",
            "if (isIdentifierName(this.lexer.peek().type)) result.name = @Identifier();",
            "if (this.lexer.peek().type === '<') result.typeParameters = @TypeParameters();",
            "result.parameters = @Parameters();",
            "@TypeAnnotation(result);",
            "@FunctionBody(result);"
        ],
        "inline": true
    },
    "FunctionDeclaration": {
        "region": "声明",
        "name": "FunctionDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Decorators"
            },
            {
                "comment": "undefined。",
                "type": "Modifiers"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个函数声明(`function fn() {...}`、`function *fn() {...}`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前函数声明的(可能不存在)。",
                "equals": "@Decorators()",
                "type": "Decorators"
            },
            {
                "optional": true,
                "comment": "获取当前函数声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "name": "functionToken",
                "comment": "获取当前函数声明的functionToken 的位置。",
                "equals": "@readToken('function')",
                "type": "number",
                "tokens": [
                    "function"
                ]
            },
            {
                "optional": true,
                "name": "*Token",
                "comment": "获取当前函数声明的*Token 的位置(可能不存在)。",
                "equals": "@readToken('*')",
                "type": "number",
                "tokens": [
                    "*"
                ]
            },
            {
                "optional": true,
                "name": "name",
                "comment": "获取当前函数声明的(可能不存在)。",
                "equals": "@Identifier()",
                "type": "Identifier"
            },
            {
                "optional": true,
                "comment": "获取当前函数声明的(可能不存在)。",
                "equals": "@DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName)",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前函数声明的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            },
            {
                "inlined": true,
                "name": "=>Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "body",
                "type": "BlockStatement | Expression",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": ";Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前函数声明的(可能不存在)。",
                "equals": "@FunctionBody()",
                "type": "FunctionBody"
            }
        ],
        "codes": [
            "Parameters",
            "const result = new @FunctionDeclaration();",
            "if (decorators) result.decorators = decorators;",
            "@FunctionDeclarationOrExpression(result, modifiers);",
            "return result;"
        ],
        "classComment": "表示一个函数声明(`function fn() {...}`、`function *fn() {...}`)。"
    },
    "FunctionExpression": {
        "region": "声明",
        "name": "FunctionExpression",
        "params": [
            {
                "comment": "undefined。",
                "type": "Modifiers"
            }
        ],
        "doc": true,
        "extends": "Expression",
        "comment": "解析一个函数表达式(`function () {}`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前函数表达式的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "name": "functionToken",
                "comment": "获取当前函数表达式的functionToken 的位置。",
                "equals": "@readToken('function')",
                "type": "number",
                "tokens": [
                    "function"
                ]
            },
            {
                "optional": true,
                "name": "*Token",
                "comment": "获取当前函数表达式的*Token 的位置(可能不存在)。",
                "equals": "@readToken('*')",
                "type": "number",
                "tokens": [
                    "*"
                ]
            },
            {
                "optional": true,
                "name": "name",
                "comment": "获取当前函数表达式的(可能不存在)。",
                "equals": "@Identifier()",
                "type": "Identifier"
            },
            {
                "optional": true,
                "comment": "获取当前函数表达式的(可能不存在)。",
                "equals": "@DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName)",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前函数表达式的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            },
            {
                "inlined": true,
                "name": "=>Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "body",
                "type": "BlockStatement | Expression",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": ";Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前函数表达式的(可能不存在)。",
                "equals": "@FunctionBody()",
                "type": "FunctionBody"
            }
        ],
        "codes": [
            "Parameters",
            "const result = new @FunctionDeclaration();",
            "@FunctionDeclarationOrExpression(result, modifiers);",
            "return result;"
        ],
        "classComment": "表示一个函数表达式(`function () {}`)。"
    },
    "FunctionBody": {
        "region": "声明",
        "name": "FunctionBody",
        "params": [
            {
                "comment": "存放结果的目标节点。",
                "name": "result",
                "type": "{'=>'?: number, body?: BlockStatement | Expression, ';'?: number}"
            }
        ],
        "extends": "Node",
        "comment": "解析一个函数主体(`{...}`、`=> xx`、`;`)。",
        "parts": [
            {
                "optional": true,
                "name": "=>Token",
                "comment": "获取当前函数主体的=>Token 的位置(可能不存在)。",
                "equals": "@readToken('=>')",
                "type": "number",
                "tokens": [
                    "=>"
                ]
            },
            {
                "optional": true,
                "name": "body",
                "comment": "获取当前函数主体的(可能不存在)。",
                "equals": "@BlockStatement | Expression()",
                "type": "BlockStatement | Expression"
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前函数主体的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\tcase '{':",
            "\t\tresult.body = @BlockStatement();",
            "\t\tbreak;",
            "\tcase '=>':",
            "\t\tresult.arrowToken = @read;",
            "\t\tresult.body = @Expression(Precedence.assignment);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\t@tryReadSemicolon(result);",
            "\t\tbreak;",
            "}"
        ],
        "inline": true,
        "classComment": "表示一个函数主体(`{...}`、`=> xx`、`;`)。"
    },
    "ClassDeclarationOrExpression": {
        "region": "声明",
        "name": "ClassDeclarationOrExpression",
        "params": [
            {
                "comment": "存放结果的目标节点。",
                "name": "result",
                "type": "{}"
            }
        ],
        "extends": "Expression",
        "comment": "解析一个类声明或类表达式。",
        "codes": [
            "@DocComment(result);",
            "result.classToken = @readToken('class');",
            "if (isIdentifierName(this.lexer.peek().type) && this.lexer.peek().type !== 'extends' && this.lexer.peek().type !== 'implements') result.name = @Identifier();",
            "if (this.lexer.peek().type === '<') result.typeParameters = @TypeParameters();",
            "@ExtendsClause(result);",
            "@ImplementsClause(result);",
            "@ClassBody(result);"
        ],
        "inline": true
    },
    "ClassDeclaration": {
        "region": "声明",
        "name": "ClassDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Decorators"
            },
            {
                "comment": "undefined。",
                "type": "Modifiers"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个类声明(`class xx {}`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前类声明的(可能不存在)。",
                "equals": "@Decorators()",
                "type": "Decorators"
            },
            {
                "optional": true,
                "comment": "获取当前类声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "name": "classToken",
                "comment": "获取当前类声明的classToken 的位置。",
                "equals": "@readToken('class')",
                "type": "number",
                "tokens": [
                    "class"
                ]
            },
            {
                "optional": true,
                "comment": "获取当前类声明的(可能不存在)。",
                "equals": "@DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName)",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "inlined": true,
                "name": "extendsToken",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "extends",
                "type": "ClassHeritageNode , ... isExpressionStart",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前类声明的(可能不存在)。",
                "equals": "@ExtendsClause()",
                "type": "ExtendsClause"
            },
            {
                "inlined": true,
                "name": "implementsToken",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "implements",
                "type": "ClassHeritageNode , ... isExpressionStart",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前类声明的(可能不存在)。",
                "equals": "@ImplementsClause()",
                "type": "ImplementsClause"
            },
            {
                "inlined": true,
                "name": "members",
                "type": "{ ClassElement ... }",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": ";Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前类声明的(可能不存在)。",
                "equals": "@ClassBody()",
                "type": "ClassBody"
            }
        ],
        "codes": [
            "name?: Identifier",
            "const result = new @ClassDeclaration();",
            "if (decorators) result.decorators = decorators;",
            "if (modifiers) result.modifiers = modifiers;",
            "@ClassDeclarationOrExpression(result);",
            "return result;"
        ],
        "classComment": "表示一个类声明(`class xx {}`)。"
    },
    "ClassExpression": {
        "region": "声明",
        "name": "ClassExpression",
        "doc": true,
        "extends": "Expression",
        "comment": "解析一个类表达式(`class xx {}`)。",
        "parts": [
            {
                "name": "classToken",
                "comment": "获取当前类表达式的classToken 的位置。",
                "equals": "@readToken('class')",
                "type": "number",
                "tokens": [
                    "class"
                ]
            },
            {
                "optional": true,
                "comment": "获取当前类表达式的(可能不存在)。",
                "equals": "@DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName)",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "inlined": true,
                "name": "extendsToken",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "extends",
                "type": "ClassHeritageNode , ... isExpressionStart",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前类表达式的(可能不存在)。",
                "equals": "@ExtendsClause()",
                "type": "ExtendsClause"
            },
            {
                "inlined": true,
                "name": "implementsToken",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "implements",
                "type": "ClassHeritageNode , ... isExpressionStart",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前类表达式的(可能不存在)。",
                "equals": "@ImplementsClause()",
                "type": "ImplementsClause"
            },
            {
                "inlined": true,
                "name": "members",
                "type": "{ ClassElement ... }",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": ";Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前类表达式的(可能不存在)。",
                "equals": "@ClassBody()",
                "type": "ClassBody"
            }
        ],
        "codes": [
            "name?: Identifier",
            "const result = new @ClassExpression();",
            "@ClassDeclarationOrExpression(result);",
            "return result;"
        ],
        "classComment": "表示一个类表达式(`class xx {}`)。"
    },
    "ExtendsClause": {
        "region": "声明",
        "name": "ExtendsClause",
        "params": [
            {
                "comment": "存放结果的目标节点。",
                "name": "result",
                "type": "{'extends'?: number, extends?: ClassHeritageNode , ... isExpressionStart}"
            }
        ],
        "extends": "Node",
        "comment": "解析一个extends 分句(`extends xx`)。",
        "parts": [
            {
                "optional": true,
                "name": "extendsToken",
                "comment": "获取当前extends 分句的extendsToken 的位置(可能不存在)。",
                "equals": "@readToken('extends')",
                "type": "number",
                "tokens": [
                    "extends"
                ]
            },
            {
                "optional": true,
                "name": "extends",
                "comment": "获取当前extends 分句的(可能不存在)。",
                "equals": "@NodeList(@,, 'ClassHeritageNode', 'isExpressionStart')",
                "type": "ClassHeritageNode , ... isExpressionStart",
                "list": {
                    "element": ",",
                    "open": "ClassHeritageNode",
                    "close": "isExpressionStart",
                    "continue": "",
                    "seperator": "",
                    "optional": false,
                    "type": "@NodeList<@,>",
                    "equals": "@NodeList(@,, 'ClassHeritageNode', 'isExpressionStart')"
                }
            }
        ],
        "codes": [
            "if (@peek === 'extends') result.extendsToken = @readToken('extends');",
            "result.extends = @NodeList(@,, 'ClassHeritageNode', 'isExpressionStart');"
        ],
        "inline": true,
        "classComment": "表示一个extends 分句(`extends xx`)。"
    },
    "ImplementsClause": {
        "region": "声明",
        "name": "ImplementsClause",
        "params": [
            {
                "comment": "存放结果的目标节点。",
                "name": "result",
                "type": "{'implements'?: number, implements?: ClassHeritageNode , ... isExpressionStart}"
            }
        ],
        "extends": "Node",
        "comment": "解析一个implements 分句(`implements xx`)。",
        "parts": [
            {
                "optional": true,
                "name": "implementsToken",
                "comment": "获取当前implements 分句的implementsToken 的位置(可能不存在)。",
                "equals": "@readToken('implements')",
                "type": "number",
                "tokens": [
                    "implements"
                ]
            },
            {
                "optional": true,
                "name": "implements",
                "comment": "获取当前implements 分句的(可能不存在)。",
                "equals": "@NodeList(@,, 'ClassHeritageNode', 'isExpressionStart')",
                "type": "ClassHeritageNode , ... isExpressionStart",
                "list": {
                    "element": ",",
                    "open": "ClassHeritageNode",
                    "close": "isExpressionStart",
                    "continue": "",
                    "seperator": "",
                    "optional": false,
                    "type": "@NodeList<@,>",
                    "equals": "@NodeList(@,, 'ClassHeritageNode', 'isExpressionStart')"
                }
            }
        ],
        "codes": [
            "if (@peek === 'implements') result.implementsToken = @readToken('implements');",
            "result.implements = @NodeList(@,, 'ClassHeritageNode', 'isExpressionStart');"
        ],
        "inline": true,
        "classComment": "表示一个implements 分句(`implements xx`)。"
    },
    "ClassHeritageNode": {
        "region": "声明",
        "name": "ClassHeritageNode",
        "extends": "Node",
        "comment": "解析一个extends 或 implements 分句项。",
        "parts": [
            {
                "name": "value",
                "comment": "获取当前extends 或 implements 分句项的值。",
                "args": "Precedence.leftHandSide",
                "equals": "@Expression(Precedence.leftHandSide)",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @ClassHeritageNode();",
            "result.value = @Expression(Precedence.leftHandSide);",
            "return result;"
        ],
        "classComment": "表示一个extends 或 implements 分句项。"
    },
    "ClassBody": {
        "region": "声明",
        "name": "ClassBody",
        "params": [
            {
                "comment": "存放结果的目标节点。",
                "name": "result",
                "type": "{members?: { ClassElement ... }, ';'?: number}"
            }
        ],
        "extends": "Node",
        "comment": "解析一个类主体(`{...}`、`;`)。",
        "parts": [
            {
                "optional": true,
                "name": "members",
                "comment": "获取当前类主体的(可能不存在)。",
                "equals": "@NodeList(@ClassElement, '{', '}')",
                "type": "{ ClassElement ... }",
                "list": {
                    "element": "ClassElement",
                    "open": "{",
                    "close": "}",
                    "continue": "",
                    "seperator": "",
                    "optional": false,
                    "type": "@NodeList<@ClassElement>",
                    "equals": "@NodeList(@ClassElement, '{', '}')"
                }
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前类主体的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "if (this.lexer.peek().type === '{') {",
            "\tresult.members = @NodeList(@ClassElement, '{', '}');",
            "} else {",
            "\t@tryReadSemicolon(result);",
            "}"
        ],
        "inline": true,
        "classComment": "表示一个类主体(`{...}`、`;`)。"
    },
    "ClassElement": {
        "region": "声明",
        "name": "ClassElement",
        "extends": "Node",
        "alias": "MethodDeclaration | PropertyDeclaration | AccessorDeclaration",
        "comment": "解析一个类成员。",
        "codes": [
            "const decorators = @Decorators();",
            "const modifiers = @Modifiers();",
            "switch (this.lexer.peek().type) {",
            "\tcase 'identifier':",
            "\t\tbreak;",
            "\tcase 'get':",
            "\tcase 'set':",
            "\t\tconst savedToken = @lexer.current;",
            "\t\t@lexer.read();",
            "\t\tif (isKeyword(this.lexer.peek().type) || this.lexer.peek().type === '[') {",
            "\t\t\treturn @AccessorDeclaration(decorators, modifiers, savedToken.type === 'get' ? savedToken.start : undefined, savedToken.type === 'set' ? savedToken.start : undefined);",
            "\t\t}",
            "\t\t@lexer.current = savedToken;",
            "\t\tbreak;",
            "\tcase '*':",
            "\t\treturn @MethodDeclaration(decorators, modifiers, @read, @PropertyName());",
            "}",
            "const name = @PropertyName();",
            "switch (this.lexer.peek().type) {",
            "\tcase '(':",
            "\tcase '<':",
            "\t\treturn @MethodDeclaration(decorators, modifiers, undefined, name);",
            "\tdefault:",
            "\t\treturn @PropertyDeclaration(decorators, modifiers, name);",
            "}"
        ]
    },
    "AccessorDeclaration": {
        "region": "声明",
        "name": "AccessorDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Decorators"
            },
            {
                "comment": "undefined。",
                "type": "Modifiers"
            },
            {
                "comment": "undefined。",
                "name": "getToken",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "setToken",
                "type": "number"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个访问器声明(`get x() {...}`、`set x(value) {...}`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前访问器声明的(可能不存在)。",
                "equals": "@Decorators()",
                "type": "Decorators"
            },
            {
                "optional": true,
                "comment": "获取当前访问器声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "optional": true,
                "name": "getToken",
                "comment": "获取当前访问器声明的getToken 的位置(可能不存在)。",
                "equals": "getToken",
                "type": "number",
                "tokens": [
                    "get"
                ]
            },
            {
                "optional": true,
                "name": "setToken",
                "comment": "获取当前访问器声明的setToken 的位置(可能不存在)。",
                "equals": "setToken",
                "type": "number",
                "tokens": [
                    "set"
                ]
            },
            {
                "name": "name",
                "comment": "获取当前访问器声明的(可能不存在)。",
                "equals": "@PropertyName()",
                "type": "PropertyName"
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前访问器声明的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            },
            {
                "inlined": true,
                "name": "=>Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "body",
                "type": "BlockStatement | Expression",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": ";Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前访问器声明的(可能不存在)。",
                "equals": "@FunctionBody()",
                "type": "FunctionBody"
            }
        ],
        "codes": [
            "Parameters"
        ],
        "classComment": "表示一个访问器声明(`get x() {...}`、`set x(value) {...}`)。"
    },
    "MethodDeclaration": {
        "region": "声明",
        "name": "MethodDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Decorators"
            },
            {
                "comment": "undefined。",
                "type": "Modifiers"
            },
            {
                "comment": "undefined。",
                "name": "*Token",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "name",
                "type": "PropertyName"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个方法声明(`x() {...}`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前方法声明的(可能不存在)。",
                "equals": "@Decorators()",
                "type": "Decorators"
            },
            {
                "optional": true,
                "comment": "获取当前方法声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "optional": true,
                "name": "*Token",
                "comment": "获取当前方法声明的*Token 的位置(可能不存在)。",
                "equals": "*Token",
                "type": "number",
                "tokens": [
                    "*"
                ]
            },
            {
                "optional": true,
                "name": "name",
                "comment": "获取当前方法声明的(可能不存在)。",
                "equals": "name",
                "type": "PropertyName"
            },
            {
                "optional": true,
                "comment": "获取当前方法声明的(可能不存在)。",
                "equals": "@DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName)",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前方法声明的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            },
            {
                "inlined": true,
                "name": "=>Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "body",
                "type": "BlockStatement | Expression",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": ";Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前方法声明的(可能不存在)。",
                "equals": "@FunctionBody()",
                "type": "FunctionBody"
            }
        ],
        "codes": [
            "Parameters"
        ],
        "classComment": "表示一个方法声明(`x() {...}`)。"
    },
    "PropertyDeclaration": {
        "region": "声明",
        "name": "PropertyDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Decorators"
            },
            {
                "comment": "undefined。",
                "type": "Modifiers"
            },
            {
                "comment": "undefined。",
                "name": "name",
                "type": "PropertyName"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个属性声明(`x: number`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前属性声明的(可能不存在)。",
                "equals": "@Decorators()",
                "type": "Decorators"
            },
            {
                "optional": true,
                "comment": "获取当前属性声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "name": "name",
                "comment": "获取当前属性声明的(可能不存在)。",
                "equals": "name",
                "type": "PropertyName"
            },
            {
                "inlined": true,
                "name": ":Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "type",
                "type": "TypeNode",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前属性声明的(可能不存在)。",
                "equals": "@TypeAnnotation()",
                "type": "TypeAnnotation"
            },
            {
                "inlined": true,
                "name": "=Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "initializer",
                "type": "Expression",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前属性声明的(可能不存在)。",
                "equals": "@Initializer()",
                "type": "Initializer"
            }
        ],
        "codes": [
            "const result = new @PropertyDeclaration();",
            "result. = @Decorators();",
            "result. = @Modifiers();",
            "result.name = name;",
            "result.:Token = undefined;",
            "result.type = undefined;",
            "result. = @TypeAnnotation();",
            "result.=Token = undefined;",
            "result.initializer = undefined;",
            "result. = @Initializer();",
            "return result;"
        ],
        "classComment": "表示一个属性声明(`x: number`)。"
    },
    "InterfaceDeclaration": {
        "region": "声明",
        "name": "InterfaceDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Decorators"
            },
            {
                "comment": "undefined。",
                "type": "Modifiers"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个接口声明(`interface T {...}`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前接口声明的(可能不存在)。",
                "equals": "@Decorators()",
                "type": "Decorators"
            },
            {
                "optional": true,
                "comment": "获取当前接口声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "name": "interfaceToken",
                "comment": "获取当前接口声明的interfaceToken 的位置。",
                "equals": "@readToken('interface')",
                "type": "number",
                "tokens": [
                    "interface"
                ]
            },
            {
                "name": "name",
                "comment": "获取当前接口声明的(可能不存在)。",
                "args": "false",
                "equals": "@Identifier(false)",
                "type": "Identifier"
            },
            {
                "optional": true,
                "comment": "获取当前接口声明的(可能不存在)。",
                "equals": "@DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName)",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "inlined": true,
                "name": "extendsToken",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "extends",
                "type": "ClassHeritageNode , ... isExpressionStart",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前接口声明的(可能不存在)。",
                "equals": "@ExtendsClause()",
                "type": "ExtendsClause"
            },
            {
                "name": "members",
                "comment": "获取当前接口声明的(可能不存在)。",
                "equals": "@NodeList(@TypeMemberSignature, '{', '}')",
                "type": "{ TypeMemberSignature ... }",
                "list": {
                    "element": "TypeMemberSignature",
                    "open": "{",
                    "close": "}",
                    "continue": "",
                    "seperator": "",
                    "optional": false,
                    "type": "@NodeList<@TypeMemberSignature>",
                    "equals": "@NodeList(@TypeMemberSignature, '{', '}')"
                }
            }
        ],
        "codes": [
            "const result = new @InterfaceDeclaration();",
            "result. = @Decorators();",
            "result. = @Modifiers();",
            "result.interfaceToken = @readToken('interface');",
            "result.name = @Identifier(false);",
            "result. = @DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName);",
            "result.extendsToken = undefined;",
            "result.extends = undefined;",
            "result. = @ExtendsClause();",
            "result.members = @NodeList(@TypeMemberSignature, '{', '}');",
            "return result;"
        ],
        "classComment": "表示一个接口声明(`interface T {...}`)。"
    },
    "EnumDeclaration": {
        "region": "声明",
        "name": "EnumDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Decorators"
            },
            {
                "comment": "undefined。",
                "type": "Modifiers"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个枚举声明(`enum T {}`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前枚举声明的(可能不存在)。",
                "equals": "@Decorators()",
                "type": "Decorators"
            },
            {
                "optional": true,
                "comment": "获取当前枚举声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "name": "enumToken",
                "comment": "获取当前枚举声明的enumToken 的位置。",
                "equals": "@readToken('enum')",
                "type": "number",
                "tokens": [
                    "enum"
                ]
            },
            {
                "name": "name",
                "comment": "获取当前枚举声明的(可能不存在)。",
                "args": "false",
                "equals": "@Identifier(false)",
                "type": "Identifier"
            },
            {
                "inlined": true,
                "name": "extendsToken",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "extends",
                "type": "ClassHeritageNode , ... isExpressionStart",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前枚举声明的(可能不存在)。",
                "equals": "@ExtendsClause()",
                "type": "ExtendsClause"
            },
            {
                "name": "members",
                "comment": "获取当前枚举声明的(可能不存在)。",
                "equals": "@DelimitedList(@EnumMemberDeclaration, '{', '}', true, @isPropertyNameStart)",
                "type": "{ ?EnumMemberDeclaration , ...isPropertyNameStart }",
                "list": {
                    "element": "EnumMemberDeclaration",
                    "open": "{",
                    "close": "}",
                    "continue": "isPropertyNameStart",
                    "seperator": ",",
                    "optional": true,
                    "type": "@NodeList<@EnumMemberDeclaration>",
                    "equals": "@DelimitedList(@EnumMemberDeclaration, '{', '}', true, @isPropertyNameStart)"
                }
            }
        ],
        "codes": [
            "const result = new @EnumDeclaration();",
            "result. = @Decorators();",
            "result. = @Modifiers();",
            "result.enumToken = @readToken('enum');",
            "result.name = @Identifier(false);",
            "result.extendsToken = undefined;",
            "result.extends = undefined;",
            "result. = @ExtendsClause();",
            "result.members = @DelimitedList(@EnumMemberDeclaration, '{', '}', true, @isPropertyNameStart);",
            "return result;"
        ],
        "classComment": "表示一个枚举声明(`enum T {}`)。"
    },
    "EnumMemberDeclaration": {
        "region": "声明",
        "name": "EnumMemberDeclaration",
        "extends": "Declaration",
        "comment": "解析一个枚举成员声明(`x`、`x = 1`)。",
        "parts": [
            {
                "name": "name",
                "comment": "获取当前枚举成员声明的(可能不存在)。",
                "equals": "@PropertyName()",
                "type": "PropertyName"
            },
            {
                "inlined": true,
                "name": "=Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "initializer",
                "type": "Expression",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前枚举成员声明的(可能不存在)。",
                "equals": "@Initializer()",
                "type": "Initializer"
            }
        ],
        "codes": [
            "const result = new @EnumMemberDeclaration();",
            "result.name = @PropertyName();",
            "result.=Token = undefined;",
            "result.initializer = undefined;",
            "result. = @Initializer();",
            "return result;"
        ],
        "classComment": "表示一个枚举成员声明(`x`、`x = 1`)。"
    },
    "NamespaceOrModuleDeclaration": {
        "region": "声明",
        "name": "NamespaceOrModuleDeclaration",
        "params": [
            {
                "comment": "存放结果的目标节点。",
                "name": "result",
                "type": "{}"
            },
            {
                "comment": "修饰器列表。",
                "name": "decorators",
                "type": "@NodeList<@Decorator>"
            },
            {
                "comment": "(可能不存在)。",
                "name": "modifiers",
                "type": "@NodeList<@Modifier>"
            },
            {
                "comment": "类型。合法的值有：`any`、`number`、`boolean`、`string`、`symbol`、`void`、`never`、`this`、`null`、`undefined`、`char`、`byte`、`int`、`long`、`short`、`uint`、`ulong`、`ushort`、`float`、`double`、`*`、`?`。",
                "name": "type",
                "type": "TokenType"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个命名空间或模块声明。",
        "codes": [
            "@DocComment(result);",
            "if (decorators) result.decorators = decorators;",
            "if (modifiers) result.modifiers = modifiers;",
            "if (type === @namespace) result.namespaceToken = @readToken(type);",
            "else result.moduleToken = @readToken(type);",
            "if (type === 'module' && this.lexer.peek().type === 'stringLiteral') {",
            "\t(<@ModuleDeclaration>result).name = @StringLiteral();",
            "} else {",
            "\tresult.name = @Identifier();",
            "\twhile (this.lexer.peek().type === '.') {",
            "\t\tresult.name = @MemberCallExpression(result.name);",
            "\t}",
            "}",
            "@BlockBody(result);"
        ],
        "inline": true
    },
    "NamespaceDeclaration": {
        "region": "声明",
        "name": "NamespaceDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Decorators"
            },
            {
                "comment": "undefined。",
                "type": "Modifiers"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个命名空间声明(`namespace T {}`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前命名空间声明的(可能不存在)。",
                "equals": "@Decorators()",
                "type": "Decorators"
            },
            {
                "optional": true,
                "comment": "获取当前命名空间声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "name": "namespaceToken",
                "comment": "获取当前命名空间声明的namespaceToken 的位置。",
                "equals": "@readToken('namespace')",
                "type": "number",
                "tokens": [
                    "namespace"
                ]
            },
            {
                "name": "name",
                "comment": "获取当前命名空间声明的(可能不存在)。",
                "equals": "@Identifier | MemberCallExpression()",
                "type": "Identifier | MemberCallExpression"
            }
        ],
        "codes": [
            "BlockBody",
            "const result = new @NamespaceDeclaration();",
            "@NamespaceOrModuleDeclaration(result, decorators, modifiers, 'namespace');",
            "return result;"
        ],
        "classComment": "表示一个命名空间声明(`namespace T {}`)。"
    },
    "ModuleDeclaration": {
        "region": "声明",
        "name": "ModuleDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Decorators"
            },
            {
                "comment": "undefined。",
                "type": "Modifiers"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个模块声明(`module T {}`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前模块声明的(可能不存在)。",
                "equals": "@Decorators()",
                "type": "Decorators"
            },
            {
                "optional": true,
                "comment": "获取当前模块声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "name": "moduleToken",
                "comment": "获取当前模块声明的moduleToken 的位置。",
                "equals": "@readToken('module')",
                "type": "number",
                "tokens": [
                    "module"
                ]
            },
            {
                "name": "name",
                "comment": "获取当前模块声明的(可能不存在)。",
                "equals": "@Identifier | MemberCallExpression | StringLiteral()",
                "type": "Identifier | MemberCallExpression | StringLiteral"
            }
        ],
        "codes": [
            "BlockBody",
            "const result = new @ModuleDeclaration();",
            "@NamespaceOrModuleDeclaration(result, decorators, modifiers, 'module');",
            "return result;"
        ],
        "classComment": "表示一个模块声明(`module T {}`)。"
    },
    "BlockBody": {
        "region": "声明",
        "name": "BlockBody",
        "params": [
            {
                "comment": "存放结果的目标节点。",
                "name": "result",
                "type": "{statements?: { Statement ... }}"
            }
        ],
        "extends": "Node",
        "comment": "解析一个语句块主体(`{...}`)。",
        "parts": [
            {
                "name": "statements",
                "comment": "获取当前语句块主体的undefined。",
                "equals": "@NodeList(@Statement, '{', '}')",
                "type": "{ Statement ... }",
                "list": {
                    "element": "Statement",
                    "open": "{",
                    "close": "}",
                    "continue": "",
                    "seperator": "",
                    "optional": false,
                    "type": "@NodeList<@Statement>",
                    "equals": "@NodeList(@Statement, '{', '}')"
                }
            }
        ],
        "codes": [
            "result.statements = @NodeList(@Statement, '{', '}');"
        ],
        "inline": true,
        "classComment": "表示一个语句块主体(`{...}`)。"
    },
    "ExtensionDeclaration": {
        "region": "声明",
        "name": "ExtensionDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Decorators"
            },
            {
                "comment": "undefined。",
                "type": "Modifiers"
            }
        ],
        "doc": true,
        "extends": "Declaration",
        "comment": "解析一个扩展声明(`extends T {}`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前扩展声明的(可能不存在)。",
                "equals": "@Decorators()",
                "type": "Decorators"
            },
            {
                "optional": true,
                "comment": "获取当前扩展声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "name": "extendsToken",
                "comment": "获取当前扩展声明的extendsToken 的位置。",
                "equals": "@readToken('extends')",
                "type": "number",
                "tokens": [
                    "extends"
                ]
            },
            {
                "name": "type",
                "comment": "获取当前扩展声明的类型。合法的值有：`any`、`number`、`boolean`、`string`、`symbol`、`void`、`never`、`this`、`null`、`undefined`、`char`、`byte`、`int`、`long`、`short`、`uint`、`ulong`、`ushort`、`float`、`double`、`*`、`?`。",
                "equals": "@TypeNode()",
                "type": "TypeNode"
            },
            {
                "inlined": true,
                "name": "extendsToken",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "extends",
                "type": "ClassHeritageNode , ... isExpressionStart",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前扩展声明的(可能不存在)。",
                "equals": "@ExtendsClause()",
                "type": "ExtendsClause"
            },
            {
                "inlined": true,
                "name": "implementsToken",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": "implements",
                "type": "ClassHeritageNode , ... isExpressionStart",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前扩展声明的(可能不存在)。",
                "equals": "@ImplementsClause()",
                "type": "ImplementsClause"
            },
            {
                "inlined": true,
                "name": "members",
                "type": "{ ClassElement ... }",
                "comment": "(可能不存在)"
            },
            {
                "inlined": true,
                "name": ";Token",
                "type": "number",
                "comment": "(可能不存在)"
            },
            {
                "optional": true,
                "comment": "获取当前扩展声明的(可能不存在)。",
                "equals": "@ClassBody()",
                "type": "ClassBody"
            }
        ],
        "codes": [
            "const result = new @ExtensionDeclaration();",
            "result. = @Decorators();",
            "result. = @Modifiers();",
            "result.extendsToken = @readToken('extends');",
            "result.type = @TypeNode();",
            "result.extendsToken = undefined;",
            "result.extends = undefined;",
            "result. = @ExtendsClause();",
            "result.implementsToken = undefined;",
            "result.implements = undefined;",
            "result. = @ImplementsClause();",
            "result.members = undefined;",
            "result.;Token = undefined;",
            "result. = @ClassBody();",
            "return result;"
        ],
        "classComment": "表示一个扩展声明(`extends T {}`)。"
    },
    "DeclarationOrExpressionStatement": {
        "region": "声明",
        "name": "DeclarationOrExpressionStatement",
        "extends": "Expression",
        "comment": "解析一个声明或表达式语句。",
        "codes": [
            "const savedState = @stashSave();",
            "const decorators = @Decorators();",
            "const modifiers = @Modifiers();",
            "switch (this.lexer.peek().type) {",
            "\tcase 'function':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @FunctionDeclaration(decorators, modifiers);",
            "\tcase 'class':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @ClassDeclaration(decorators, modifiers);",
            "\tcase 'interface':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @InterfaceDeclaration(decorators, modifiers);",
            "\tcase 'enum':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @EnumDeclaration(decorators, modifiers);",
            "\tcase 'namespace':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @NamespaceDeclaration(decorators, modifiers);",
            "\tcase 'module':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @ModuleDeclaration(decorators, modifiers);",
            "\tcase 'extends':",
            "\t\t@stashClear(savedState);",
            "\t\treturn @ExtensionDeclaration(decorators, modifiers);",
            "\tdefault:",
            "\t\t@stashRestore(savedState);",
            "\t\treturn @ExpressionStatement(@Expression());",
            "}"
        ]
    },
    "Decorators": {
        "region": "声明",
        "name": "Decorators",
        "extends": "Node",
        "comment": "解析一个修饰器列表。",
        "parts": [
            {
                "name": "decorators",
                "comment": "获取当前修饰器列表的修饰器列表。",
                "equals": "@NodeList(@Decorator)",
                "type": "Decorator ...",
                "list": {
                    "element": "Decorator",
                    "open": "",
                    "close": "",
                    "continue": "",
                    "seperator": "",
                    "optional": false,
                    "type": "@NodeList<@Decorator>",
                    "equals": "@NodeList(@Decorator)"
                }
            }
        ],
        "codes": [
            "let result: @NodeList<@Decorator>;",
            "while (this.lexer.peek().type === '@') {",
            "\tif (!result) result = new @NodeList<@Modifier>();",
            "\tresult.push(@Decorator());",
            "}",
            "return result;"
        ],
        "classComment": "表示一个修饰器列表。"
    },
    "Decorator": {
        "region": "声明",
        "name": "Decorator",
        "extends": "Node",
        "comment": "解析一个修饰器(`@x`)。",
        "parts": [
            {
                "name": "@Token",
                "comment": "获取当前修饰器的@Token 的位置。",
                "equals": "@readToken('@')",
                "type": "number",
                "tokens": [
                    "@"
                ]
            },
            {
                "name": "body",
                "comment": "获取当前修饰器的主体部分。",
                "args": "Precedence.leftHandSide",
                "equals": "@Expression(Precedence.leftHandSide)",
                "type": "Expression"
            }
        ],
        "codes": [
            "const result = new @Decorator();",
            "result.@Token = @readToken('@');",
            "result.body = @Expression(Precedence.leftHandSide);",
            "return result;"
        ],
        "classComment": "表示一个修饰器(`@x`)。"
    },
    "Modifiers": {
        "region": "声明",
        "name": "Modifiers",
        "extends": "Node",
        "comment": "解析一个修饰符列表。",
        "parts": [
            {
                "name": "modifiers",
                "comment": "获取当前修饰符列表的(可能不存在)。",
                "equals": "@NodeList(@Modifier)",
                "type": "Modifier ...",
                "list": {
                    "element": "Modifier",
                    "open": "",
                    "close": "",
                    "continue": "",
                    "seperator": "",
                    "optional": false,
                    "type": "@NodeList<@Modifier>",
                    "equals": "@NodeList(@Modifier)"
                }
            }
        ],
        "codes": [
            "let result: @NodeList<@Modifier>;",
            "while (isModifier(this.lexer.peek().type)) {",
            "\tconst savedToken = @lexer.current;",
            "\tconst modifier = @Modifier();",
            "\tswitch (modifier.type) {",
            "\t\tcase 'export':",
            "\t\t\tif (!result) result = new @NodeList()<@Modifier>();",
            "\t\t\tresult.push(modifier);",
            "\t\t\tif (this.lexer.peek().type === 'default') {",
            "\t\t\t\tresult.push(@Modifier());",
            "\t\t\t}",
            "\t\t\tcontinue;",
            "\t\tcase 'const':",
            "\t\t\tif (this.lexer.peek().type === 'enum') {",
            "\t\t\t\tif (!result) result = new @NodeList()<@Modifier>();",
            "\t\t\t\tresult.push(modifier);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tif (@sameLine) {",
            "\t\t\t\tif (!result) result = new @NodeList()<@Modifier>();",
            "\t\t\t\tresult.push(modifier);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t}",
            "\t@lexer.current = savedToken;",
            "\tbreak;",
            "}",
            "return result;"
        ],
        "classComment": "表示一个修饰符列表。"
    },
    "Modifier": {
        "region": "声明",
        "name": "Modifier",
        "extends": "Node",
        "comment": "解析一个修饰符(`static`、`private`、...)。",
        "parts": [
            {
                "name": "type",
                "comment": "获取当前修饰符的type 的位置。合法的值有：`export`、`default`、`declare`、`const`、`static`、`abstract`、`readonly`、`async`、`public`、`protected`、`private`。",
                "equals": "@read",
                "type": "number",
                "tokens": [
                    "export",
                    "default",
                    "declare",
                    "const",
                    "static",
                    "abstract",
                    "readonly",
                    "async",
                    "public",
                    "protected",
                    "private"
                ]
            }
        ],
        "codes": [
            "const result = new @Modifier();",
            "result.type = @read;",
            "return result;"
        ],
        "classComment": "表示一个修饰符(`static`、`private`、...)。"
    },
    "TypeAliasDeclaration": {
        "region": "声明",
        "name": "TypeAliasDeclaration",
        "extends": "Declaration",
        "comment": "解析一个类型别名声明(`type A = number;`)。",
        "parts": [
            {
                "name": "typeToken",
                "comment": "获取当前类型别名声明的typeToken 的位置。",
                "equals": "@readToken('type')",
                "type": "number",
                "tokens": [
                    "type"
                ]
            },
            {
                "name": "name",
                "comment": "获取当前类型别名声明的(可能不存在)。",
                "equals": "@Identifier()",
                "type": "Identifier"
            },
            {
                "optional": true,
                "comment": "获取当前类型别名声明的(可能不存在)。",
                "equals": "@DelimitedList(@TypeParameterDeclaration, '<', '>', false, @isIdentifierName)",
                "type": "@NodeList<@TypeParameterDeclaration>"
            },
            {
                "name": "=Token",
                "comment": "获取当前类型别名声明的=Token 的位置。",
                "equals": "@readToken('=')",
                "type": "number",
                "tokens": [
                    "="
                ]
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前类型别名声明的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "TypeNode"
        ],
        "classComment": "表示一个类型别名声明(`type A = number;`)。"
    },
    "ImportAssignmentOrImportDeclaration": {
        "region": "声明",
        "name": "ImportAssignmentOrImportDeclaration",
        "extends": "Declaration",
        "comment": "解析一个import 赋值或 import 声明。",
        "codes": [
            "const importToken = @read;",
            "const imports = @DelimitedList(@ImportClause, undefined, undefined, isBindingNameStart);",
            "if (this.lexer.peek().type === '=' && imports.length === 1 && imports[0].constructor === @SimpleImportClause && (<@SimpleImportClause>imports[0]).name == null) {",
            "\treturn @ImportAssignmentDeclaration(importToken, (<@SimpleImportClause>imports[0]).variable);",
            "}",
            "return @ImportDeclaration(importToken, imports);"
        ]
    },
    "ImportAssignmentDeclaration": {
        "region": "声明",
        "name": "ImportAssignmentDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "name": "importToken",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "variable",
                "type": "Identifier"
            }
        ],
        "extends": "Declaration",
        "comment": "解析一个import 赋值声明。",
        "parts": [
            {
                "name": "importToken",
                "comment": "获取当前import 赋值声明的importToken 的位置。",
                "equals": "importToken",
                "type": "number",
                "tokens": [
                    "import"
                ]
            },
            {
                "name": "variable",
                "comment": "获取当前import 赋值声明的别名。",
                "equals": "variable",
                "type": "Identifier"
            },
            {
                "name": "=Token",
                "comment": "获取当前import 赋值声明的=Token 的位置。",
                "equals": "@readToken('=')",
                "type": "number",
                "tokens": [
                    "="
                ]
            },
            {
                "name": "value",
                "comment": "获取当前import 赋值声明的值。",
                "args": "Precedence.assignment",
                "equals": "@Expression(Precedence.assignment)",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前import 赋值声明的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "const result = new @ImportAssignmentDeclaration();",
            "result.importToken = importToken;",
            "result.variable = variable;",
            "result.=Token = @readToken('=');",
            "result.value = @Expression(Precedence.assignment);",
            "if (@peek === ';') result.;Token = @readToken(';');",
            "return result;"
        ],
        "classComment": "表示一个import 赋值声明。"
    },
    "ImportDeclaration": {
        "region": "声明",
        "name": "ImportDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "name": "importToken",
                "type": "number"
            },
            {
                "comment": "undefined。",
                "name": "variables",
                "type": "ImportClause , ..."
            }
        ],
        "extends": "Declaration",
        "comment": "解析一个import 声明(`import x from '...';`)。",
        "parts": [
            {
                "name": "importToken",
                "comment": "获取当前import 声明的importToken 的位置。",
                "equals": "importToken",
                "type": "number",
                "tokens": [
                    "import"
                ]
            },
            {
                "optional": true,
                "name": "variables",
                "comment": "获取当前import 声明的(可能不存在)。",
                "equals": "@DelimitedList(@ImportClause)",
                "type": "ImportClause , ...",
                "list": {
                    "element": "ImportClause",
                    "open": "",
                    "close": "",
                    "continue": "",
                    "seperator": ",",
                    "optional": false,
                    "type": "@NodeList<@ImportClause>",
                    "equals": "@DelimitedList(@ImportClause)"
                }
            },
            {
                "optional": true,
                "comment": "获取当前import 声明的(可能不存在)。",
                "equals": "imports ? @readToken(@from) : undefined",
                "type": "'from' "
            },
            {
                "name": "from",
                "comment": "获取当前import 声明的导入模块名。",
                "equals": "@StringLiteral()",
                "type": "StringLiteral"
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前import 声明的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "const result = new @ImportDeclaration();",
            "if (variables) {",
            "\tresult.variables = variables;",
            "\tresult.fromToken = @readToken('from');",
            "}",
            "result.from = @StringLiteral();",
            "return result;"
        ],
        "classComment": "表示一个import 声明(`import x from '...';`)。"
    },
    "ImportClause": {
        "region": "声明",
        "name": "ImportClause",
        "extends": "Node",
        "alias": "SimpleImportOrExportClause | NamespaceImportClause | NamedImportClause",
        "comment": "解析一个import 分句(`x`、`{x}`、...)。",
        "codes": [
            "switch (this.lexer.peek().type) {",
            "\t//+ case 'identifier':",
            "\t//+\t\treturn @SimpleImportOrExportClause(true);",
            "\tcase '*':",
            "\t\treturn @NamespaceImportClause();",
            "\tcase '{':",
            "\t\treturn @NamedImportClause();",
            "\tdefault:",
            "\t\treturn @SimpleImportClause();",
            "}"
        ]
    },
    "NamespaceImportClause": {
        "region": "声明",
        "name": "NamespaceImportClause",
        "extends": "Node",
        "comment": "解析一个命名空间导入分句(`* as x`)。",
        "parts": [
            {
                "name": "variable",
                "comment": "获取当前命名空间导入分句的(可能不存在)。",
                "equals": "@Identifier()",
                "type": "Identifier"
            }
        ],
        "codes": [
            "*",
            "as"
        ],
        "classComment": "表示一个命名空间导入分句(`* as x`)。"
    },
    "NamedImportClause": {
        "region": "声明",
        "name": "NamedImportClause",
        "extends": "Node",
        "comment": "解析一个对象导入分句(`{x, x as y}`)。",
        "parts": [
            {
                "name": "elements",
                "comment": "获取当前对象导入分句的所有元素。",
                "equals": "@DelimitedList(@SimpleImportOrExportClause, '{', '}')",
                "type": "{ SimpleImportOrExportClause , ... }",
                "list": {
                    "element": "SimpleImportOrExportClause",
                    "open": "{",
                    "close": "}",
                    "continue": "",
                    "seperator": ",",
                    "optional": false,
                    "type": "@NodeList<@SimpleImportOrExportClause>",
                    "equals": "@DelimitedList(@SimpleImportOrExportClause, '{', '}')"
                }
            }
        ],
        "codes": [
            "const result = new @NamedImportClause();",
            "result.elements = @DelimitedList(@SimpleImportClause, '{', '}', isIdentifierName);",
            "return result;"
        ],
        "classComment": "表示一个对象导入分句(`{x, x as y}`)。"
    },
    "SimpleImportClause": {
        "region": "声明",
        "name": "SimpleImportClause",
        "extends": "Node",
        "comment": "解析一个简单导入分句。",
        "codes": [
            "return @SimpleImportOrExportClause(true);"
        ]
    },
    "SimpleImportOrExportClause": {
        "region": "声明",
        "name": "SimpleImportOrExportClause",
        "params": [
            {
                "comment": "解析 import 分句。",
                "name": "importClause",
                "type": "boolean"
            }
        ],
        "extends": "Node",
        "comment": "解析一个简单导入或导出分句(`x`、`x as y`)。",
        "parts": [
            {
                "optional": true,
                "name": "name",
                "comment": "获取当前简单导入或导出分句的导入或导出的名称(可能不存在)。",
                "args": "true",
                "equals": "@Identifier(true)",
                "type": "Identifier"
            },
            {
                "optional": true,
                "name": "asToken",
                "comment": "获取当前简单导入或导出分句的asToken 的位置(可能不存在)。",
                "equals": "@readToken('as')",
                "type": "number",
                "tokens": [
                    "as"
                ]
            },
            {
                "name": "variable",
                "comment": "获取当前简单导入或导出分句的导入或导出的变量。",
                "equals": "@Identifier()",
                "type": "Identifier"
            }
        ],
        "codes": [
            "const result = new @SimpleImportOrExportClause();",
            "const nameOrVariable = @Identifier(true);",
            "if (this.lexer.peek().type === @as) {",
            "\tresult.name = nameOrVariable;",
            "\tresult.asToken = @read;",
            "\tresult.variable = @Identifier(!importClause);",
            "} else {",
            "\tif (importClause && !isIdentifierName(@current)) {",
            "\t\t@error(@lexer.current, \"Identifier expected; Keyword '{0}' cannot be used as an identifier.\", getTokenName(@current));",
            "\t}",
            "\tresult.variable = nameOrVariable;",
            "}",
            "return result;"
        ],
        "classComment": "表示一个简单导入或导出分句(`x`、`x as y`)。"
    },
    "ExportAssignmentOrExportDeclaration": {
        "region": "声明",
        "name": "ExportAssignmentOrExportDeclaration",
        "extends": "Declaration",
        "comment": "解析一个export 赋值或 export 声明。",
        "codes": [
            "const savedState = @lexer.current;",
            "const exportToekn = @read;",
            "switch (this.lexer.peek().type) {",
            "\tcase 'function':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @FunctionDeclaration(undefined, @Modifiers());",
            "\tcase 'class':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @ClassDeclaration(undefined, @Modifiers());",
            "\tcase 'interface':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @InterfaceDeclaration(undefined, @Modifiers());",
            "\tcase 'enum':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @EnumDeclaration(undefined, @Modifiers());",
            "\tcase 'namespace':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @NamespaceDeclaration(undefined, @Modifiers());",
            "\tcase 'module':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @ModuleDeclaration(undefined, @Modifiers());",
            "\tcase 'var':",
            "\tcase 'let':",
            "\tcase 'const':",
            "\t\t@lexer.current = savedState;",
            "\t\treturn @VariableStatement(@Modifiers());",
            "\tcase '*':",
            "\t\treturn @ExportNamespaceDeclaration(exportToekn);",
            "\tcase '{':",
            "\t\treturn @ExportListDeclaration(exportToekn);",
            "\tcase '=':",
            "\t\treturn @ExportAssignmentDeclaration(start);",
            "\tdefault:",
            "\t\t// @lexer.current = savedState;",
            "\t\t// @error(this.lexer.peek().type, \"Declaration or statement expected. Unexpected token '{0}'.\", getTokenName(this.lexer.peek().type));",
            "\t\treturn @ExportDefaultDeclaration(@Modifiers());",
            "}"
        ]
    },
    "ExportNamespaceDeclaration": {
        "region": "声明",
        "name": "ExportNamespaceDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "name": "exportToken",
                "type": "number"
            }
        ],
        "extends": "Declaration",
        "comment": "解析一个导出列表声明(`export * from ...`)。",
        "parts": [
            {
                "name": "exportToken",
                "comment": "获取当前导出列表声明的exportToken 的位置。",
                "equals": "exportToken",
                "type": "number",
                "tokens": [
                    "export"
                ]
            },
            {
                "name": "*Token",
                "comment": "获取当前导出列表声明的*Token 的位置。",
                "equals": "@readToken('*')",
                "type": "number",
                "tokens": [
                    "*"
                ]
            },
            {
                "name": "fromToken",
                "comment": "获取当前导出列表声明的fromToken 的位置。",
                "equals": "@readToken('from')",
                "type": "number",
                "tokens": [
                    "from"
                ]
            },
            {
                "name": "from",
                "comment": "获取当前导出列表声明的导入模块名。",
                "equals": "@StringLiteral()",
                "type": "StringLiteral"
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前导出列表声明的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "const result = new @ExportNamespaceDeclaration();",
            "result.exportToken = exportToken;",
            "result.*Token = @readToken('*');",
            "result.fromToken = @readToken('from');",
            "result.from = @StringLiteral();",
            "if (@peek === ';') result.;Token = @readToken(';');",
            "return result;"
        ],
        "classComment": "表示一个导出列表声明(`export * from ...`)。"
    },
    "ExportListDeclaration": {
        "region": "声明",
        "name": "ExportListDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "name": "exportToken",
                "type": "number"
            }
        ],
        "extends": "Declaration",
        "comment": "解析一个导出列表声明(`export a from ...`)。",
        "parts": [
            {
                "name": "exportToken",
                "comment": "获取当前导出列表声明的exportToken 的位置。",
                "equals": "exportToken",
                "type": "number",
                "tokens": [
                    "export"
                ]
            },
            {
                "name": "variables",
                "comment": "获取当前导出列表声明的(可能不存在)。",
                "equals": "@NodeList(@SimpleImportOrExportClause, '{', '}')",
                "type": "{ SimpleImportOrExportClause ... }",
                "list": {
                    "element": "SimpleImportOrExportClause",
                    "open": "{",
                    "close": "}",
                    "continue": "",
                    "seperator": "",
                    "optional": false,
                    "type": "@NodeList<@SimpleImportOrExportClause>",
                    "equals": "@NodeList(@SimpleImportOrExportClause, '{', '}')"
                }
            },
            {
                "name": "fromToken",
                "comment": "获取当前导出列表声明的fromToken 的位置。",
                "equals": "@readToken('from')",
                "type": "number",
                "tokens": [
                    "from"
                ]
            },
            {
                "name": "from",
                "comment": "获取当前导出列表声明的导入模块名。",
                "equals": "@StringLiteral()",
                "type": "StringLiteral"
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前导出列表声明的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "const result = new @ExportListDeclaration();",
            "result.exportToken = exportToken;",
            "result.variables = @NodeList(@SimpleImportOrExportClause, '{', '}');",
            "result.fromToken = @readToken('from');",
            "result.from = @StringLiteral();",
            "if (@peek === ';') result.;Token = @readToken(';');",
            "return result;"
        ],
        "classComment": "表示一个导出列表声明(`export a from ...`)。"
    },
    "ExportAssignmentDeclaration": {
        "region": "声明",
        "name": "ExportAssignmentDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "name": "exportToken",
                "type": "number"
            }
        ],
        "extends": "Declaration",
        "comment": "解析一个导出赋值声明(`export = 1;`)。",
        "parts": [
            {
                "name": "exportToken",
                "comment": "获取当前导出赋值声明的exportToken 的位置。",
                "equals": "exportToken",
                "type": "number",
                "tokens": [
                    "export"
                ]
            },
            {
                "name": "=Token",
                "comment": "获取当前导出赋值声明的=Token 的位置。",
                "equals": "@readToken('=')",
                "type": "number",
                "tokens": [
                    "="
                ]
            },
            {
                "name": "value",
                "comment": "获取当前导出赋值声明的值。",
                "args": "Precedence.assignment",
                "equals": "@Expression(Precedence.assignment)",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前导出赋值声明的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "const result = new @ExportAssignmentDeclaration();",
            "result.exportToken = exportToken;",
            "result.=Token = @readToken('=');",
            "result.value = @Expression(Precedence.assignment);",
            "if (@peek === ';') result.;Token = @readToken(';');",
            "return result;"
        ],
        "classComment": "表示一个导出赋值声明(`export = 1;`)。"
    },
    "ExportDefaultDeclaration": {
        "region": "声明",
        "name": "ExportDefaultDeclaration",
        "params": [
            {
                "comment": "undefined。",
                "type": "Modifiers"
            }
        ],
        "extends": "Declaration",
        "comment": "解析一个export default 声明(`export default x = 1;`)。",
        "parts": [
            {
                "optional": true,
                "comment": "获取当前export default 声明的(可能不存在)。",
                "equals": "@Modifiers()",
                "type": "Modifiers"
            },
            {
                "name": "expression",
                "comment": "获取当前export default 声明的表达式部分。",
                "args": "Precedence.assignment",
                "equals": "@Expression(Precedence.assignment)",
                "type": "Expression"
            },
            {
                "optional": true,
                "name": ";Token",
                "comment": "获取当前export default 声明的;Token 的位置(可能不存在)。",
                "equals": "@readToken(';')",
                "type": "number",
                "tokens": [
                    ";"
                ]
            }
        ],
        "codes": [
            "const result = new @ExportDefaultDeclaration();",
            "result. = @Modifiers();",
            "result.expression = @Expression(Precedence.assignment);",
            "if (@peek === ';') result.;Token = @readToken(';');",
            "return result;"
        ],
        "classComment": "表示一个export default 声明(`export default x = 1;`)。"
    },
    "DocComment": {
        "region": "文档注释",
        "name": "DocComment",
        "params": [
            {
                "comment": "存放结果的目标节点。",
                "name": "result",
                "type": "{}"
            }
        ],
        "extends": "Node",
        "comment": "解析一个文档注释。",
        "inline": true
    }
}