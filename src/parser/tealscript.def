
# 类型

TypeNode() @abstract // 类型节点(`number`、`string[]`、...)
	let result = @UnaryOrPrimaryTypeNode(allowIn);
	while (getPrecedence(@peek) >= precedence) {
		result = @BinaryOrCallTypeNode(result, allowIn);
	}
	return result;

BinaryOrPrimaryTypeNode(precedence: Precedence) // 联合或交错或独立类型节) {
			UnionTypeNode // 

		}
	}
	@BinaryTypeNode(%) // 双目表达式(x + y、x = y、...)
		left: TypeNode // 左值部分
		operator:TokenType // 当前运算的类型。合法的值有：,、*=、/=、%=、+=、‐=、<<=、>>=、>>>=、&=、^=、|=、**=、||、&&、|、^、&、==、!=、===、!==、<、>、<=、>=、instanceof、in、<<、>>、>>>、+、-、*、/、%、** 
		right: TypeNode(getPrecedence(result.operator) + (isRightHandOperator(result.operator) ? 0 : 1), allowIn)

UnaryOrPrimaryTypeNode // 单目或独立类型节*
	
*FunctionOrParenthesizedTypeNode // 函数或括号类型节点
	const parameters = @tryParseParameters();
	if (parameters) {
		return @FunctionTypeNode(undefined, parameters);
	}
	return @ParenthesizedTypeNode();

FunctionTypeNode(., .) // 函数类型节点(`()=>void`)
	TypeParameters[opt] Parameters[opt] => TypeNode

TypeParameters
	NodeList<TypeParameterDeclaration>()

TypeParameterDeclaration // 类型参数声明(`T`、`T extends R`)
	name:BindingIdentifier @if extends[opt] extends:TypeNode @endif

Parameters: NodeList<ParameterDeclaration>

ConstructorType // 构造函数类型节点(`new () => void`)。
	new TypeParameters[opt] Parameters => return:TypeNode

# 表达式

Expression(precedence: Precedence/*允许解析的最低操作符优先级*/, allowIn: boolean/*是否允许解析 in 表达式*/) @abstract // 表达式
	let result: nodes.Expression;
	switch (@peek) {
		case @<identifier>:
			result = @ArrowFunctionOrGenericExpressionOrIdentifier();
			break;
			@ArrowFunctionOrGenericExpressionOrIdentifier // 箭头或泛型表达式或标识符
				switch (@peek) {
					case @=>:
						result = @ArrowFunctionExpression(undefined, undefined, result);
						break;
					case @<:
						const saved = @stashSave();
						const arguments = @TypeArguments();
						if (@current === @>) {
							@stashClear(saved);
							result = @GenericExpression(result, arguments);
						} else {
							@stashRestore(saved);
						}
						break;
				}
				return result;
			@GenericExpression(*, *) // 泛型表达式(`value<number>`)
				target: Identifier // 目标部分
				typeArguments: TypeArguments 
			@Identifier // 标识符(`x`)
				value:: <identifier> // 值部分
		case @<this>:
		case @<null>:
		case @<true>:
		case @<false>:
		case @<super>:
			result = @SimpleLiteral();
			break;
			@SimpleLiteral // 简单字面量(`null`、`true`、`false`、`this`、`super`)
				type: <this>|<null>|<true>|<false>|<super> // 类型
		case @( === @{ ? @BlockStatement() : @Expression(Precedence.assignment, allowIn)
				@ParenthesizedExpression // 括号表达式(`(x)`)
					(
					body: Expression(Precedence.any, true) // 主体部分
					)
		cae @<numericLiteral:
			result = @NumericLiteral();
			break;
			@NumericLiteral // 数字字面量(`1`)
				value: <numericLiteral>
		case @<stringLiteral>:
		case @<noSubstitutionTemplateLiteral>:
			result = @StringLiteral();
			break;
			@StringLiteral // 字符串字面量(`'abc'`、`"abc"`、`\`abc\``)
				value: <stringLiteral>
		case @[:
			result = @ArrayLiteral();
			break;
			@ArrayLiteral // 数组字面量(`[x, y]`)
				elements: [ ArrayLiteralElement,... ] // 所以元素
				@ArrayLiteralElement // 数组字面量元素(`x`)
					...?
					value?: Expression(Precedence.assignment, true)
		case @{:
			result = @ObjectLiteral();
			break;
			@ObjectLiteral // 对象字面量(`{x: y}`)
				elements: { PropertyDefinition,... }
		case @function));
					return ErrorIdentifier();
		case @new:expected.");
						result.end = @lexer.current.end;
					}
					return result;
				@NewExpression(*) : // new 表达式(`new x()`)。
					new
					target: Expression(Precedence.member, false) 
					?arguments: Arguments
		case @/:
		case @/=:	result.end = @lexer.current.end;
	        	return result;
		case @<templateHead>)
					value: <stringLiteral>
		ase @<:
			result = @ArrowFunctionOrTypeAssertionExpression();
			brak;
			@ArrowFunctionOrTypeAssertionExpression // 箭头函数或类型确认表达式
				const saved = @stashSave();
				const typeParameters = @TypeParameters();
				if (@peek === @() {
					const parameters = @Parameters();
					if (@peek === @=> || @peek === @:) {
						@stashClear(saved);
						return @ArrowFunctionExpression(undefined, typeParameters, parameters, allowIn);
					}
				}
				return @TypeAssertionExpression();
				@TypeAssertionExpression // 类型确认表达式(<T>xx)
					<
					type: TypeNode(Precedence.any)
					>
					operand: Expression(Precedence.postfix, false)
		case @<yield>:
			result = @YieldExpression();
			break;
			@YieldExpression // yield 表达式(`yield xx`)) {
						result.operand = @Expression(Precedence.assignment, false);
					}
				}
				return result;
		case @<await>:
			result = @AwaitExpression();
			break;
			@AwaitExpression // wait 表达式(`await xx`)) {
					result.operand = @Expression(Precedence.assignment, false);
				}
				return result;
		case @<class>:
			result = @ClassExpression();
			break;
			@ClassExpression // 类表达式(`class xx {}`)。
				class 
				name?: IdentifierOrReserverdWord 
				?TypeParameterDeclarations
				?ClassTail
				?ClassBody
			// todo
		case @<async>:
			result = @AsyncFunctionExpressionOrIdentifier();
			break;
			@AsyncArrowFunctionOrIdentifier // 异步函数表达式或标识符
				const saved = @stashSave();
				const modifiers = @Modifiers();
				if (@sameLine && (@peek === @( || @peek === @<identifier> || isReserverdWord(@peek))) {
					const parameters = @peek === @( ? @Parameters() : @Identifier();
					if (@peek === @=> || @peek === @:) {
						@stashClear(saved);
						return @ArrowFunctionExpression(undefined, typeParameters, parameters, allowIn);
					}
				}
		case @=>:
			return @ArrowFunctionExpression(undefined, undefined, undefined, allowIn);
	}
	if (isUnaryOperator(@peek)) {
		return @UnaryExpression();
	}
	if (isReserverdWord(@peek)) {
		if (@options.strictMode) {
			@error(@peek, "Expression expected. '{0}' is a reserved word in strict mode.", tokenToString(@peek));
		}
		return @ArrowFunctionOrGenericExpressionOrIdentifier();
	}
	return @ErrorExpression();
	@UnaryExpression // 一元运算表达式(+x、typeof x、...)
		operator:: delete | void | typeof | + | - | ~ | ! | ++ | -- 
		operand: Expression(Precedence.postfix, false)
	while (getPrecedence(@peek) >= precedence) {
		// BUG: 如果ConditionalOrBinaryOrCallExpression 不解析出任何东西，则可能导致死循环 
		result = @ConditionalOrBinaryOrCallExpression(result, allowIn);
	}
	return result;


ConditionalOrBinaryOrCallExpression(parsed: Expression, allowIn: boolean) // 条件或双目或调用表达式
	switch (@peek) {
		MemberCallExpression(*) // 成员调用表达式(x.y)
			target: Expression // 目标部分
			. 
			argument: IdentifierOrKeyword // 参数部分
		case @=:
			break;
		case @(:
			return @FunctionCallExpression(parsed);
			@FunctionCallExpression(*) // 函数调用表达式(x())
				target: Expression 
				arguments: CallArguments
				@CallArguments // 函数调用参数列表
					( Argument,... )
					@CallArgument // 函数调用参数(x)
						...? 
						value: Expression(Precedence.assignment, true)
		IndexCallExpression(*) // 索引调用表达式(x[y])
			target:Expression 
			[ 
			argument: Expression(Precedence.any, true)
			]
		ConditionalExpression(*) // 条件表达式(`x ? y : z`)
			condition:Expression 
			? 
			then: Expression(Precedence.assignment, true) // 则部分 
			: 
			else: Expression(Precedence.assignment, allowIn) // 否则部分
		case ++:
		case --:
			if (@sameLine) {
				return @PostfixExpression(parsed);
			}
			break;
			@PostfixExpression(*) // 后缀表达式(`x++`、`x--`)
				operand: Expression(Precedence.leftHandSide) // 操作数
				operator:: ++ | --
		case in:
			if(allowIn === false) {
				return parsed;
			}
			break;
		case <noSubstitutionTemplateLiteral>:
			return @TemplateCallExpression(parsed, @StringLiteral());
		case <templateHead>:
			return @TemplateCallExpression(parsed, @TemplateLiteral());
			@TemplateCallExpression(*, *) // 模板调用表达式(`x\`abc\``)
				target: Expression 
				argument: TemplateLiteral | StringLiteral
	}
	return @BinaryExpression(parsed, allowIn);
	@BinaryExpression(*, *llowIn: boolean) // 双目表达式(x + y、x = y、...)
		left: Expression // 左值部分
		operator:TokenType // 当前运算的类型。合法的值有：,、*=、/=、%=、+=、‐=、<<=、>>=、>>>=、&=、^=、|=、**=、||、&&、|、^、&、==、!=、===、!==、<、>、<=、>=、instanceof、in、<<、>>、>>>、+、-、*、/、%、** 
		right: Expression(getPrecedence(result.operator) + (isRightHandOperator(result.operator) ? 0 : 1), allowIn) // 右值部分

# 语句

Statement: @abstract // 语句
	switch(@peek) {
		case <identifier>: return @LabeledOrExpressionStatement(@Identifier());
		case this:
		BlockStatement: // 语句块(`{...}`)
			{ statements:Statement... }
		case var: return @VariableStatement();
		case let: 
		case const:
			if (@isVariableStatement()) {
				return @parseVariableStatement();
			}
			break;
			@VariableStatement: // 变量声明语句(`var x`、`let x`、`const x`)
				type:var|let|const variables:VariableDeclaration,...
		FunctionDeclaration:
		ClassDeclaration:

		EmptyStatement: // 空语句(`;`)
			;
		IfStatement: // if 语句(`if(x) ...`)
			if ( condition:Expression ) then:Statement=@EmabledStatement() @if else else:Statement=@EmabledStatement() @endif
		SwitchStatement: // switch 语句(`switch(x) {...}`)
			switch ( condition:Expression ) { CaseClause... }
		ForStatement:
		WhileStatement:
		ExpressionStatement[?Yield]
		BreakableStatement[?Yield, ?Return]
		ContinueStatement[?Yield]
		BreakStatement[?Yield]
		ReturnStatement[?Yield]
		WithStatement[?Yield, ?Return]
		LabelledStatement[?Yield, ?Return]
		ThrowStatement[?Yield]
		TryStatement[?Yield, ?Return]
		DebuggerStatement
	}






			@ClassTail @inline
				ClassHeritage ? { ClassBody ? }
			@ClassHeritage[Yield] :
				extends LeftHandSideExpression
			@ClassBody[Yield] :
				ClassElementList
					ClassElementList ClassElement
					ClassElement
						MethodDefinition
						static MethodDefinition
						;



				@ObjectLiteralElement // 对象字面量元素(`x: y`)
					key: PropertyName 
					?: 
					?value: Expression(Precedence.assignment, true)
					const result = new nodes.ObjectLiteralElement();
					result.key = @PropertyName();
					if(@peek === @:) {
						result.colonToken = @read();
						result.value = @Expression(Precedence.assignment, true);
					} else if(result.key.constructor !== nodes.Identifier && result.key.constructor !== nodes.MemberCallExpression) {
						@expectToken(@:);
					}
					return result;
					@PropertyName // 表示一个属性名称(`xx`、`"xx"`、`0`、`[xx]`)
						= Identifier | NumericLiteral | StringLiteral | ComputedPropertyName | ErrorExpression
						switch (@peek) {
							case @<identifier>:
								return @Identifier();
							case @<stringLiteral>:
								return @StringLiteral();
							case @<numericLiteral>:
								return @NumericLiteral();
							case @[:
								return @ComputedPropertyName();
								@ComputedPropertyName // 已计算的属性名(`[1]`)
									[ 
									body: Expression(Precedence.assignment, true) 
									]
							default:
								if (@isKeyword(@peek)) {
									return @Identifier();
								}
								@error(@peek, "应输入属性名。");
								return @ErrorExpression(); // TODO
						}
			@ArrowExpression(allowIn: boolean): // 箭头表达式
				=>
				body: Expression(Precedence.assignment, allowIn)