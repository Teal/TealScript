
# 类型

TypeNode(precedence: Precedence) @abstract // 类型节点(`number`、`string[]`、...)
	let result = @UnaryOrPrimaryTypeNode();
	while(getPrecedence(@peek) >= precedence) {
		result = @TypeNodeRest(result, precedence);
	}
	return result;

UnaryOrPrimaryTypeNode // 单目或独立类型节点
	switch(@peek) {
		case (: return @FunctionOrParenthesizedTypeNode;
		case <: return @FunctionTypeNode(@TypeParameters, @Parameters);
		ConstructorType
	}

TypeNodeRest(parsed: TypeNode, precedence: Precedence) // 类型节点的剩余部分
	switch(@peek) {

	}

FunctionOrParenthesizedTypeNode // 函数或括号类型节点
	const parameters = @tryParseParameters();
	if (parameters) {
		return @FunctionTypeNode(undefined, parameters);
	}
	return @ParenthesizedTypeNode();

FunctionTypeNode(., .) // 函数类型节点(`()=>void`)
	TypeParameters[opt] Parameters[opt] => TypeNode

TypeParameters
	NodeList<TypeParameterDeclaration>()

TypeParameterDeclaration // 类型参数声明(`T`、`T extends R`)
	name:BindingIdentifier @if extends[opt] extends:TypeNode @endif

Parameters: NodeList<ParameterDeclaration>

ConstructorType // 构造函数类型节点(`new () => void`)。
	new TypeParameters[opt] Parameters => return:TypeNode

# 语句

Statement: @abstract // 语句
	switch(@peek) {
		case <identifier>: return @LabeledOrExpressionStatement();
		case this:
		BlockStatement: // 语句块(`{...}`)
			{ statements:Statement... }
		case var: return @VariableStatement();
		case let: 
		case const:
			if (@isVariableStatement()) {
				return @parseVariableStatement();
			}
			break;
			@VariableStatement: // 变量声明语句(`var x`、`let x`、`const x`)
				type:var|let|const variables:VariableDeclaration,...
		FunctionDeclaration:
		ClassDeclaration:

		EmptyStatement:
		IfStatement:
		SwitchStatement:
		ForStatement:
		WhileStatement:
		ExpressionStatement[?Yield]
		BreakableStatement[?Yield, ?Return]
		ContinueStatement[?Yield]
		BreakStatement[?Yield]
		ReturnStatement[?Yield]
		WithStatement[?Yield, ?Return]
		LabelledStatement[?Yield, ?Return]
		ThrowStatement[?Yield]
		TryStatement[?Yield, ?Return]
		DebuggerStatement
	}

