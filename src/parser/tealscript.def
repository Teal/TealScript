
# 类型

TypeNode @abstract // 类型节点(`number`、`string[]`、...)
	let result = @UnaryOrPrimaryTypeNode(allowIn);
	while (getPrecedence(@peek) >= precedence) {
		result = @BinaryOrCallTypeNode(result, allowIn);
	}
	return result;

BinaryOrPrimaryTypeNode(precedence: Precedence) // 联合或交错或独立类型节) {
			UnionTypeNode // 

		}
	}
	@BinaryTypeNode(%) // 双目表达式(x + y、x = y、...)
		left: TypeNode // 左值部分
		operator:TokenType // 当前运算的类型。合法的值有：,、*=、/=、%=、+=、‐=、<<=、>>=、>>>=、&=、^=、|=、**=、||、&&、|、^、&、==、!=、===、!==、<、>、<=、>=、instanceof、in、<<、>>、>>>、+、-、*、/、%、** 
		right: TypeNode(getPrecedence(result.operator) + (isRightHandOperator(result.operator) ? 0 : 1), allowIn)

UnaryOrPrimaryTypeNode // 单目或独立类型节*
	
*FunctionOrParenthesizedTypeNode // 函数或括号类型节点
	const parameters = @tryParseParameters();
	if (parameters) {
		return @FunctionTypeNode(undefined, parameters);
	}
	return @ParenthesizedTypeNode();

FunctionTypeNode(., .) // 函数类型节点(`()=>void`)
	TypeParameters[opt] Parameters[opt] => TypeNode

TypeParameters
	NodeList<TypeParameterDeclaration>()

TypeParameterDeclaration // 类型参数声明(`T`、`T extends R`)
	name:BindingIdentifier @if extends[opt] extends:TypeNode @endif

Parameters: NodeList<ParameterDeclaration>

ConstructorType // 构造函数类型节点(`new () => void`)。
	new TypeParameters[opt] Parameters => return:TypeNode

# 表达式

Expression(precedence: Precedence/*允许解析的最低操作符优先级*/, allowIn: boolean/*是否允许解析 in 表达式*/) @abstract // 表达式
	let result: nodes.Expression;
	switch (@peek) {
		case @<identifier>: // x => y、x<T>、x
			result = @ArrowFunctionOrGenericExpressionOrIdentifier();
			break;
			@ArrowFunctionOrGenericExpressionOrIdentifier // 箭头或泛型表达式或标识符
				switch (@peek) {
					case @=>:
						result = @ArrowFunctionExpression(undefined, undefined, result);
						break;
					case @<:
						const savedState = @stashSave();
						const arguments = @TypeArguments();
						if (@current === @>) {
							@stashClear(savedState);
							result = @GenericExpression(result, arguments);
						} else {
							@stashRestore(savedState);
						}
						break;
				}
				return result;
				@GenericExpression(*, *) // 泛型表达式(`value<number>`)
					target: Identifier // 目标部分
					typeArguments: TypeArguments 
				@Identifier // 标识符(`x`)
					value: <identifier> // 值部分
		case @<this>:
		case @<null>:
		case @<true>:
		case @<false>:
		case @<super>:
			result = @SimpleLiteral();
			break;
			@SimpleLiteral // 简单字面量(`null`、`true`、`false`、`this`、`super`)
				type: <this>|<null>|<true>|<false>|<super> // 类型
		case @(: // (x) => ...、(x)
			result = @ArrowFunctionOrParenthesizedExpression();
			break;
			@ArrowFunctionOrParenthesizedExpression // 括号或箭头表达式
				const savedState = @stashSave();
				const parameters = @Parameters();
				return @peek === @=> || @peek === @: ? @ArrowFunctionLiteral(undefined, undefined, parameters, allowIn) : @ParenthesizedExpression();
				@ArrowFunctionLiteral(*, *, *, allowIn: boolean) // 箭头函数表达式(`x => xx`)。
					?Modifiers
					?TypeParameterDeclarations
					parameters?: ParameterDeclarations | Identifier // 参数部分
					ReturnType? 
					=> 
					body: BlockStatement | Expression = @peek === @{ ? @BlockStatement() : @Expression(Precedence.assignment, allowIn)
				@ParenthesizedExpression // 括号表达式(`(x)`)
					(
					body: Expression(Precedence.any, true) // 主体部分
					)
		case @<numericLiteral>:
			result = @NumericLiteral();
			break;
			@NumericLiteral // 数字字面量(`1`)
				value: <numericLiteral>
		case @<stringLiteral>:
		case @<noSubstitutionTemplateLiteral>:
			result = @StringLiteral();
			break;
			@StringLiteral // 字符串字面量(`'abc'`、`"abc"`、`\`abc\``)
				value: <stringLiteral>
		case @[:
			result = @ArrayLiteral();
			break;
			@ArrayLiteral // 数组字面量(`[x, y]`)
				elements: [ ArrayLiteralElement,... ] // 所以元素
				@ArrayLiteralElement // 数组字面量元素(`x`)
					...?
					value?: Expression(Precedence.assignment, true)
		case @{:
			result = @ObjectLiteral();
			break;
			@ObjectLiteral // 对象字面量(`{x: y}`)
				elements: { PropertyDefinition,... }
		case @function:
			result = @FunctionExpression(undefined);
			break;
			@FunctionExpression(*) // 函数表达式(`function () {}`)
				?Modifiers
				function
				?* 
				name?: Identifier = @readIdentifier(false);
				?TypeParameters
				Parameters
				?ReturnType
				body: BlockStatement | ArrowExpression = @peek === @=> ? @ArrowExpression(allowIn) : @BlockStatement()
				@readIdentifier(allowKeyword: boolean) // 读取一个标识符
					if (@peek === @<identifier>) {
						return @Identifier();
					}
					if (isReserverdWord(@peek)) {
						if (options.strictMode) {
							@error(@lexer.peek(), "Identifier expected. '{0}' is a reserved word in strict mode.", tokenToString(@peek));
						}
						return @Identifier();
					}
					@error(@lexer.peek(), isKeyword(@peek) ? "Identifier expected. '{0}' is a keyword." : "Identifier expected.", tokenToString(@peek));
					return ErrorIdentifier();
		case @new:
			result = @NewTargetOrNewExpression();
			break;
			@NewTargetOrNewExpression // new.target 或 new 表达式
				const start = @read();
				return @peek === @. ? @NewTargetExpression(start) : @NewExpression(start);
				@NewTargetExpression(*) // new.target 表达式(`new.target`)
					new 
					.
					target
					const result = new nodes.NewTargetExpression();
					result.start = start;
					result.dotToken = @readToken(@.);
					if (@peek === @<identifier> && @lexer.peek().data === "target") {
						result.end = @lexer.read().end;
					} else {
						@error(@lexer.current, "Expression expected.");
						result.end = @lexer.current.end;
					}
					return result;
				@NewExpression(*) : // new 表达式(`new x()`)。
					new
					target: Expression(Precedence.member, false) 
					?arguments: Arguments
		case @/:
		case @/=:	
			result = @RegularExpressionLiteral();
			break;
			@RegularExpressionLiteral // 正则表达式字面量(/abc/)
				value: <stringLiteral> 
				flags?: <stringLiteral> // 标志部分
				const result = new nodes.RegularExpressionLiteral();
				result.start = @lexer.readAsRegularExpressionLiteral().start;
				result.value = @lexer.current.data.pattern;
	        	result.flags = @lexer.current.data.flags;
	        	result.end = @lexer.current.end;
	        	return result;
		case @<templateHead>:
			return @TemplateLiteral();
			@TemplateLiteral // 模板字面量(`\`abc\``)
				spans: TemplateSpan | Expression... // 所有组成部分
				const result = new nodes.TemplateLiteral();
				result.spans = new nodes.NodeList<nodes.Expression>();
				while (true) {
					result.spans.push(@TemplateSpan());
					result.spans.push(@Expression());
					if (@peek() !== @}) {
		                @expectToken(@});
		                break;
		            }
		            if (@lexer.readAsTemplateMiddleOrTail().type === @<templateTail>) {
		                result.spans.push(@TemplateSpan());
		                break;
		            }
				}
				return result;
				@TemplateSpan // 模板文本区块(`\`abc${`、`}abc${`、`}abc\``)
					value: <stringLiteral>
		case @<: // <T> (p)=>{}、<T>fn
			result = @ArrowFunctionOrTypeAssertionExpression();
			break;
			@ArrowFunctionOrTypeAssertionExpression // 箭头函数或类型确认表达式
				const savedState = @stashSave();
				const typeParameters = @TypeParameters();
				const parameters = @peek === @( ? @Parameters() : @peek === @<identifier> || isReserverdWord(@peek) : @Identifier() : undefined;
				if (parameters && (@peek === @=> || @peek === @:)) {
					@stashClear(savedState);
					return @ArrowFunctionExpression(undefined, typeParameters, parameters, allowIn);
				}
				@stashRestore(savedState);
				return @TypeAssertionExpression();
				@TypeAssertionExpression // 类型确认表达式(<T>xx)
					<
					type: TypeNode(Precedence.any)
					>
					operand: Expression(Precedence.postfix, false)
		case @<yield>:
			result = @YieldExpression();
			break;
			@YieldExpression // yield 表达式(`yield xx`)) {
				yield 
				?*
				operand: Expression(Precedence.assignment, false)
				const result = new nodes.YieldExpression();
				result.start = @read;
				if (@sameLine) {
					if (@peek === @*) {
						result.asteriskToken = @read;
					}
					if (@sameLine && isExpressionStart(@peek)) {
						result.operand = @Expression(Precedence.assignment, false);
					}
				}
				return result;
		case @<await>:
			result = @AwaitExpression();
			break;
			@AwaitExpression // wait 表达式(`await xx`)) {
				await 
				operand: Expression(Precedence.assignment, false)
				const result = new nodes.AwaitExpression();
				result.start = @read;
				if (@sameLine && isExpressionStart(@peek)) {
					result.operand = @Expression(Precedence.assignment, false);
				}
				return result;
		case @<class>:
			result = @ClassExpression();
			break;
			@ClassExpression // 类表达式(`class xx {}`)。
				class 
				name?: IdentifierOrReserverdWord 
				?TypeParameterDeclarations
				?ClassTail
				?ClassBody
			// todo
		case @<async>:
			result = @AsyncFunctionExpressionOrIdentifier(allowIn);
			break;
			@AsyncArrowFunctionOrIdentifier(allowIn: boolean) // 异步函数表达式或标识符
				const savedState = @stashSave();
				const modifiers = @Modifiers();
				const typeParameters = @sameLine && @peek === @< ? @TypeParameters() : undefined;
				if (@sameLine && (@peek === @( || @peek === @<identifier> || isReserverdWord(@peek))) {
					const parameters = @peek === @( ? @Parameters() : @readIdentifier();
					if (@peek === @=> || @peek === @:) {
						@stashClear(saved);
						return @ArrowFunctionExpression(modifiers, typeParameters, parameters, allowIn);
					}
				}
		case @=>:
			result = @ArrowFunctionExpression(undefined, undefined, undefined, allowIn);
			break;
		default:
			if (isUnaryOperator(@peek)) {
				result = @UnaryExpression();
				break;
			} 
			if (isReserverdWord(@peek)) {
				if (options.strictMode) {
					@error(@lexer.peek(), "Expression expected. '{0}' is a reserved word in strict mode.", tokenToString(@peek));
				}
				result = @ArrowFunctionOrGenericExpressionOrIdentifier();
				break;
			}
			@error(@lexer.peek(), @peek == @) || @peek == @] || @peek == @} || @peek == @> ? "Unexpected token '{0}'." : @isKeyword(@peek) ? "Expression expected. '{0}' is a keyword." : "Expression expected.", tokenToString(@peek));
			return @ErrorIdentifier();
			@UnaryExpression // 一元运算表达式(+x、typeof x、...)
				operator: <delete>|<void>|<typeof>|<+>|<->|<~>|<!>|<++>|<-->
				operand: Expression(Precedence.postfix, false)
			@ErrorIdentifier @extends(Identifier) // 错误的标识符
				const result = new ErrorIdentifier();
				result.start = @lexer.current.end;
				return result;
	}
	while (getPrecedence(@peek) >= precedence) {
		switch (@peek) {
			case @.:
				result = @MemberCallExpression(result);
				continue;
				@MemberCallExpression(*) // 成员调用表达式(x.y)
					target: Expression // 目标部分
					. 
					argument: IdentifierOrKeyword // 参数部分
			case @=:
				result = @BinaryExpression(result, allowIn);
				continue;
			case @(:
				result = @FunctionCallExpression(result);
				continue;
				@FunctionCallExpression(*) // 函数调用表达式(x())
					target: Expression 
					arguments: CallArguments
					@CallArguments // 函数调用参数列表
						( Argument,... )
						@CallArgument // 函数调用参数(x)
							?...
							value: Expression(Precedence.assignment, true)
			case @[:
				result = @IndexCallExpression(result);
				continue;
				@IndexCallExpression(*) // 索引调用表达式(x[y])
					target:Expression 
					[ 
					argument: Expression(Precedence.any, true)
					]
			case @?:
				result = @ConditionalExpression(result);
				continue;
				@ConditionalExpression(*) // 条件表达式(`x ? y : z`)
					condition:Expression 
					? 
					then: Expression(Precedence.assignment, true) // 则部分 
					: 
					else: Expression(Precedence.assignment, allowIn) // 否则部分
			case @++:
			case @--:
				if (@sameLine) {
					result = @PostfixExpression(result);
					continue;
				}
				break;
				@PostfixExpression(*) // 后缀表达式(`x++`、`x--`)
					operand: Expression(Precedence.leftHandSide) // 操作数
					operator:: ++ | --
			case @<noSubstitutionTemplateLiteral>:
				return @TemplateCallExpression(parsed, @StringLiteral());
			case @<templateHead>:
				return @TemplateCallExpression(parsed, @TemplateLiteral());
				@TemplateCallExpression(*, *) // 模板调用表达式(`x\`abc\``)
					target: Expression 
					argument: TemplateLiteral | StringLiteral
			case @<in>:
				if(allowIn === false) {
					break;
				}
				// 继续往下执行
			default:
				result = @BinaryExpression(result, allowIn);
				continue;
				@BinaryExpression(*, *llowIn: boolean) // 双目表达式(x + y、x = y、...)
					left: Expression // 左值部分
					operator: <,>|<*=>|</=>|<%=>|<+=>|<‐=>|<<<=>|<>>=>|<>>>=>|<&=>|<^=>|<|=>|<**=>|<||>|<&&>|<|>|<^>|<&>|<==>|<!=>|<===>|<!==>|<<>|<>>|<<=>|<>=>|<instanceof>|<in>|<<<>|<>>>|<>>>>|<+>|<->|<*>|</>|<%>|<**> // 运算类型
					right: Expression(getPrecedence(result.operator) + (isRightHandOperator(result.operator) ? 0 : 1), allowIn) // 右值部分
		}
	}
	return result;

# 语句

Statement: @abstract // 语句
	switch(@peek) {
		case <identifier>: return @LabeledOrExpressionStatement(@Identifier());
		case this:
		BlockStatement: // 语句块(`{...}`)
			{ statements:Statement... }
		case var: return @VariableStatement();
		case let: 
		case const:
			if (@isVariableStatement()) {
				return @parseVariableStatement();
			}
			break;
			@VariableStatement: // 变量声明语句(`var x`、`let x`、`const x`)
				type:var|let|const variables:VariableDeclaration,...
		FunctionDeclaration:
		ClassDeclaration:

		EmptyStatement: // 空语句(`;`)
			;
		IfStatement: // if 语句(`if(x) ...`)
			if ( condition:Expression ) then:Statement=@EmabledStatement() @if else else:Statement=@EmabledStatement() @endif
		SwitchStatement: // switch 语句(`switch(x) {...}`)
			switch ( condition:Expression ) { CaseClause... }
		ForStatement:
		WhileStatement:
		ExpressionStatement[?Yield]
		BreakableStatement[?Yield, ?Return]
		ContinueStatement[?Yield]
		BreakStatement[?Yield]
		ReturnStatement[?Yield]
		WithStatement[?Yield, ?Return]
		LabelledStatement[?Yield, ?Return]
		ThrowStatement[?Yield]
		TryStatement[?Yield, ?Return]
		DebuggerStatement
	}



@isDeclarationStart() // 判断是否紧跟定义开始
		const savedState = @stashSave();
		while (@peek === @@) {
			@read();
			@Expression(Expression.leftHandSide, false)
		}
		const result = @sameLine && isDeclarationStart(@peek);
		@stashRestore(savedState);
		return result;


			@ClassTail @inline
				ClassHeritage ? { ClassBody ? }
			@ClassHeritage[Yield] :
				extends LeftHandSideExpression
			@ClassBody[Yield] :
				ClassElementList
					ClassElementList ClassElement
					ClassElement
						MethodDefinition
						static MethodDefinition
						;



				@ObjectLiteralElement // 对象字面量元素(`x: y`)
					key: PropertyName 
					?: 
					?value: Expression(Precedence.assignment, true)
					const result = new nodes.ObjectLiteralElement();
					result.key = @PropertyName();
					if(@peek === @:) {
						result.colonToken = @read();
						result.value = @Expression(Precedence.assignment, true);
					} else if(result.key.constructor !== nodes.Identifier && result.key.constructor !== nodes.MemberCallExpression) {
						@expectToken(@:);
					}
					return result;
					@PropertyName // 表示一个属性名称(`xx`、`"xx"`、`0`、`[xx]`)
						= Identifier | NumericLiteral | StringLiteral | ComputedPropertyName | ErrorExpression
						switch (@peek) {
							case @<identifier>:
								return @Identifier();
							case @<stringLiteral>:
								return @StringLiteral();
							case @<numericLiteral>:
								return @NumericLiteral();
							case @[:
								return @ComputedPropertyName();
								@ComputedPropertyName // 已计算的属性名(`[1]`)
									[ 
									body: Expression(Precedence.assignment, true) 
									]
							default:
								if (@isKeyword(@peek)) {
									return @Identifier();
								}
								@error(@peek, "应输入属性名。");
								return @ErrorExpression(); // TODO
						}
			@ArrowExpression(allowIn: boolean): // 箭头表达式
				=>
				body: Expression(Precedence.assignment, allowIn)


# 声明

Declaration() @abstract // 声明
	decorators: Decorator...
		@Decorator // 修饰器(`@x`、`@x()`)
			@
			body: Expression(Expression.leftHandSide, false)
	modifiers: Modifiers
		Modifier // 修饰符(`static`、`private`、...)
			type: <static>|<abstract>|<public>|<protected>|<private>|<const>
	name: Identifier
	typeParameters: TypeParameters

FunctionDeclaration(*, *, *) // 函数声明(`function fn() {...}`、`function * fn(){...}`)

@ImportAssignmentOrImportDeclaration // import 赋值或 import 声明
	const start = @read;
	let imports = @NodeList(@ImportClause, undefined, undefined, @,);
	if (@peek === @= && imports.length === 1 && imports[0].constructor === nodes.SimpleImportClause && (<nodes.SimpleImportClause>imports[0]).name == null) {
		return @ImportAssignmentDeclaration(start, (<nodes.SimpleImportClause>imports[0]).variable);
		@ImportAssignmentDeclaration(*, *) // import 赋值声明
			import
			variable: Identifier // 别名
			=
			value: Expression(Precedence.assignment, true)
			?;
	}
	return @ImportDeclaration(start, imports);
	@ImportDeclaration(*, *) // import 声明(`import xx from '...';`)
		import
		?names: ImportClause,...
		?from = imports ? @readToken(@from) : undefined
		target: StringLiteral // 导入模块名
		?;
		@ImportClause // import 分句
			= SimpleImportOrExportClause | NamespaceImportClause | NamedImportClause
			switch (@peek) {
				case @<identifier>:
					return @SimpleImportOrExportClause(false);
				case @*:
					return @NamespaceImportClause();
				case @{:
					return @NamedImportClause();
				default:
					return @SimpleImportOrExportClause(false);
			}
			@SimpleImportOrExportClause(exportClause: boolean) // 简单导入或导出分句(`a`、`a as b`)
				?name: Identifier // 导入或导出的名称
				?as 
				variable: Identifier // 导入或导出的变量
				const result = new nodes.SimpleImportOrExportClause();
				const nameOrVariable = @readIdentifier(true);
				if (@peek === @as) {
					result.name = nameOrVariable;
					result.asToken = @read;
					result.variable = @readIdentifier(exportClause);
				} else {
					if (!exportClause && isKeyword(@current) && !isReserverdWord(@current)) {
						@error(@current, "Identifier expected. '{0}' is a keyword.", tokenToString(@current));
					}
					result.variable = nameOrVariable;
				}
				return result;
			@NamespaceImportClause // 命名空间导入分句(* as d)
				*
				as
				variable: Identifier = @readIdentifier(false)
			@NamedImportClause // 对象导入分句(`{a, x as b}`)
				{ SimpleImportClause,... }
	
@ExportAssignmentOrExportDeclaration // export 赋值或 export 声明
	const start = @read;
	switch (@peek) {
		case @<function>:
			return @ExportDeclaration(start, undefined, FunctionDeclaration(undefined, undefined));
		case @<var>:
		case @<const>:
		case @<let>:
			return @ExportDeclaration(start, undefined, VariableStatement(read));
		case @=:
			return @ExportAssignmentDeclaration(start);
			@ExportAssignmentDeclaration(*) // 导出赋值声明(`export = 1;`)
				export
				=
				value: Expression(Precedence.assignment, true)
				?;
		case @{:
			return @ExportListDeclaration(start);
			@ExportListDeclaration(*) // 导出列表声明(`export a from ...`)
				export
				names: { SimpleImportOrExportClause... } = @NodeList(() => @SimpleImportOrExportClause(true), @{, @}, @,)
				from
				target: StringLiteral // 导入模块名
				?;
		case @*:
			return @ExportNamespaceDeclaration(start);
			@ExportNamespaceDeclaration(*) // 导出列表声明(`export * from ...`)
				export
				*
				from
				target: StringLiteral // 导入模块名
				?;
		case @<default>:
			return @ExportDeclaration(start, @read);
		default:
			return @ExportDeclaration(start, undefined);
		@ExportDeclaration(*, *) // export 声明(`export function fn() { }`)
			export
			?default
			body: Statement
	}

	
	
	
	

	
