
# 类型

TypeNode(precedence: Precedence) @abstract // 类型节点(`number`、`string[]`、...)
	let result = @UnaryOrPrimaryTypeNode();
	while(getPrecedence(@peek) >= precedence) {
		result = @TypeNodeRest(result, precedence);
	}
	return result;

UnaryOrPrimaryTypeNode // 单目或独立类型节点
	switch(@peek) {
		case (: return @FunctionOrParenthesizedTypeNode;
		case <: return @FunctionTypeNode(@TypeParameters, @Parameters);
		ConstructorType
	}

TypeNodeRest(parsed: TypeNode, precedence: Precedence) // 类型节点的剩余部分
	switch(@peek) {

	}

FunctionOrParenthesizedTypeNode // 函数或括号类型节点
	const parameters = @tryParseParameters();
	if (parameters) {
		return @FunctionTypeNode(undefined, parameters);
	}
	return @ParenthesizedTypeNode();

FunctionTypeNode(., .) // 函数类型节点(`()=>void`)
	TypeParameters[opt] Parameters[opt] => TypeNode

TypeParameters
	NodeList<TypeParameterDeclaration>()

TypeParameterDeclaration // 类型参数声明(`T`、`T extends R`)
	name:BindingIdentifier @if extends[opt] extends:TypeNode @endif

Parameters: NodeList<ParameterDeclaration>

ConstructorType // 构造函数类型节点(`new () => void`)。
	new TypeParameters[opt] Parameters => return:TypeNode

# 表达式

Expression(precedence: Precedence/*最低允许解析的优先级*/, disdisallowIn: boolean/*是否禁止解析 in 表达式*/) @abstract // 表达式。
	return @ExpressionRest(@UnaryOrPrimaryExpression(), precedence, disallowIn);

UnaryOrPrimaryExpression // 单目或独立表达式


ExpressionRest(parsed: Expression, precedence: Precedence, disallowIn: boolean) // 表达式的剩余部分。
	while (getPrecedence(@peek) >= precedence) {
		parsed = @ConditionalOrBinaryOrCallExpression(parsed, precedence, disallowIn);
	}
	return parsed;

ConditionalOrBinaryOrCallExpression(parsed: Expression, precedence: Precedence, disallowIn: boolean) // 条件或双目或调用表达式
	if (isAssignOperator(@peek)) {
		return @BinaryExpression(parsed, precedence, disallowIn);
	}
	switch(@peek) {
		MemberCallExpression(parsed: Expression) // 成员调用表达式(`x.y`)
			target:Expression . argument:IdentifierOrKeyword
		FunctionCallExpression(parsed: Expression) // 函数调用表达式(`x()`)

	}

# 语句

Statement: @abstract // 语句
	switch(@peek) {
		case <identifier>: return @LabeledOrExpressionStatement(@Identifier());
		case this:
		BlockStatement: // 语句块(`{...}`)
			{ statements:Statement... }
		case var: return @VariableStatement();
		case let: 
		case const:
			if (@isVariableStatement()) {
				return @parseVariableStatement();
			}
			break;
			@VariableStatement: // 变量声明语句(`var x`、`let x`、`const x`)
				type:var|let|const variables:VariableDeclaration,...
		FunctionDeclaration:
		ClassDeclaration:

		EmptyStatement: // 空语句(`;`)
			;
		IfStatement: // if 语句(`if(x) ...`)
			if ( condition:Expression ) then:Statement=@EmabledStatement() @if else else:Statement=@EmabledStatement() @endif
		SwitchStatement: // switch 语句(`switch(x) {...}`)
			switch ( condition:Expression ) { CaseClause... }
		ForStatement:
		WhileStatement:
		ExpressionStatement[?Yield]
		BreakableStatement[?Yield, ?Return]
		ContinueStatement[?Yield]
		BreakStatement[?Yield]
		ReturnStatement[?Yield]
		WithStatement[?Yield, ?Return]
		LabelledStatement[?Yield, ?Return]
		ThrowStatement[?Yield]
		TryStatement[?Yield, ?Return]
		DebuggerStatement
	}

