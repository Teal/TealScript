// TealScript 语法定义文件
// 此文件可用于生成 ts, nodeVisitor.ts, parser.ts。 

#region 类型

TypeNode: // 类型节点(number、string[]、...)
UnionOrIntersectionOrPrimaryTypeNode:
	UnionTypeNode: -> BinaryTypeNode
		UnionOrIntersectionOrPrimaryTypeNode | IntersectionOrPrimaryTypeNode
	IntersectionOrPrimaryTypeNode:
			IntersectionTypeNode: -> BinaryTypeNode
				IntersectionOrPrimaryTypeNode & PrimaryTypeNode
		PrimaryTypeNode:
				GenericTypeNode: // 泛型节点(Array<T>)。
					TypeName @nobr TypeArguments?
			TypeName:
					PredefinedTypeNode // 内置类型节点(number、string、...)
						any
						number
						boolean
						string
						symbol
						void
						never
						null
						*
						?
						this
					IdentifierTypeNode // 标识符类型节点(x)
					QualifiedNameTypeNode: // 限定名称类型节点("abc"、true)
						TypeName . IdentifierOrKeyword
				ParenthesizedTypeNode: // 括号类型节点((number))
					( body:TypeNode )
			ObjectTypeNode:
					{ TypeBody? }
			ArrayTypeNode:
					PrimaryTypeNode @nobr	[ ]
			TupleTypeNode:
					[ TupleElementTypes	]
				@TupleElementTypes:
					TupleElementTypeNode:
							TypeNode
						TupleElementTypes	, TupleElementTypeNode
				TypeQueryNode: // 类型查询节点(typeof x)。
					typeof operand:TypeQueryExpression
FunctionTypeNode:
	TypeParameterDeclarations? ParameterDeclarations@try => TypeNode
	ConstructorTypeNode: // 构造函数类型节点(new ()=>void)。
		new TypeParameterDeclarations? ParameterDeclarations => TypeNode

ParameterDeclarations: // @name=parameters
	( ParameterDeclarationList? )

TypeParameterDeclarations: // @name=typeParameters
	< TypeParameterDeclarationList	>

TypeParameterDeclarationList:
	TypeParameterDeclaration
	TypeParameterDeclarationList	, TypeParameterDeclaration

TypeParameterDeclaration:
	BindingIdentifier Constraint?

Constraint:
	extends TypeNode

TypeArguments:
	< TypeArgumentList	>

TypeArgumentList:
	TypeArgument
	TypeArgumentList	, TypeArgument

TypeArgument:
	TypeNode

TypeBody:
	TypeMemberList	;?
	TypeMemberList	,?

TypeMemberList:
	TypeMember
	TypeMemberList	; TypeMember
	TypeMemberList	, TypeMember

TypeMember:
	PropertySignature
	CallSignature
	ConstructSignature
	IndexSignature
	MethodSignature

TypeQueryExpression:
	IdentifierOrKeyword
	TypeQueryExpression	. IdentifierOrKeyword

PropertySignature:
	PropertyName ?? TypeAnnotation?

PropertyName:
	IdentifierOrKeyword
	StringLiteral
	NumericLiteral

TypeAnnotation:
	 TypeNode

CallSignature:
	TypeParameterDeclarations? ( ParameterDeclarationList? ) TypeAnnotation?

ParameterDeclarationList:
	RequiredParameterDeclarationList
	?ionalParameterDeclarationList
	RestParameter
	RequiredParameterDeclarationList	, ?ionalParameterDeclarationList
	RequiredParameterDeclarationList	, RestParameter
	?ionalParameterDeclarationList	, RestParameter
	RequiredParameterDeclarationList	, ?ionalParameterDeclarationList	, RestParameter

RequiredParameterDeclarationList:
	RequiredParameter
	RequiredParameterDeclarationList	, RequiredParameter

RequiredParameter:
	AccessibilityModifier? BindingIdentifierOrPattern TypeAnnotation?
	BindingIdentifier  StringLiteral

AccessibilityModifier:
	public
	private
	protected

BindingIdentifierOrPattern:
	BindingIdentifier
	BindingPattern

?ionalParameterDeclarationList:
	?ionalParameter
	?ionalParameterDeclarationList	, ?ionalParameter

?ionalParameter:
	AccessibilityModifier? BindingIdentifierOrPattern	? TypeAnnotation?
	AccessibilityModifier? BindingIdentifierOrPattern TypeAnnotation? Initializer
	BindingIdentifier ?  StringLiteral

RestParameter:
	... 	BindingIdentifier TypeAnnotation?

ConstructSignature:
	new TypeParameterDeclarations? ( ParameterDeclarationList? ) TypeAnnotation?

IndexSignature:
	[ BindingIdentifier  string ] TypeAnnotation
	[ BindingIdentifier  number ] TypeAnnotation

MethodSignature:
	PropertyName ?? CallSignature

#endregion

#region 表达式

CoverInitializedName
	IdentifierOrKeyword Initializer[In, ?Yield]
	@Initializer :
		= AssignmentExpression[?In, ?Yield]

TemplateLiteral[Yield] :
	NoSubstitutionTemplate
	TemplateHead Expression[In, ?Yield] TemplateSpans
	- TemplateSpans[Yield] :
		TemplateTail
		TemplateMiddleList TemplateTail
		@TemplateMiddleList[Yield] :
			TemplateMiddle Expression[In, ?Yield]
			TemplateMiddleList TemplateMiddle Expression[In, ?Yield]

#endregion

#region JSX 节点

#endregion

#region 语句

Statement[Yield, Return] :
	BlockStatement[?Yield, ?Return]
		Block[?Yield, ?Return]
			{ StatementList }
	VariableStatement
		var VariableDeclarationList[In, ?Yield] ;
		@VariableDeclarationList :
			VariableDeclaration[?In, ?Yield]
			VariableDeclarationList[?In, ?Yield] , VariableDeclaration[?In, ?Yield]
		@VariableDeclaration :
			BindingIdentifier Initializer[?In, ?Yield] ?
			BindingPattern Initializer[?In, ?Yield]
	EmptyStatement
		;
	ExpressionStatement 
		[lookahead ∉ { { , function , class , let [ }] Expression[In, ?Yield] ;
	IfStatement[?Yield, ?Return]
		if ( Expression[In, ?Yield] ) Statement[?Yield, ?Return] else Statement[?Yield, ?Return]
		if ( Expression[In, ?Yield] ) Statement[?Yield, ?Return]
	BreakableStatement[?Yield, ?Return]
		IterationStatement[?Yield, ?Return]
			do Statement[?Yield, ?Return] while ( Expression[In, ?Yield] ) ;
			while ( Expression[In, ?Yield] ) Statement[?Yield, ?Return]
			for ( [lookahead ∉ { let [ }] Expression ? ; Expression[In, ?Yield] ? ;
			Expression[In, ?Yield] ? ) Statement[?Yield, ?Return]
			for ( var VariableDeclarationList ; Expression[In, ?Yield] ? ; Expression[In, ?Yield] ? )
			Statement[?Yield, ?Return]
			for ( LexicalDeclaration Expression[In, ?Yield] ? ; Expression[In, ?Yield] ? )
			Statement[?Yield, ?Return]
			for ( [lookahead ∉ { let [ }] LeftHandSideExpression in Expression[In, ?Yield] )
			Statement[?Yield, ?Return]
			for ( var ForBinding in Expression[In, ?Yield] ) Statement[?Yield, ?Return]
			for ( ForDeclaration in Expression[In, ?Yield] ) Statement[?Yield, ?Return]
			for ( [lookahead ≠ let] LeftHandSideExpression of AssignmentExpression[In, ?Yield] )
			Statement[?Yield, ?Return]
			for ( var ForBinding of AssignmentExpression[In, ?Yield] ) Statement[?Yield, ?Return]
			for ( ForDeclaration of AssignmentExpression[In, ?Yield] ) Statement[?Yield, ?Return]
			@ForDeclaration[Yield] :
				LetOrConst ForBinding
				@ForBinding[Yield] :
					BindingIdentifier
					BindingPattern
		SwitchStatement[?Yield, ?Return]
			switch ( Expression[In, ?Yield] ) CaseBlock[?Yield, ?Return]
			@CaseBlock[Yield, Return] :
				{ CaseClauses[?Yield, ?Return] ? }
				{ CaseClauses[?Yield, ?Return] ? DefaultClause[?Yield, ?Return] CaseClauses[?Yield, ?Return] ? } 
			@CaseClauses[Yield, Return] :
				CaseClause[?Yield, ?Return]
				CaseClauses[?Yield, ?Return] CaseClause[?Yield, ?Return]
			@CaseClause[Yield, Return] :
				case Expression[In, ?Yield] : StatementList[?Yield, ?Return] ?
			@DefaultClause[Yield, Return] :
				default : StatementList[?Yield, ?Return] ?
	ContinueStatement
		continue ;
		continue @nobr IdentifierOrReserverdWord ;
	BreakStatement
		break ;
		break @nobr IdentifierOrReserverdWord ;
	[+Return] ReturnStatement
		return ;
		return @nobr Expression[In, ?Yield] ;
	WithStatement[?Yield, ?Return]
		with ( Expression[In, ?Yield] ) Statement[?Yield, ?Return]
	LabelledStatement[?Yield, ?Return]
		IdentifierOrReserverdWord : LabelledItem[?Yield, ?Return]
		@LabelledItem[Yield, Return] :
			Statement[?Yield, ?Return]
			FunctionDeclaration
	ThrowStatement
		throw @nobr Expression[In, ?Yield] ;
	TryStatement[?Yield, ?Return]
		try Block[?Yield, ?Return] Catch[?Yield, ?Return]
		try Block[?Yield, ?Return] Finally[?Yield, ?Return]
		try Block[?Yield, ?Return] Catch[?Yield, ?Return] Finally[?Yield, ?Return]
		@Catch[Yield, Return] :
			catch ( CatchParameter ) Block[?Yield, ?Return]
			@CatchParameter[Yield] :
				BindingIdentifier
				BindingPattern
		@Finally[Yield, Return] :
			finally Block[?Yield, ?Return]
	DebuggerStatement
		debugger ;

StatementList[Yield, Return] :
	StatementList[?Yield, ?Return] StatementListItem[?Yield, ?Return]
	StatementListItem[?Yield, ?Return]
		Statement[?Yield, ?Return]
		Declaration
			HoistableDeclaration
				FunctionDeclaration[?Yield, ?Default]
				GeneratorDeclaration[?Yield, ?Default]
					function * BindingIdentifier ( FormalParameters[Yield] ) { GeneratorBody }
					[+Default] function * ( FormalParameters[Yield] ) { GeneratorBody } 
			ClassDeclaration
				class BindingIdentifier ClassTail
				[+Default] class ClassTail
			LexicalDeclaration[In, ?Yield]
				LetOrConst BindingList[?In, ?Yield] ;
				@LetOrConst :
					let
					const
				@BindingList :
					BindingList[?In, ?Yield] , LexicalBinding[?In, ?Yield]
					LexicalBinding[?In, ?Yield]
						BindingIdentifier Initializer[?In, ?Yield] ?
						BindingPattern Initializer[?In, ?Yield]

BindingPattern[Yield] :
	ObjectBindingPattern
		{ }
		{ BindingPropertyList }
		{ BindingPropertyList , }
		@BindingPropertyList[Yield] :
			BindingPropertyList , BindingProperty
			BindingProperty
				SingleNameBinding
				PropertyName : BindingElement
	ArrayBindingPattern
		[ Elision? BindingRestElement ? ]
		[ BindingElementList ]
		[ BindingElementList , Elision? BindingRestElement ? ]
		@BindingElementList[Yield] :
			BindingElementList , BindingElisionElement
			BindingElisionElement
				Elision? BindingElement
		@BindingRestElement[Yield] :
			... 	BindingIdentifier
			... 	BindingPattern
	- BindingElement[Yield] :
		BindingPattern Initializer[In, ?Yield] ?
		SingleNameBinding
			BindingIdentifier Initializer[In, ?Yield] ?

AssignmentPattern[Yield] :
	ObjectAssignmentPattern
		{ }
		{ AssignmentPropertyList }
		{ AssignmentPropertyList , }
		@AssignmentPropertyList[Yield] :
			AssignmentPropertyList , AssignmentProperty
			AssignmentProperty
				IdentifierOrKeyword Initializer[In, ?Yield] ?
				PropertyName : AssignmentElement
	ArrayAssignmentPattern
		[ Elision? AssignmentRestElement ? ]
		[ AssignmentElementList ]
		[ AssignmentElementList , Elision? AssignmentRestElement ? ]
		@AssignmentRestElement[Yield] :
			... 	DestructuringAssignmentTarget
		@AssignmentElementList[Yield] :
			AssignmentElementList , AssignmentElisionElement
			AssignmentElisionElement
				Elision? AssignmentElement
	- AssignmentElement[Yield] :
		DestructuringAssignmentTarget Initializer[In, ?Yield] ?
			@DestructuringAssignmentTarget[Yield] :
				LeftHandSideExpression

#endregion

#region 声明

FunctionDeclaration[Yield, Default] :
	function BindingIdentifier ( FormalParameters ) { FunctionBody }
	[+Default] function ( FormalParameters ) { FunctionBody }

StrictFormalParameters[Yield] :
	FormalParameters

FormalParameters[Yield] :
	[empty]
	FormalParameterList

	FormalParameterList[Yield] : 
	FunctionRestParameter
	FormalsList
	FormalsList , FunctionRestParameter

FormalsList[Yield] :
	FormalParameter
	FormalsList , FormalParameter

FunctionRestParameter[Yield] :
	BindingRestElement

FormalParameter[Yield] :
	BindingElement

FunctionBody[Yield] :
	FunctionStatementList

FunctionStatementList[Yield] :
	StatementList[?Yield, Return] ?


	When the production ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList  is recognized the following
grammar is used to re伀氂ine the interpretation of CoverParenthesizedExpressionAndArrowParameterList:

ArrowFormalParameters[Yield] :
	( StrictFormalParameters )
	

MethodDefinition[Yield] :
	PropertyName ( StrictFormalParameters ) { FunctionBody }
	GeneratorMethod
		* PropertyName ( StrictFormalParameters[Yield] ) { GeneratorBody }
	get PropertyName ( ) { FunctionBody }
	set PropertyName ( PropertySetParameterList ) { FunctionBody }
PropertySetParameterList :
	FormalParameter

Script :
	ScriptBody?
ScriptBody :
	StatementList
Module :
	ModuleBody?
ModuleBody :
	ModuleItemList
ModuleItemList :
	ModuleItem
	ModuleItemList ModuleItem
ModuleItem :
	ImportDeclaration 
	ExportDeclaration
	StatementListItem
ImportDeclaration :
	import ImportClause FromClause ;
	import ModuleSpecifier ;

ImportClause :
	ImportedDefaultBinding
	NameSpaceImport
	NamedImports
	ImportedDefaultBinding , NameSpaceImport
	ImportedDefaultBinding , NamedImports

ImportedDefaultBinding :
	ImportedBinding
NameSpaceImport :
	* as ImportedBinding

NamedImports :
	{ }
	{ ImportsList }
	{ ImportsList , }

FromClause :
	from ModuleSpecifier

ImportsList :
	ImportSpecifier
	ImportsList , ImportSpecifier

ImportSpecifier :
	ImportedBinding
	IdentifierOrKeyword as ImportedBinding

ModuleSpecifier :
	StringLiteral
ImportedBinding :
	BindingIdentifier
ExportDeclaration :
	export * FromClause ;
	export ExportClause FromClause ;
	export ExportClause ;
	export VariableStatement
	export Declaration
	export default HoistableDeclaration[Default]
	export default ClassDeclaration[Default]
	export default [lookahead ∉ { function , class }] AssignmentExpression[In] ;
ExportClause :
	{ }
	{ ExportsList }
	{ ExportsList , } 
ExportsList :
	ExportSpecifier
	ExportsList , ExportSpecifier

ExportSpecifier :
	IdentifierOrKeyword
	IdentifierOrKeyword as IdentifierOrKeyword

#endregion

#region 源文件

#endregion

#region 词法

SourceCharacter :
	any Unicode code point

InputElementDiv :
	WhiteSpace
	LineTerminator
	Comment
	CommonToken
	DivPunctuator
	RightBracePunctuator
InputElementRegExp :
	WhiteSpace
	LineTerminator
	Comment
	CommonToken
	RightBracePunctuator
	RegularExpressionLiteral
InputElementRegExpOrTemplateTail :
	WhiteSpace
	LineTerminator
	Comment
	CommonToken
	RegularExpressionLiteral
	TemplateSubstitutionTail
InputElementTemplateTail :
	WhiteSpace
	LineTerminator
	Comment
	CommonToken
	DivPunctuator
	TemplateSubstitutionTail
WhiteSpace :
	<TAB>
	<VT>
	<FF>
	<SP>
	<NBSP>
	<ZWNBSP>
	<USP>

LineTerminator :
	<LF>
	
	<CR>
	<LS>
	<PS>

LineTerminatorSequence :
	<LF>
	<CR>[lookahead ≠ <LF>]
	<LS>
	<PS>
	<CR><LF>

Comment :
	MultiLineComment
	SingleLineComment
MultiLineComment :
	/* MultiLineCommentChars? */
MultiLineCommentChars :
	MultiLineNotAsteriskChar MultiLineCommentChars?
	* PostAsteriskCommentChars?
PostAsteriskCommentChars :
	MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars?
	* PostAsteriskCommentChars?
MultiLineNotAsteriskChar :
	SourceCharacter but not *

MultiLineNotForwardSlashOrAsteriskChar :
	SourceCharacter but not one of /  or *

SingleLineComment :
	// SingleLineCommentChars?
SingleLineCommentChars :
	SingleLineCommentChar SingleLineCommentChars?
SingleLineCommentChar :
	SourceCharacter but not LineTerminator
CommonToken :
	IdentifierOrKeyword
	Punctuator
	NumericLiteral
	StringLiteral
	Template
IdentifierOrKeyword :
	IdentifierStart
	IdentifierOrKeyword IdentifierPart
IdentifierStart :
	UnicodeIDStart
	$
	_
	\ UnicodeEscapeSequence 
IdentifierPart :
	UnicodeIDContinue
	$
	_
	\ UnicodeEscapeSequence
	<ZWNJ>
	<ZWJ>

UnicodeIDStart :
	any Unicode code point with the Unicode property “ID_Start”

UnicodeIDContinue :
	any Unicode code point with the Unicode property “ID_Continue”

ReservedWord :
	Keyword
	FutureReservedWord
	NullLiteral
	BooleanLiteral

Keyword : one of
	break do in typeof case else instanceof var catch export new void class extends return while
	const finally super with continue for switch yield debugger function this default if
	throw delete import try

FutureReservedWord :
	enum
	await

	await is only treated as a FutureReservedWord when Module is the goal symbol of the syntactic grammar.

The following tokens are also considered to be FutureReservedWords when parsing strict mode code:
	implements  package  protected 
	interface  private  public

Punctuator : one of
	{ ( ) [ ] . ... 	; , < > <= >= == != === !== + ‐ * % ++ ‐‐ << >> >>> & | ^ ! ~ && || ? : = +=
	‐= *= %= <<= >>= >>>= &= |= ^= => ** **=

DivPunctuator :
	/
	/=

RightBracePunctuator :
	}

NullLiteral :
	null

BooleanLiteral :
	true
	false

NumericLiteral :
	DecimalLiteral 
	BinaryIntegerLiteral
	OctalIntegerLiteral
	HexIntegerLiteral
DecimalLiteral :
	DecimalIntegerLiteral . DecimalDigits? ExponentPart?
	. DecimalDigits ExponentPart?
	DecimalIntegerLiteral ExponentPart?
DecimalIntegerLiteral :
	0
	NonZeroDigit DecimalDigits?
DecimalDigits :
	DecimalDigit
	DecimalDigits DecimalDigit
	DecimalDigit : one of
	0 1 2 3 4 5 6 7 8 9

	NonZeroDigit : one of
	1 2 3 4 5 6 7 8 9

ExponentPart :
	ExponentIndicator SignedInteger
	ExponentIndicator : one of
	e E

SignedInteger :
	DecimalDigits
	+ DecimalDigits
	‐ DecimalDigits

BinaryIntegerLiteral :
	0b BinaryDigits
	0B BinaryDigits

BinaryDigits :
	BinaryDigit
	BinaryDigits BinaryDigit
	BinaryDigit : one of
	0 1

OctalIntegerLiteral :
	0o OctalDigits
	0O OctalDigits

OctalDigits :
	OctalDigit
	OctalDigits OctalDigit
	OctalDigit : one of
	0 1 2 3 4 5 6 7

HexIntegerLiteral :
	0x HexDigits 
	0X HexDigits

HexDigits :
	HexDigit
	HexDigits HexDigit
	HexDigit : one of
	0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F

StringLiteral :
	" DoubleStringCharacters? "
	' SingleStringCharacters? '
DoubleStringCharacters :
	DoubleStringCharacter DoubleStringCharacters?
SingleStringCharacters :
	SingleStringCharacter SingleStringCharacters?
DoubleStringCharacter :
	SourceCharacter but not one of "  or \  or LineTerminator
	\ EscapeSequence
	LineContinuation
SingleStringCharacter :
	SourceCharacter but not one of '  or \  or LineTerminator
	\ EscapeSequence
	LineContinuation
LineContinuation :
	\ LineTerminatorSequence

EscapeSequence :
	CharacterEscapeSequence
	0 [lookahead ∉ DecimalDigit]
	HexEscapeSequence
	UnicodeEscapeSequence
CharacterEscapeSequence :
	SingleEscapeCharacter
	NonEscapeCharacter
	SingleEscapeCharacter : one of
	' " \ b f n r t v

NonEscapeCharacter :
	SourceCharacter but not one of EscapeCharacter  or LineTerminator
EscapeCharacter :
	SingleEscapeCharacter
	DecimalDigit
	x
	u

HexEscapeSequence :
	x HexDigit HexDigit

	UnicodeEscapeSequence : 
	u Hex4Digits
	u{ HexDigits }

Hex4Digits :
	HexDigit HexDigit HexDigit HexDigit
RegularExpressionLiteral :
	/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody :
	RegularExpressionFirstChar RegularExpressionChars
RegularExpressionChars :
	[empty]
	RegularExpressionChars RegularExpressionChar
RegularExpressionFirstChar :
	RegularExpressionNonTerminator but not one of *  or \  or /  or [
	RegularExpressionBackslashSequence
	RegularExpressionClass
RegularExpressionChar :
	RegularExpressionNonTerminator but not one of \  or /  or [
	RegularExpressionBackslashSequence
	RegularExpressionClass
RegularExpressionBackslashSequence :
	\ RegularExpressionNonTerminator

RegularExpressionNonTerminator :
	SourceCharacter but not LineTerminator
RegularExpressionClass :
	[ RegularExpressionClassChars ]

RegularExpressionClassChars :
	[empty]
	RegularExpressionClassChars RegularExpressionClassChar
RegularExpressionClassChar :
	RegularExpressionNonTerminator but not one of ]  or \
	RegularExpressionBackslashSequence
RegularExpressionFlags :
	[empty]
	RegularExpressionFlags IdentifierPart
Template :
	NoSubstitutionTemplate
	TemplateHead
NoSubstitutionTemplate :
	 TemplateCharacters? 
TemplateHead :
	 TemplateCharacters? ${
TemplateSubstitutionTail :
	TemplateMiddle 
	TemplateTail
TemplateMiddle :
	} TemplateCharacters? ${
TemplateTail :
	} TemplateCharacters? 
TemplateCharacters :
	TemplateCharacter TemplateCharacters?
TemplateCharacter :
	$ [lookahead ≠ {]
	\ EscapeSequence
	LineContinuation
	LineTerminatorSequence
	SourceCharacter but not one of   or \  or $  or LineTerminator
#endregion

A.6 Number Conversions

StringNumericLiteral ::
	StrWhiteSpace?
	StrWhiteSpace? StrNumericLiteral StrWhiteSpace?
StrWhiteSpace ::
	StrWhiteSpaceChar StrWhiteSpace?
StrWhiteSpaceChar ::
	WhiteSpace
	LineTerminator
StrNumericLiteral ::
	StrDecimalLiteral
	BinaryIntegerLiteral
	OctalIntegerLiteral
	HexIntegerLiteral
StrDecimalLiteral ::
	StrUnsignedDecimalLiteral
	+ StrUnsignedDecimalLiteral
	‐ StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral ::
	Infinity
	DecimalDigits . DecimalDigits? ExponentPart?
	. DecimalDigits ExponentPart?
	DecimalDigits ExponentPart?
DecimalDigits :
	DecimalDigit
	DecimalDigits DecimalDigit
	DecimalDigit : one of
	0 1 2 3 4 5 6 7 8 9

ExponentPart :
	ExponentIndicator SignedInteger
	ExponentIndicator : one of
	e E

SignedInteger :
	DecimalDigits
	+ DecimalDigits
	‐ DecimalDigits

	HexIntegerLiteral : 
	0x HexDigits
	0X HexDigits

	HexDigit : one of
	0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F

	All grammar symbols not explicitly de伀氂ined by the StringNumericLiteral grammar have the defininitions used in the Lexical
	Grammar for numeric literals.

	A.7 Universal Resource Identifier Character Classes

uri ::
	uriCharacters?
uriCharacters ::
	uriCharacter uriCharacters?
uriCharacter ::
	uriReserved
	uriUnescaped
	uriEscaped
	uriReserved :: one of
	; / ? : @ & = + $ ,

uriUnescaped ::
	uriAlpha
	DecimalDigit
	uriMark
uriEscaped ::
	% HexDigit HexDigit

	uriAlpha :: one of
	a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V
	W X Y Z

	uriMark :: one of
	‐ _ . ! ~ * ' ( )

	A.8 Regular Expressions

Pattern[U] :
	Disjunction[?U]

Disjunction[U] :
	Alternative[?U]
	Alternative[?U] | Disjunction[?U]

Alternative[U] :
	[empty]
	Alternative[?U] Term[?U]

Term[U] :
	Assertion[?U]
	Atom[?U] 
	Atom[?U] Quantifier

Assertion[U] :
	^
	$
	\ b
	\ B
	( ? = Disjunction[?U] )
	( ? ! Disjunction[?U] )
Quantifier :
	QuantifierPrefix
	QuantifierPrefix ?

QuantifierPrefix :
	*
	+
	?
	{ DecimalDigits }
	{ DecimalDigits , }
	{ DecimalDigits , DecimalDigits }

Atom[U] :
	PatternCharacter
	.
	\ AtomEscape[?U]
	CharacterClass[?U]
	( Disjunction[?U] )
	( ? : Disjunction[?U] )
	SyntaxCharacter : one of
	^ $ \ . * + ? ( ) [ ] { } |

PatternCharacter :
	SourceCharacter but not SyntaxCharacter

AtomEscape[U] :
	DecimalEscape
	CharacterEscape[?U]
	CharacterClassEscape

CharacterEscape[U] :
	ControlEscape
	c ControlLetter
	HexEscapeSequence
	RegExpUnicodeEscapeSequence[?U]
	IdentityEscape[?U]
	ControlEscape : one of
	f n r t v

	ControlLetter : one of
	a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V
	W X Y Z 
RegExpUnicodeEscapeSequence[U] :
	[+U] u LeadSurrogate \u TrailSurrogate
	[+U] u LeadSurrogate
	[+U] u TrailSurrogate
	[+U] u NonSurrogate
	[~U] u Hex4Digits
	[+U] u{ HexDigits }

	Each \u TrailSurrogate for which the choice of associated u LeadSurrogate is ambiguous shall be associated with the nearest
	possible u LeadSurrogate that would otherwise have no corresponding \u TrailSurrogate.

	
LeadSurrogate :
	Hex4Digits but only if the SV of Hex4Digits  is in the inclusive range 0xD800 to 0xDBFF
TrailSurrogate :
	Hex4Digits but only if the SV of Hex4Digits  is in the inclusive range 0xDC00 to 0xDFFF
NonSurrogate :
	Hex4Digits but only if the SV of Hex4Digits  is not in the inclusive range 0xD800 to 0xDFFF

IdentityEscape[U] :
	[+U] SyntaxCharacter
	[+U] /
	[~U] SourceCharacter but not UnicodeIDContinue
DecimalEscape :
	DecimalIntegerLiteral [lookahead ∉ DecimalDigit]
	CharacterClassEscape : one of
	d D s S w W

CharacterClass[U] :
	[ [lookahead ∉ { ^ }] ClassRanges[?U] ]
	[ ^ ClassRanges[?U] ]

ClassRanges[U] :
	[empty]
	NonemptyClassRanges[?U]

NonemptyClassRanges[U] :
	ClassAtom[?U]
	ClassAtom[?U] NonemptyClassRangesNoDash[?U]
	ClassAtom[?U] ‐ ClassAtom[?U] ClassRanges[?U]

NonemptyClassRangesNoDash[U] :
	ClassAtom[?U]
	ClassAtomNoDash[?U] NonemptyClassRangesNoDash[?U]
	ClassAtomNoDash[?U] ‐ ClassAtom[?U] ClassRanges[?U]

ClassAtom[U] :
	‐
	ClassAtomNoDash[?U]

	ClassAtomNoDash[U] : 
	SourceCharacter but not one of \  or ]  or ‐
	\ ClassEscape[?U]

ClassEscape[U] :
	DecimalEscape
	b
	[+U] ‐
	CharacterEscape[?U]
	CharacterClassEscape 

NumericLiteral :
	DecimalLiteral
	BinaryIntegerLiteral
	OctalIntegerLiteral
	HexIntegerLiteral
	LegacyOctalIntegerLiteral
LegacyOctalIntegerLiteral :
	0 OctalDigit
	LegacyOctalIntegerLiteral OctalDigit
DecimalIntegerLiteral :
	0
	NonZeroDigit DecimalDigits?
	NonOctalDecimalIntegerLiteral
NonOctalDecimalIntegerLiteral :
	0 NonOctalDigit
	LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit
	NonOctalDecimalIntegerLiteral DecimalDigit
LegacyOctalLikeDecimalIntegerLiteral :
	0 OctalDigit
	LegacyOctalLikeDecimalIntegerLiteral OctalDigit
	NonOctalDigit : one of
	
EscapeSequence :
	CharacterEscapeSequence
	LegacyOctalEscapeSequence
	HexEscapeSequence
	UnicodeEscapeSequence
LegacyOctalEscapeSequence :
	OctalDigit [lookahead ∉ OctalDigit]
	ZeroToThree OctalDigit [lookahead ∉ OctalDigit]
	FourToSeven OctalDigit
	ZeroToThree OctalDigit OctalDigit
	ZeroToThree : one of
	0 1 2 3

	FourToSeven : one of
	4 5 6 7

Comment :
	MultiLineComment
	SingleLineComment
	SingleLineHTMLOpenComment
	SingleLineHTMLCloseComment
	SingleLineDelimitedComment
MultiLineComment :
	/* FirstCommentLine? LineTerminator MultiLineCommentChars? */ HTMLCloseComment?
FirstCommentLine :
	SingleLineDelimitedCommentChars
SingleLineHTMLOpenComment :
	<!‐‐ SingleLineCommentChars?
SingleLineHTMLCloseComment :
	LineTerminatorSequence HTMLCloseComment
SingleLineDelimitedComment :
	/* SingleLineDelimitedCommentChars? */
HTMLCloseComment :
	WhiteSpaceSequence? SingleLineDelimitedCommentSequence? ‐‐> SingleLineCommentChars?
SingleLineDelimitedCommentChars :
	SingleLineNotAsteriskChar SingleLineDelimitedCommentChars?
	* SingleLinePostAsteriskCommentChars?
SingleLineNotAsteriskChar :
	SourceCharacter but not one of *  or LineTerminator

SingleLinePostAsteriskCommentChars :
	SingleLineNotForwardSlashOrAsteriskChar SingleLineDelimitedCommentChars?
	* SingleLinePostAsteriskCommentChars?
SingleLineNotForwardSlashOrAsteriskChar :
	SourceCharacter but not one of /  or *  or LineTerminator

WhiteSpaceSequence :
	WhiteSpace WhiteSpaceSequence?
	SingleLineDelimitedCommentSequence : 
	SingleLineDelimitedComment WhiteSpaceSequence? SingleLineDelimitedCommentSequence?

Term[U] :
	[+U] Assertion[U]
	[+U] Atom[U]
	[+U] Atom[U] Quantifier
	[~U] QuantifiableAssertion Quantifier
	[~U] Assertion
	[~U] ExtendedAtom Quantifier
	[~U] ExtendedAtom

Assertion[U] :
	^
	$
	\ b
	\ B
	[+U] ( ? = Disjunction[U] )
	[+U] ( ? ! Disjunction[U] )
	[~U] QuantifiableAssertion
QuantifiableAssertion :
	( ? = Disjunction )
	( ? ! Disjunction )

ExtendedAtom :
	.
	\ AtomEscape
	CharacterClass
	( Disjunction )
	( ? : Disjunction )
	InvalidBracedQuantifier
	ExtendedPatternCharacter
InvalidBracedQuantifier :
	{ DecimalDigits }
	{ DecimalDigits , }
	{ DecimalDigits , DecimalDigits }

ExtendedPatternCharacter :
	SourceCharacter but not one of ^ $ . * + ? ( ) [ | 
AtomEscape[U] :
	[+U] DecimalEscape
	[+U] CharacterEscape[U]
	[+U] CharacterClassEscape
	[~U] DecimalEscape but only if the integer value of DecimalEscape  is <= _NcapturingParens_
	[~U] CharacterClassEscape
	[~U] CharacterEscape

CharacterEscape[U] :
	ControlEscape
	c ControlLetter
	HexEscapeSequence
	RegExpUnicodeEscapeSequence[?U]
	[~U] LegacyOctalEscapeSequence
	IdentityEscape[?U]

IdentityEscape[U] :
	[+U] SyntaxCharacter
	[+U] /
	[~U] SourceCharacter but not c

NonemptyClassRanges[U] :
	ClassAtom[?U]
	ClassAtom[?U] NonemptyClassRangesNoDash[?U]
	[+U] ClassAtom[U] ‐ ClassAtom[U] ClassRanges[U]
	[~U] ClassAtomInRange ‐ ClassAtomInRange ClassRanges

NonemptyClassRangesNoDash[U] :
	ClassAtom[?U]
	ClassAtomNoDash[?U] NonemptyClassRangesNoDash[?U]
	[+U] ClassAtomNoDash[U] ‐ ClassAtom[U] ClassRanges[U]
	[~U] ClassAtomNoDashInRange ‐ ClassAtomInRange ClassRanges

ClassAtom[U] :
	‐
	ClassAtomNoDash[?U]

ClassAtomNoDash[U] :
	\ ClassEscape[?U]
	SourceCharacter but not one of ]  or ‐

ClassAtomInRange :
	‐
	ClassAtomNoDashInRange
ClassAtomNoDashInRange :
	\ ClassEscape
	SourceCharacter but not one of ]  or ‐

ClassEscape[U] :
	b
	[+U] DecimalEscape
	[+U] CharacterEscape[U]
	[+U] CharacterClassEscape 
	[+U] ‐
	[~U] DecimalEscape but only if the integer value of DecimalEscape  is 0
	[~U] CharacterClassEscape
	[~U] c ClassControlLetter
	[~U] CharacterEscape
ClassControlLetter :
	DecimalDigit
	


# 词法

SourceCharacter ::
	[any Unicode code point]

InputElementDiv :: WhiteSpace
	LineTerminator
	Comment
	CommonToken
	DivPunctuator
	RightBracePunctuator

InputElementRegExp :: WhiteSpace
	LineTerminator
	Comment
	CommonToken
	RightBracePunctuator
	RegularExpressionLiteral

InputElementRegExpOrTemplateTail ::
	WhiteSpace
	LineTerminator
	Comment
	CommonToken
	RegularExpressionLiteral
	TemplateSubstitutionTail

InputElementTemplateTail ::
	WhiteSpace
	LineTerminator
	Comment
	CommonToken
	DivPunctuator
	TemplateSubstitutionTail

WhiteSpace ::
	<TAB>
	<VT>
	<FF>
	<SP>
	<NBSP>
	<ZWNBSP>
	<USP>

LineTerminator ::
	<LF>
	<CR>
	<LS>
	<PS>

LineTerminatorSequence ::
	<LF>
	<CR> [lookahead ≠ <LF> ]
	<LS>
	<PS>
	<CR> <LF>

Comment ::
	MultiLineComment
	SingleLineComment

MultiLineComment ::
	/* MultiLineCommentChars[opt] */

MultiLineCommentChars ::
	MultiLineNotAsteriskChar MultiLineCommentChars[opt]
	*	PostAsteriskCommentChars[opt]

PostAsteriskCommentChars ::
	MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars[opt]
	*	PostAsteriskCommentChars[opt]

MultiLineNotAsteriskChar ::
	SourceCharacter [but not] *

MultiLineNotForwardSlashOrAsteriskChar ::
	SourceCharacter [but not] [one of] / [or] *

SingleLineComment ::
	// SingleLineCommentChars[opt]

SingleLineCommentChars ::
	SingleLineCommentChar SingleLineCommentChars[opt]

SingleLineCommentChar ::
	SourceCharacter [but not] LineTerminator

CommonToken ::
	IdentifierName Punctuator
	NumericLiteral
	StringLiteral
	Template

IdentifierName ::
	IdentifierStart
	IdentifierName IdentifierPart

IdentifierStart ::
	UnicodeIDStart
	$
	_
	\ UnicodeEscapeSequence


IdentifierPart ::
	UnicodeIDContinue
	$
	_
	\ UnicodeEscapeSequence
	<ZWNJ>
	<ZWJ> 	11.6

UnicodeIDStart ::
	[any Unicode code point with the Unicode property “ID_Start” or “Other_ID_Start”]

UnicodeIDContinue ::
	[any Unicode code point with the Unicode property “ID_Continue”, “Other_ID_Continue”, or “Other_ID_Start”]

ReservedWord ::
	Keyword
	FutureReservedWord
	NullLiteral
	BooleanLiteral

Keyword :: [one of]
	break 		do  		in  		typeof
	case 		else 		instanceof  var
	catch 		export  	new 		void
	class  		extends 	return 		while
	const 		finally 	super 		with
	continue 	for 		switch 		yield
	debugger  	function 	this
	default 	if 			throw
	delete 		import 		try

FutureReservedWord :: [one of]
	enum  		await[remark]
	implements 	package 	protected
	interface 	private 	public

Punctuator :: [one of]
	{	} 	( 	) 	[ 	]
	.	; 	, 	< 	> 	<=
	>= 	== 	!= 	=== 	!==
	+ 	- 	* 	% 	++ 	--
	<< 	>> 	>>> 	& 	| 	^
	! 	~ 	&& 	|| 	? 	:
	= 	+= 	-= 	*= 	%= 	<<=
	>>= 	>>>= 	&= 	|= 	^= 	=>

DivPunctuator :: [one of]
	/
	/=

RightBracePunctuator :: [one of]
	}

NullLiteral ::
	null

BooleanLiteral ::
	true
	false

NumericLiteral ::
	DecimalLiteral
	BinaryIntegerLiteral
	OctalIntegerLiteral
	HexIntegerLiteral

DecimalLiteral ::
	DecimalIntegerLiteral . DecimalDigits[opt] ExponentPart[opt]
	. DecimalDigits ExponentPart[opt]
	DecimalIntegerLiteral ExponentPart[opt]

DecimalIntegerLiteral ::
	0
	NonZeroDigit DecimalDigits[opt]

DecimalDigits ::
	DecimalDigit
	DecimalDigits DecimalDigit

DecimalDigit :: [one of]
	0	1  2  3  4  5  6  7  8  9

NonZeroDigit :: [one of]
	1	2  3  4  5  6  7  8  9

ExponentPart ::
	ExponentIndicator SignedInteger

ExponentIndicator :: [one of]
	e  E

SignedInteger ::
	DecimalDigits
	+ DecimalDigits
	- DecimalDigits

BinaryIntegerLiteral ::
	0b BinaryDigits
	0B BinaryDigits

BinaryDigits ::
	BinaryDigit
	BinaryDigits BinaryDigit

BinaryDigit :: [one of]
	0  1

OctalIntegerLiteral ::
	0o OctalDigits
	0O OctalDigits

OctalDigits ::
	OctalDigit
	OctalDigits OctalDigit

OctalDigit :: [one of]
	0  1  2  3  4  5  6  7

HexIntegerLiteral ::
	0x HexDigits
	0X HexDigits

HexDigits ::
	HexDigit
	HexDigits HexDigit

HexDigit :: [one of]
	0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F

StringLiteral ::
	" DoubleStringCharacters[opt] "
	' SingleStringCharacters[opt] '

DoubleStringCharacters ::
	DoubleStringCharacter DoubleStringCharacters[opt]

SingleStringCharacters ::
	SingleStringCharacter SingleStringCharacters[opt]

DoubleStringCharacter ::
	SourceCharacter [but not] [one of] " [or] \ [or] LineTerminator
	\ EscapeSequence
	LineContinuation

SingleStringCharacter ::
	SourceCharacter [but not] [one of] ' [or] \ [or] LineTerminator
	\ EscapeSequence
	LineContinuation

LineContinuation ::
	\ LineTerminatorSequence

EscapeSequence ::
	CharacterEscapeSequence
	0 [lookahead ∉ DecimalDigit]
	HexEscapeSequence
	UnicodeEscapeSequence

CharacterEscapeSequence ::
	SingleEscapeCharacter
	NonEscapeCharacter

SingleEscapeCharacter ::  [one of]
	'  "  \  b  f  n  r  t  v

NonEscapeCharacter ::
	SourceCharacter [but not] [one of] EscapeCharacter [or] LineTerminator

EscapeCharacter ::
	SingleEscapeCharacter DecimalDigit x u

HexEscapeSequence ::
	x HexDigit HexDigit

UnicodeEscapeSequence ::
	u Hex4Digits  u{ HexDigits }

Hex4Digits ::
	HexDigit HexDigit HexDigit HexDigit

RegularExpressionLiteral ::
	/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody ::
	RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars ::
	[empty]
	RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar ::
	RegularExpressionNonTerminator [but not] [one of] * [or] \ [or] / [or] [
	RegularExpressionBackslashSequence RegularExpressionClass

RegularExpressionChar ::
	RegularExpressionNonTerminator [but not] [one of] \ [or] / [or] [
	RegularExpressionBackslashSequence RegularExpressionClass

RegularExpressionBackslashSequence ::
	\ RegularExpressionNonTerminator

RegularExpressionNonTerminator ::
	SourceCharacter [but not] LineTerminator

RegularExpressionClass ::
	[ RegularExpressionClassChars ]

RegularExpressionClassChars ::
	[empty]
	RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar ::
	RegularExpressionNonTerminator [but not] [one of] ] [or] \
	RegularExpressionBackslashSequence

RegularExpressionFlags ::
	[empty]
	RegularExpressionFlags IdentifierPart

Template ::
	NoSubstitutionTemplate
	TemplateHead 	11.8.6

NoSubstitutionTemplate ::  
	` TemplateCharacters[opt] `

TemplateHead ::
	` TemplateCharacters[opt] ${

TemplateSubstitutionTail ::
	TemplateMiddle  TemplateTail

TemplateMiddle ::
	} TemplateCharacters[opt] ${

TemplateTail ::
	} TemplateCharacters[opt] `

TemplateCharacters ::
	TemplateCharacter TemplateCharacters[opt]

TemplateCharacter ::
	$ [lookahead ≠ { ]
	\ EscapeSequence
	LineContinuation
	LineTerminatorSequence
	SourceCharacter [but not] [one of] ` [or] \ [or] $ [or] LineTerminator

# 表达式

IdentifierReference[Yield] :
	Identifier
	[~Yield]  yield

BindingIdentifier[Yield]  :
	Identifier
	[~Yield]  yield

LabelIdentifier[Yield] :
	Identifier
	[~Yield]  yield

Identifier :
	IdentifierName [but not] ReservedWord

PrimaryExpression[Yield] :
	IdentifierReference[?Yield]
	ClassExpression[?Yield] 

PropertyDefinitionList[Yield] :
	PropertyDefinition[?Yield]
	PropertyDefinitionList[?Yield] , PropertyDefinition[?Yield]

PropertyDefinition[Yield] :
	IdentifierReference[?Yield]
	CoverInitializedName[?Yield]

PropertyName[?Yield] : 
	AssignmentExpression[In, ?Yield]
	MethodDefinition[?Yield]

CoverInitializedName[Yield]  :
	IdentifierReference[?Yield] Initializer[In, ?Yield]

Initializer[In, Yield] :
	= AssignmentExpression[?In, ?Yield]

# 语句

Statement[Yield, Return] :
	BlockStatement[?Yield, ?Return]
	VariableStatement[?Yield]
	EmptyStatement
	ExpressionStatement[?Yield]
	IfStatement[?Yield, ?Return]
	BreakableStatement[?Yield, ?Return]
	ContinueStatement[?Yield]
	BreakStatement[?Yield]
	[+Return] ReturnStatement[?Yield]
	WithStatement[?Yield, ?Return]
	LabelledStatement[?Yield, ?Return]
	ThrowStatement[?Yield]
	TryStatement[?Yield, ?Return]
	DebuggerStatement

Declaration[Yield] :
	HoistableDeclaration[?Yield]
	ClassDeclaration[?Yield]
	LexicalDeclaration[In, ?Yield]

HoistableDeclaration[Yield, Default] :
	FunctionDeclaration[?Yield,?Default] GeneratorDeclaration[?Yield, ?Default]

BreakableStatement[Yield, Return] :
	IterationStatement[?Yield, ?Return]
	SwitchStatement[?Yield, ?Return]

BlockStatement[Yield, Return] :
	Block[?Yield, ?Return]

Block[Yield, Return] :
	{ StatementList[?Yield, ?Return][opt] }

StatementList[Yield, Return] :
	StatementListItem[?Yield, ?Return]
	StatementList[?Yield, ?Return] StatementListItem[?Yield, ?Return]

StatementListItem[Yield, Return] :
	Statement[?Yield, ?Return]
	Declaration[?Yield]

LexicalDeclaration[In, Yield] :
	LetOrConst BindingList[?In, ?Yield] ;

LetOrConst : [one of]
	let const

BindingList[In, Yield] :
	LexicalBinding[?In, ?Yield]
	BindingList[?In, ?Yield] , LexicalBinding[?In, ?Yield]

LexicalBinding[In, Yield]  :
	BindingIdentifier[?Yield]  Initializer[?In, ?Yield][opt]
	BindingPattern[?Yield]   Initializer[?In, ?Yield]

VariableStatement[Yield] :
	var VariableDeclarationList[In, ?Yield] ;

VariableDeclarationList[In, Yield] :
	VariableDeclaration[?In, ?Yield]
	VariableDeclarationList[?In, ?Yield] , VariableDeclaration[?In, ?Yield]

VariableDeclaration[In, Yield] :
	BindingIdentifier[?Yield] Initializer[?In, ?Yield][opt]
	BindingPattern[?Yield]  Initializer[?In, ?Yield]

BindingPattern[Yield] :
	ObjectBindingPattern[?Yield]
	ArrayBindingPattern[?Yield]

ObjectBindingPattern[Yield] :
	{ }
	{ BindingPropertyList[?Yield] }
	{ BindingPropertyList[?Yield] , }

ArrayBindingPattern[Yield] :
	[ Elision[opt] BindingRestElement[?Yield][opt] ]
	[ BindingElementList[?Yield] ]
	[ BindingElementList[?Yield] , Elision[opt] BindingRestElement[?Yield][opt] ]

BindingPropertyList[Yield] :
	BindingProperty[?Yield]
	BindingPropertyList[?Yield] , BindingProperty[?Yield]

BindingElementList[Yield] :
	BindingElisionElement[?Yield]
	BindingElementList[?Yield] , BindingElisionElement[?Yield]

BindingElisionElement[Yield] :
	Elision[opt]  BindingElement[?Yield]

BindingProperty[Yield] :
	SingleNameBinding[?Yield]

PropertyName[?Yield] :
	BindingElement[?Yield]

BindingElement[Yield] :
	SingleNameBinding[?Yield]
	BindingPattern[?Yield] Initializer[In, ?Yield][opt]

SingleNameBinding[Yield]  :
	BindingIdentifier[?Yield] Initializer[In, ?Yield][opt]

BindingRestElement[Yield] :
	... BindingIdentifier[?Yield]

EmptyStatement :
	;

ExpressionStatement[Yield] :
	[lookahead ∉ {{, function,  class,  let [ }] Expression[In, ?Yield] ;

IfStatement[Yield, Return] :
	if ( Expression[In, ?Yield] ) Statement[?Yield, ?Return]  else Statement[?Yield, ?Return]
	if ( Expression[In, ?Yield] ) Statement[?Yield, ?Return]

IterationStatement[Yield, Return] :
	do Statement[?Yield, ?Return] while ( Expression[In, ?Yield] ) ; while ( Expression[In, ?Yield] ) Statement[?Yield, ?Return]
	for ( [lookahead ∉ {let [ }] Expression[?Yield][opt] ; Expression[In, ?Yield][opt] ; Expression[In, ?Yield][opt] ) Statement[?Yield, ?Return]
	for ( var VariableDeclarationList[?Yield]; Expression[In, ?Yield][opt] ; Expression[In, ?Yield][opt] ) Statement[?Yield, ?Return]
	for ( LexicalDeclaration[?Yield]  Expression[In, ?Yield][opt] ; Expression[In, ?Yield][opt] ) Statement[?Yield, ?Return]
	for ( [lookahead ∉ {let [ }] LeftHandSideExpression[?Yield] in Expression[In, ?Yield] ) Statement[?Yield, ?Return] 
	for ( var ForBinding[?Yield] in Expression[In, ?Yield] ) Statement[?Yield, ?Return]
	for ( ForDeclaration[?Yield]  in Expression[In, ?Yield] ) Statement[?Yield, ?Return]
	for ( [lookahead ≠ let] LeftHandSideExpression[?Yield] of AssignmentExpression[In, ?Yield] ) Statement[?Yield, ?Return]
	for ( var ForBinding[?Yield] of AssignmentExpression[In, ?Yield] ) Statement[?Yield, ?Return]
	for ( ForDeclaration[?Yield]  of AssignmentExpression[In, ?Yield] ) Statement[?Yield, ?Return]

ForDeclaration[Yield] :
	LetOrConst  ForBinding[?Yield]

ForBinding[Yield] :
	BindingIdentifier[?Yield]
	BindingPattern[?Yield]

ContinueStatement[Yield]  :
	continue ;
	continue [no LineTerminator here] LabelIdentifier[?Yield] ;

BreakStatement[Yield]  :
	break ;
	break [no LineTerminator here]  LabelIdentifier[?Yield] ;

ReturnStatement[Yield] :
	return ;
	return [no LineTerminator here] Expression[In, ?Yield] ;

WithStatement[Yield, Return] :
	with ( Expression[In, ?Yield] ) Statement[?Yield, ?Return]

SwitchStatement[Yield, Return] :
	switch ( Expression[In, ?Yield] ) CaseBlock[?Yield, ?Return]

CaseBlock[Yield, Return] :
	{ CaseClauses[?Yield, ?Return][opt] }
	{ CaseClauses[?Yield, ?Return][opt] DefaultClause[?Yield, ?Return]  CaseClauses[?Yield, ?Return][opt] }

CaseClauses[Yield, Return] :
	CaseClause[?Yield, ?Return]
	CaseClauses[?Yield, ?Return] CaseClause[?Yield, ?Return]

CaseClause[Yield, Return] :
	case Expression[In, ?Yield] : StatementList[?Yield, ?Return][opt]

DefaultClause[Yield, Return] :
	default : StatementList[?Yield, ?Return][opt]

LabelledStatement[Yield, Return] :
	LabelIdentifier[?Yield] : LabelledItem[?Yield, ?Return]

LabelledItem[Yield, Return] :
	Statement[?Yield, ?Return]
	FunctionDeclaration[?Yield]

ThrowStatement[Yield] :
	throw [no LineTerminator here] Expression[In, ?Yield] ;

TryStatement[Yield, Return] :
	try Block[?Yield, ?Return] Catch[?Yield, ?Return] try Block[?Yield, ?Return] Finally[?Yield, ?Return] try Block[?Yield, ?Return] Catch[?Yield, ?Return]  Finally[?Yield, ?Return]

Catch[Yield, Return] :
	catch ( CatchParameter[?Yield] ) Block[?Yield, ?Return]

Finally[Yield, Return] :
	finally Block[?Yield, ?Return]

CatchParameter[Yield] :
	BindingIdentifier[?Yield]
	BindingPattern[?Yield]

DebuggerStatement :
	debugger ;

# 成员声明

FunctionDeclaration[Yield, Default]  :
	function BindingIdentifier[?Yield] ( FormalParameters ) { FunctionBody }
	[+Default] function ( FormalParameters ) { FunctionBody }

FunctionExpression :
	function BindingIdentifier[opt] ( FormalParameters ) { FunctionBody }

StrictFormalParameters[Yield] :
	FormalParameters[?Yield]

FormalParameters[Yield] :
	[empty]
	FormalParameterList[?Yield]

FormalParameterList[Yield]  :
	FunctionRestParameter[?Yield]
	FormalsList[?Yield]
	FormalsList[?Yield], FunctionRestParameter[?Yield]

FormalsList[Yield] :
	FormalParameter[?Yield]
	FormalsList[?Yield] , FormalParameter[?Yield]

FunctionRestParameter[Yield] :
	BindingRestElement[?Yield]

FormalParameter[Yield] :
	BindingElement[?Yield]

FunctionBody[Yield] :
	FunctionStatementList[?Yield]

FunctionStatementList[Yield] :
	StatementList[?Yield, Return][opt]

ArrowFunction[In, Yield]  :
	ArrowParameters[?Yield] [no LineTerminator here]  => ConciseBody[?In]

ArrowParameters[Yield]  :
	BindingIdentifier[?Yield]
	CoverParenthesizedExpressionAndArrowParameterList[?Yield]

MethodDefinition[Yield] :
	PropertyName[?Yield] ( StrictFormalParameters )  { FunctionBody }   GeneratorMethod[?Yield]
	get PropertyName[?Yield] ( )  { FunctionBody }  set PropertyName[?Yield] ( PropertySetParameterList ) { FunctionBody }

PropertySetParameterList :
	FormalParameter

GeneratorMethod[Yield]  :
	* PropertyName[?Yield] (StrictFormalParameters[Yield] )  { GeneratorBody }

GeneratorDeclaration[Yield, Default] :
	function * BindingIdentifier[?Yield] ( FormalParameters[Yield] ) { GeneratorBody }
	[+Default] function * ( FormalParameters[Yield] ) { GeneratorBody }

GeneratorExpression :
	function * BindingIdentifier[Yield][opt] ( FormalParameters[Yield] ) { GeneratorBody }

GeneratorBody  :
	FunctionBody[Yield]

ClassDeclaration[Yield, Default] :
	class BindingIdentifier[?Yield]  ClassTail[?Yield]
	[+Default] class ClassTail[?Yield]

ClassExpression[Yield] :
	class BindingIdentifier[?Yield][opt]  ClassTail[?Yield]

ClassTail[Yield] :
	ClassHeritage[?Yield][opt]  { ClassBody[?Yield][opt] }

ClassHeritage[Yield] :
	extends LeftHandSideExpression[?Yield]

ClassBody[Yield] :  	14.5
	ClassElementList[?Yield]

ClassElementList[Yield] :  	14.5
	ClassElement[?Yield]
	ClassElementList[?Yield]  ClassElement[?Yield]

ClassElement[Yield] :
	MethodDefinition[?Yield]  static MethodDefinition[?Yield]
	;

# 源文件

Script :
	ScriptBody[opt]

ScriptBody :
	StatementList

Module :
	ModuleBody[opt]

ModuleBody :
	ModuleItemList

ModuleItemList :
	ModuleItem
	ModuleItemList  ModuleItem

ModuleItem :
	ImportDeclaration
	ExportDeclaration
	StatementListItem

ImportDeclaration :
	import  ImportClause FromClause ;
	import  ModuleSpecifier ;

ImportClause :
	ImportedDefaultBinding
	NameSpaceImport
	NamedImports
	ImportedDefaultBinding , NameSpaceImport
	ImportedDefaultBinding , NamedImports

ImportedDefaultBinding :
	ImportedBinding

NamedImports :
	{  }
	{  ImportsList }
	{  ImportsList , }

FromClause :
	from ModuleSpecifier

ImportsList :
	ImportSpecifier
	ImportsList ,  ImportSpecifier

ImportSpecifier :
	ImportedBinding
	IdentifierName as  ImportedBinding

ModuleSpecifier :
	StringLiteral

ImportedBinding :
	BindingIdentifier

ExportDeclaration :
	export *  FromClause ; 
	export  ExportClause  FromClause ; 
	export  ExportClause  ; export  VariableStatement  export  Declaration   export default HoistableDeclaration[Default] export default ClassDeclaration[Default] export default [lookahead ∉ { function, class }]  AssignmentExpression[In] ;

ExportClause :
	{  }
	{  ExportsList }
	{  ExportsList , }

ExportsList :
	ExportSpecifier
	ExportsList ,  ExportSpecifier

ExportSpecifier :
	IdentifierName
	IdentifierName as  IdentifierName

# 数字

StringNumericLiteral :::
	StrWhiteSpace[opt]
	StrWhiteSpace[opt] StrNumericLiteral StrWhiteSpace[opt]

StrWhiteSpace :::
	StrWhiteSpaceChar StrWhiteSpace[opt]

StrWhiteSpaceChar ::: WhiteSpace
	LineTerminator

StrNumericLiteral :::
	StrDecimalLiteral
	BinaryIntegerLiteral OctalIntegerLiteral
	HexIntegerLiteral

StrDecimalLiteral :::
	StrUnsignedDecimalLiteral
	+ StrUnsignedDecimalLiteral
	- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral :::
	Infinity
	DecimalDigits . DecimalDigits[opt] ExponentPart[opt]
	. DecimalDigits ExponentPart[opt]
	DecimalDigits ExponentPart[opt]

DecimalDigits :::
	DecimalDigit
	DecimalDigits DecimalDigit

DecimalDigit ::: [one of]
	0  1  2  3  4  5  6  7  8  9

ExponentPart :::
	ExponentIndicator SignedInteger

ExponentIndicator ::: [one of]
	e  E

SignedInteger :::
	DecimalDigits
	+ DecimalDigits
	- DecimalDigits

HexIntegerLiteral ::: 0x HexDigit
	0X HexDigit
	HexIntegerLiteral HexDigit

HexDigit ::: [one of]
	0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F

# URI

uri :::
	uriCharacters[opt]

uriCharacters :::
	uriCharacter 
	uriCharacters[opt]

uriCharacter ::: 
	uriReserved 
	uriUnescaped 
	uriEscaped

uriReserved ::: [one of]
	;  /  ?  :  @  &  =  +  $  ,

uriUnescaped :::
	uriAlpha DecimalDigit uriMark

uriEscaped :::
	% HexDigit HexDigit

uriAlpha ::: [one of]
	a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z

uriMark ::: [one of]
	-  _  .  !  ~  *  '  (  )
	A.8 Regular Expressions

Pattern[U] ::
	Disjunction[?U]

Disjunction[U] ::
	Alternative[?U]
	 Alternative[?U] | Disjunction[?U]

Alternative[U] ::
	[empty]
	Alternative[?U] Term[?U]

Term[U] ::
	Assertion[?U]
	Atom[?U]
	Atom[?U] Quantifier

Assertion[U] ::
	^
	$
	\ b
	\ B
	( ? = Disjunction[?U] )
	( ? ! Disjunction[?U] )

Quantifier ::
	QuantifierPrefix
	QuantifierPrefix ?

QuantifierPrefix ::
	*
	+ ?
	{ DecimalDigits }
	{ DecimalDigits , }
	{ DecimalDigits , DecimalDigits }

Atom[U] ::
	PatternCharacter .
	\ AtomEscape[?U] CharacterClass[?U]
	( Disjunction[?U] )
	( ? : Disjunction[?U] )

SyntaxCharacter :: [one of]
	^  $  \  .  *  +  ?  (  )  [  ]  {  }  |

PatternCharacter ::
	SourceCharacter [but not] SyntaxCharacter

AtomEscape[U] ::  DecimalEscape
	CharacterEscape[?U]
	CharacterClassEscape

CharacterEscape[U] ::  ControlEscape c ControlLetter
	HexEscapeSequence
	RegExpUnicodeEscapeSequence[?U]
	IdentityEscape[?U]

ControlEscape ::  [one of]
	f  n  r  t  v

ControlLetter :: [one of]
	a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z

RegExpUnicodeEscapeSequence[U]  ::
	[+U] u LeadSurrogate \u TrailSurrogate
	[+U] u LeadSurrogate
	[+U] u TrailSurrogate
	[+U] u NonSurrogate
	[~U] u Hex4Digits
	[+U] u{ HexDigits }
	Each \u TrailSurrogate for which the choice of associated u LeadSurrogate is ambiguous shall be associated with the nearest possible u LeadSurrogate that would otherwise have no corresponding \u TrailSurrogate.

LeadSurrogate  ::
	Hex4Digits [match only if the SV of Hex4Digits is in the inclusive range 0xD800 to 0xDBFF]

TrailSurrogate  ::
	Hex4Digits [match only if the SV of Hex4Digits is in the inclusive range 0xDC00 to 0xDFFF]

NonSurrogate  ::
	Hex4Digits [match only if the SV of Hex4Digits is not in the inclusive range 0xD800 to 0xDFFF]

IdentityEscape[U] ::
	[+U] SyntaxCharacter
	[+U]  /
	[~U] SourceCharacter [but not] UnicodeIDContinue

DecimalEscape ::
	DecimalIntegerLiteral  [lookahead ∉ DecimalDigit]

CharacterClassEscape ::  [one of]
	d  D  s  S  w  W

CharacterClass[U]  ::
	[ [lookahead ∉ {^}] ClassRanges[?U] ]
	[ ^ ClassRanges[?U] ]

ClassRanges[U] ::
	[empty]
	NonemptyClassRanges[?U]

NonemptyClassRanges[U] ::
	ClassAtom[?U]
	ClassAtom[?U]  NonemptyClassRangesNoDash[?U]
	ClassAtom[?U] - ClassAtom[?U] ClassRanges[?U]

NonemptyClassRangesNoDash[U] ::
	ClassAtom[?U]
	ClassAtomNoDash[?U] NonemptyClassRangesNoDash[?U]
	ClassAtomNoDash[?U] - ClassAtom[?U] ClassRanges[?U]

ClassAtom[U] ::
	-
	ClassAtomNoDash[?U]

ClassAtomNoDash[U] ::
	SourceCharacter  [but not] [one of] \ [or] ] [or] -
	\ ClassEscape[?U]

ClassEscape[U] ::
	DecimalEscape b
	[+U] -
	CharacterEscape[?U]
	CharacterClassEscape

# TypeScript 新增

# 类型

TypeParameters:
	< TypeParameterList >

TypeParameterList:
	TypeParameter
	TypeParameterList , TypeParameter

TypeParameter:
	BindingIdentifier Constraint[opt]

Constraint:
	extends Type

TypeArguments:
	< TypeArgumentList >

TypeArgumentList:
	TypeArgument
	TypeArgumentList , TypeArgument

TypeArgument:
	Type

Type:
	UnionOrIntersectionOrPrimaryType
	FunctionType
	ConstructorType

UnionOrIntersectionOrPrimaryType:
	UnionType
	IntersectionOrPrimaryType

IntersectionOrPrimaryType:
	IntersectionType
	PrimaryType

PrimaryType:
	ParenthesizedType
	PredefinedType
	TypeReference
	ObjectType
	ArrayType TupleType
	TypeQuery ThisType

ParenthesizedType:
	( Type )

PredefinedType:	 [one of]
	any number boolean string symbol void

TypeReference:
	TypeName [no LineTerminator here] TypeArguments[opt]

TypeName:
	IdentifierReference
	NamespaceName . IdentifierReference

NamespaceName:
	IdentifierReference
	NamespaceName . IdentifierReference

ObjectType:
	{ TypeBody[opt] }

TypeBody:
	TypeMemberList ;[opt]
	TypeMemberList ,[opt]

TypeMemberList:
	TypeMember
	TypeMemberList ; TypeMember
	TypeMemberList , TypeMember

TypeMember:
	PropertySignature
	CallSignature
	ConstructSignature
	IndexSignature
	MethodSignature

ArrayType:
	PrimaryType [no LineTerminator here] [ ]

TupleType:
	[ TupleElementTypes ]

TupleElementTypes:
	TupleElementType
	TupleElementTypes , TupleElementType

TupleElementType:
	Type

UnionType:
	UnionOrIntersectionOrPrimaryType | IntersectionOrPrimaryType

IntersectionType:
	IntersectionOrPrimaryType & PrimaryType

FunctionType:
	TypeParameters[opt] ( ParameterList[opt] ) => Type

ConstructorType:
	new TypeParameters[opt] ( ParameterList[opt] ) => Type

TypeQuery:
	typeof TypeQueryExpression

TypeQueryExpression:
	IdentifierReference
	TypeQueryExpression . IdentifierName

ThisType:
	this

PropertySignature:
	PropertyName ?[opt] TypeAnnotation[opt]

PropertyName:
	IdentifierName
	StringLiteral
	NumericLiteral

TypeAnnotation:
	:	 Type

CallSignature:
	TypeParameters[opt] ( ParameterList[opt] ) TypeAnnotation[opt]

ParameterList:
	RequiredParameterList
	OptionalParameterList
	RestParameter
	RequiredParameterList , OptionalParameterList
	RequiredParameterList , RestParameter
	OptionalParameterList , RestParameter
	RequiredParameterList , OptionalParameterList , RestParameter

RequiredParameterList:
	RequiredParameter
	RequiredParameterList , RequiredParameter

RequiredParameter:
	AccessibilityModifier[opt] BindingIdentifierOrPattern TypeAnnotation[opt]

BindingIdentifier :
	StringLiteral

AccessibilityModifier:
	public private protected

BindingIdentifierOrPattern:
	BindingIdentifier BindingPattern

OptionalParameterList:
	OptionalParameter
	OptionalParameterList , OptionalParameter

OptionalParameter:
	AccessibilityModifier[opt] BindingIdentifierOrPattern ? TypeAnnotation[opt]
	AccessibilityModifier[opt] BindingIdentifierOrPattern TypeAnnotation[opt] Initializer
	BindingIdentifier ? :	 StringLiteral

RestParameter:
	... BindingIdentifier TypeAnnotation[opt]

ConstructSignature:	 new TypeParameters[opt] ( ParameterList[opt] ) TypeAnnotation[opt]

IndexSignature:
	[ BindingIdentifier :	 string ] TypeAnnotation
	[ BindingIdentifier :	 number ] TypeAnnotation

MethodSignature:
	PropertyName ?[opt] CallSignature

TypeAliasDeclaration:
	type BindingIdentifier TypeParameters[opt] = Type ;

# 表示

PropertyDefinition:	  [Modified]
	IdentifierReference
	CoverInitializedName

PropertyName :
	AssignmentExpression
	PropertyName CallSignature { FunctionBody }
	GetAccessor SetAccessor

GetAccessor:
	get PropertyName ( ) TypeAnnotation[opt] { FunctionBody }

SetAccessor:
	set PropertyName ( BindingIdentifierOrPattern TypeAnnotation[opt] ) { FunctionBody }

FunctionExpression:
	[Modified]function BindingIdentifier[opt] CallSignature { FunctionBody }

ArrowFormalParameters:	  [Modified]
	CallSignature

Arguments:	  [Modified]
	TypeArguments[opt] ( ArgumentList[opt] )

UnaryExpression:	  [Modified]
	…
	< Type > UnaryExpression

Declaration:	  [Modified]…
	InterfaceDeclaration
	TypeAliasDeclaration EnumDeclaration

VariableDeclaration:	  [Modified]
	SimpleVariableDeclaration
	DestructuringVariableDeclaration

SimpleVariableDeclaration:
	BindingIdentifier TypeAnnotation[opt] Initializer[opt]

DestructuringVariableDeclaration:
	BindingPattern TypeAnnotation[opt] Initializer

LexicalBinding:	  [Modified]SimpleLexicalBinding
	DestructuringLexicalBinding

SimpleLexicalBinding:
	BindingIdentifier TypeAnnotation[opt] Initializer[opt]

DestructuringLexicalBinding:
	BindingPattern TypeAnnotation[opt] Initializer[opt]

FunctionDeclaration:
	[Modified]function BindingIdentifier[opt] CallSignature { FunctionBody } function BindingIdentifier[opt] CallSignature ;

InterfaceDeclaration:
	interface BindingIdentifier TypeParameters[opt] InterfaceExtendsClause[opt] ObjectType

InterfaceExtendsClause:
	extends ClassOrInterfaceTypeList

ClassOrInterfaceTypeList:
	ClassOrInterfaceType
	ClassOrInterfaceTypeList , ClassOrInterfaceType

ClassOrInterfaceType:
	TypeReference

ClassDeclaration:
	[Modified]class BindingIdentifier[opt] TypeParameters[opt] ClassHeritage { ClassBody }

ClassHeritage:	  [Modified]
	ClassExtendsClause[opt] ImplementsClause[opt]

ClassExtendsClause:
	extends  ClassType

ClassType:
	TypeReference

ImplementsClause:
	implements ClassOrInterfaceTypeList

ClassElement:	  [Modified]
	ConstructorDeclaration
	PropertyMemberDeclaration IndexMemberDeclaration

ConstructorDeclaration:
	AccessibilityModifier[opt] constructor ( ParameterList[opt] ) { FunctionBody } AccessibilityModifier[opt] constructor ( ParameterList[opt] ) ;

PropertyMemberDeclaration:
	MemberVariableDeclaration
	MemberFunctionDeclaration MemberAccessorDeclaration

MemberVariableDeclaration:
	AccessibilityModifier[opt] static[opt] PropertyName TypeAnnotation[opt] Initializer[opt] ;

MemberFunctionDeclaration:
	AccessibilityModifier[opt] static[opt] PropertyName CallSignature { FunctionBody }
	AccessibilityModifier[opt] static[opt] PropertyName CallSignature ;

MemberAccessorDeclaration:
	AccessibilityModifier[opt] static[opt] GetAccessor AccessibilityModifier[opt] static[opt]

SetAccessorIndexMemberDeclaration:
	IndexSignature ;

EnumDeclaration:
	const[opt] enum BindingIdentifier { EnumBody[opt] }

EnumBody:
	EnumMemberList ,[opt]

EnumMemberList:
	EnumMember
	EnumMemberList , EnumMember

EnumMember:
	PropertyName
	PropertyName = EnumValue

EnumValue:
	AssignmentExpression

NamespaceDeclaration:
	namespace IdentifierPath { NamespaceBody }

IdentifierPath:
	BindingIdentifier
	IdentifierPath . BindingIdentifier

NamespaceBody:
	NamespaceElements[opt]

NamespaceElements:
	NamespaceElement
	NamespaceElements NamespaceElement

NamespaceElement:
	Statement
	LexicalDeclaration
	FunctionDeclaration
	GeneratorDeclaration
	ClassDeclaration
	InterfaceDeclaration
	TypeAliasDeclaration
	EnumDeclaration
	NamespaceDeclaration
	AmbientDeclaration
	ImportAliasDeclaration
	ExportNamespaceElement

ExportNamespaceElement:
	export VariableStatement
	export LexicalDeclaration
	export FunctionDeclaration
	export GeneratorDeclaration
	export ClassDeclaration
	export InterfaceDeclaration
	export TypeAliasDeclaration
	export EnumDeclaration
	export NamespaceDeclaration
	export AmbientDeclaration
	export ImportAliasDeclaration

ImportAliasDeclaration:
	import BindingIdentifier = EntityName ;

EntityName:
	NamespaceName
	NamespaceName . IdentifierReference

SourceFile:
	ImplementationSourceFile
	DeclarationSourceFile

ImplementationSourceFile:
	ImplementationScript
	ImplementationModule

DeclarationSourceFile:
	DeclarationScript
	DeclarationModule

ImplementationScript:
	ImplementationScriptElements[opt]

ImplementationScriptElements:
	ImplementationScriptElement
	ImplementationScriptElements ImplementationScriptElement

ImplementationScriptElement:
	ImplementationElement
	AmbientModuleDeclaration

ImplementationElement:
	Statement
	LexicalDeclaration
	FunctionDeclaration
	GeneratorDeclaration
	ClassDeclaration
	InterfaceDeclaration
	TypeAliasDeclaration
	EnumDeclaration
	NamespaceDeclaration
	AmbientDeclaration
	ImportAliasDeclaration

DeclarationScript:
	DeclarationScriptElements[opt]

DeclarationScriptElements:
	DeclarationScriptElement
	DeclarationScriptElements DeclarationScriptElement

DeclarationScriptElement:
	DeclarationElement
	AmbientModuleDeclaration

DeclarationElement:
	InterfaceDeclaration
	TypeAliasDeclaration
	NamespaceDeclaration AmbientDeclaration
	ImportAliasDeclaration

ImplementationModule:
	ImplementationModuleElements[opt]

ImplementationModuleElements:
	ImplementationModuleElement
	ImplementationModuleElements ImplementationModuleElement

ImplementationModuleElement:
	ImplementationElement
	ImportDeclaration
	ImportAliasDeclaration
	ImportRequireDeclaration
	ExportImplementationElement
	ExportDefaultImplementationElement
	ExportListDeclaration ExportAssignment

DeclarationModule:
	DeclarationModuleElements[opt]

DeclarationModuleElements:
	DeclarationModuleElement
	DeclarationModuleElements DeclarationModuleElement

DeclarationModuleElement:
	DeclarationElement
	ImportDeclaration
	ImportAliasDeclaration
	ExportDeclarationElement
	ExportDefaultDeclarationElement
	ExportListDeclaration ExportAssignment

ImportRequireDeclaration:
	import BindingIdentifier = require ( StringLiteral ) ;

ExportImplementationElement:
	export VariableStatement
	export LexicalDeclaration
	export FunctionDeclaration
	export GeneratorDeclaration
	export ClassDeclaration
	export InterfaceDeclaration
	export TypeAliasDeclaration
	export EnumDeclaration
	export NamespaceDeclaration
	export AmbientDeclaration
	export ImportAliasDeclaration

ExportDeclarationElement:
	export InterfaceDeclaration
	export TypeAliasDeclaration
	export AmbientDeclaration
	export ImportAliasDeclaration

ExportDefaultImplementationElement:
	export default FunctionDeclaration
	export default GeneratorDeclaration
	export default ClassDeclaration
	export default AssignmentExpression ;

ExportDefaultDeclarationElement:
	export default AmbientFunctionDeclaration
	export default AmbientClassDeclaration
	export default IdentifierReference ;

ExportListDeclaration:
	export * FromClause ;
	export ExportClause FromClause ;
	export ExportClause ;

ExportAssignment:
	export = IdentifierReference ;


AmbientDeclaration:
	declare AmbientVariableDeclaration
	declare AmbientFunctionDeclaration
	declare AmbientClassDeclaration
	declare AmbientEnumDeclaration
	declare AmbientNamespaceDeclaration

AmbientVariableDeclaration:
	var AmbientBindingList ;
	let AmbientBindingList ;
	const AmbientBindingList ;

AmbientBindingList:
	AmbientBinding
	AmbientBindingList , AmbientBinding

AmbientBinding:
	BindingIdentifier TypeAnnotation[opt]

AmbientFunctionDeclaration:
	function BindingIdentifier CallSignature ;

AmbientClassDeclaration:
	class BindingIdentifier TypeParameters[opt] ClassHeritage { AmbientClassBody }

AmbientClassBody:
	AmbientClassBodyElements[opt]

AmbientClassBodyElements:
	AmbientClassBodyElement
	AmbientClassBodyElements AmbientClassBodyElement

AmbientClassBodyElement:
	AmbientConstructorDeclaration
	AmbientPropertyMemberDeclaration IndexSignature

AmbientConstructorDeclaration:	 constructor ( ParameterList[opt] ) ;

AmbientPropertyMemberDeclaration:
	AccessibilityModifier[opt] static[opt] PropertyName TypeAnnotation[opt] ;
	AccessibilityModifier[opt] static[opt] PropertyName CallSignature ;

AmbientEnumDeclaration:
	EnumDeclaration

AmbientNamespaceDeclaration:
	namespace IdentifierPath { AmbientNamespaceBody }

AmbientNamespaceBody:
	AmbientNamespaceElements[opt]

AmbientNamespaceElements:
	AmbientNamespaceElement
	AmbientNamespaceElements AmbientNamespaceElement

AmbientNamespaceElement:
	export[opt] AmbientVariableDeclaration
	export[opt] AmbientLexicalDeclaration
	export[opt] AmbientFunctionDeclaration
	export[opt] AmbientClassDeclaration
	export[opt] InterfaceDeclaration
	export[opt] AmbientEnumDeclaration
	export[opt] AmbientNamespaceDeclaration
	export[opt] ImportAliasDeclaration

AmbientModuleDeclaration:
	declare module StringLiteral {  DeclarationModule }

# TealScript 新增

IterationStatement[Yield, Return] :
	for ( [lookahead ∉ {let [ }] LeftHandSideExpression[?Yield] to Expression[In, ?Yield] ) Statement[?Yield, ?Return] 
	for ( var ForBinding[?Yield] to Expression[In, ?Yield] ) Statement[?Yield, ?Return]
	for ( ForDeclaration[?Yield]  to Expression[In, ?Yield] ) Statement[?Yield, ?Return]

WithStatement[Yield, Return] :
	with ( var ForBinding[?Yield] ) Statement[?Yield, ?Return]
	with ( var ForDeclaration[?Yield] ) Statement[?Yield, ?Return]
